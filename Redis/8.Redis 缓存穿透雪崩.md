

大量的请求直接落在数据库上，而没有经过redis缓存



### Redis 缓存穿透



用户要请求一个数据，发现redis中没有，查询数据库也没有，当用户发送大量请求时，缓存都没有命中，都去请求了持久层数据库，就出现了缓存穿透



解决方案：

- [ ] 布隆过滤器

  将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力

  

- [ ] 缓存空对象，无论是否命中都保存一个值，并设置过期时间，但这种方法会存在两个问题：

  如果空值能够被缓存起来，缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键

  即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间数据不一致，比如请求时没有，但在key还没过期时新增请求的数据，导致请求到redis中的空值而查不到数据

  





### Redis 缓存击穿



缓存击穿是指一个key在数据库中，这个key一般是热点数据，但在redis中过期，此时若有大量并发请求过来，可能会瞬间把数据库压垮



解决方案：

- [ ] 使用互斥锁 mutex key

  在缓存失效的时候不是立即去请求数据库，而是先使用缓存工具的某些带成功操作返回值的操作，比如Redis的SETNX或者Memcache的ADD去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存，否则就重试整个get缓存的方法

  SETNX「SET if Not eXists」：

  ```java
  public String get(key) {
      
      String value = redis.get(key);
      //代表缓存值过期
      if (value == null) { 
          //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
          if (redis.setnx(key_mutex, 1, 3 * 60) == 1) { 
              //查数据库
              value = db.get(key);
              redis.set(key, value, expire_secs);
              redis.del(key_mutex);
          } else { 
              //这个时候代表其他线程已经load db并回设到缓存了，重试获取缓存值
              sleep(50);
              get(key);  //重试
          }
      } else {
          return value; 
      }
   }
  ```

  





### Redis 雪崩



缓存雪崩是指，redis缓存出现错误不能正常工作或者大面积的key在同一时间过期，所有请求都到数据库，造成数据库挂掉的情况



解决方案：

- [ ] redis集群高可用

- [ ] 限流降级

  在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量，比如对某个key只允许一个线程查询数据和写缓存，其他线程等待

- [ ] 数据预热

  先把可能的数据访问一遍，这样部分可能大量访问的数据就会加载到缓存中，在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀