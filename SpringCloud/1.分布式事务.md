

分布式事务其实是由多个本地事务组合而成，对于分布式事务而言几乎满足不了 `ACID`，其实对于单机事务而言大部分情况下也没有满足 ACID，不然也不会有四种隔离级别



### 2PC

2PC `Two-phase commit protocol` 二阶段提交，是一种强一致性设计，他引入一个事务协调者的角色来协调管理各参与者/本地资源的提交和回滚，二阶段分别指的是准备/投票和提交两个阶段



1. 准备阶段：协调者会给各参与者发送准备命令，同步等待所有资源的响应之后就进入提交阶段，提交阶段不一定是提交事务，也可能是回滚事务
2. 假如在第一阶段所有参与者都返回准备成功，那么协调者则向所有参与者发送提交事务命令，然后等待所有事务都提交成功之后，返回事务执行成功
3. 假如在第一阶段有一个参与者返回失败，那么协调者就会向所有参与者发送回滚事务的请求
4. 若在第二阶段提交失败，则不断重试，直到所有参与者全部回滚



2PC 是一个同步阻塞协议，第一阶段协调者会等待所有参与者响应才会进行下一步操作，当然第一阶段的协调者有超时机制，假设因为网络原因没有收到某参与者的响应或某参与者挂了，那么超时后就会判断事务失败，向所有参与者发送回滚命令









### 3PC

3PC 解决 了2PC 的一些问题，相比于 2PC 它在参与者中也引入了超时机制，并且新增了一个阶段使得参与者可以利用这一个阶段统一各自的状态

3PC 包含了三个阶段，分别是准备阶段，预提交阶段和提交阶段，对应的英文：`CanCommit, PreCommit, DoCommit` 





2PC方案的问题：

1. 同步阻塞。
2. 数据不一致。
3. 单点问题。

升级的3PC方案旨在解决这些问题，主要有两个改进：

1. 增加超时机制。

2. 两阶段之间插入准备阶段。

   



### TCC

2PC 和 3PC 都是数据库层面的，而 TCC  `Try - Confirm - Cancel` 是业务层面的分布式事务：

1. Try 指的是预留，即资源的预留和锁定
2. Confirm 指的是确认操作，这一步其实就是真正的执行
3. Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销



TCC从思想上看和 2PC 差不多，都是先试探性的执行，如果都可以那就真正的执行，如果不行就回滚



TCC流程还是很简单的，难点在于业务上的定义，对于每一个操作你都需要定义三个动作分别对应`Try - Confirm - Cancel`，因此 TCC 对业务的侵入较大和业务紧耦合，需要根据特定的场景和业务逻辑来设计相应的操作



撤销和确认操作的执行可能需要重试，因此还需要保证操作的幂等







### 本地消息表













































































































































