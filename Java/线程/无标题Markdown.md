
#### [参考](https://www.javazhiyin.com/63460.html)

每个线程都有一个自己的本地内存空间--线程栈空间，线程执行时，先把变量从主内存读取到线程自己的本地内存空间，然后再对该变量进行操作，对该变量操作完后，在某个时间再把变量刷新回主内存

`volatile` 关键字的作用是：使变量在多个线程间可见

`volatile`   修饰的变量不保证对它的操作（自增）具有原子性,对于自增操作，可以使用JAVA的原子类 `AutoicInteger` 保证原子自增

仅靠  `volatile`  不能保证线程的安全性,  `volatile`  关键字修饰的变量不会被指令重排序优化

#### volatile 与 synchronized 的比较
volatile主要用在多个线程感知实例变量被更改了场合，从而使得各个线程获得最新的值,它强制线程每次从主内存中讲到变量，而不是从线程的私有内存中读取变量，从而保证了数据的可见性

比较：

①volatile轻量级，只能修饰变量。synchronized重量级，还可修饰方法

②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。

synchronized不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。

四，线程安全性
线程安全性包括两个方面，①可见性。②原子性。

从上面自增的例子中可以看出：仅仅使用volatile并不能保证线程安全性。而synchronized则可实现线程的安全性。


#### Executor

Executor 管理多个异步任务的执行，无需显式地管理线程的生命周期，异步指多个任务的执行互不干扰，不需要进行同步操作