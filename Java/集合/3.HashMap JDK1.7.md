



HashMap 的默认初始大小为16，初始化大小必须为2的幂，最大大小为2的30次方。数组中存储的链表节点Entry 类实现于Map.Entry 接口，它实现了对节点的通用操作



HashMap 的阈值默认为“容量*0.75f”，当存储节点数量超过该值，则对map 进行扩容处理。

HashMap 提供了4种构造方法，分别是**默认构造**方法；可以**指定初始容量的构造**方法；可以**指定初始容量和阈值的构造**方法以及**基于一个Map 的构造**方法。虽然是构造函数，但是真正的初始化都是在第一次添加操作里面实现的。

在第一次添加操作中，HashMap 会先判断存储数组有没有初始化，如果没有先进行初始化操作，初始化过程中会取比用户指定的容量大的最近的2 的幂次方数作为数组的初始容量，并更新扩容的阈值





### HashMap的添加流程



1. 先判断有没有初始化
2. 再判断传入的key 是否为空，为空保存在table[o] 位置
3. key 不为空就对key 进hash，hash 的结果再& 数组的长度就得到存储的位置
4. 如果存储位置为空则创建节点，不为空就说明存在冲突
5. 解决冲突HashMap 会先遍历链表，如果有相同的value 就更新旧值，否则构建节点添加到链表头
6. 添加还要先判断存储的节点数量是否达到阈值，到达阈值要进行扩容
7. 扩容扩2倍，是新建数组所以要先转移节点，转移时都重新计算存储位置，可能保持不变可能为旧容量+位置。
8. 扩容结束后新插入的元素也得再hash 一遍才能插入



### 获取节点

1. 先判断是否为空，为空就在table[0] 去找值
2. 不为空也是先hash,&数组长度计算下标位置
3. 再遍历找相同的key 返回值





HashMap 是一个并发不安全的容器，在迭代操作是采用的是fast-fail 机制；在并发添加操作中会出现丢失更新的问题；因为采用头插法在并发扩容时会产生环形链表的问题，导致CPU 到达100%，甚至宕机

解决并发问题可以采用

1. Java 类库提供的Collections 工具包下的`Collections.synchronizedMap()`方法，返回一个线程安全的Map
2. 或者使用并发包下的 `ConcurrentHashMap`，ConcurrentHashMap采用分段锁机制实现线程安全
3. 使用HashTable （不推荐）









































































































