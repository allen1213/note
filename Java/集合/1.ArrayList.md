





`ArrayList `底层用数组实现，继承于 `AbstractList`，实现了 `List、RandomAccess、Cloneable、java.io.Serializable `接口

- [ ] AbstractList实现了List，它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能
- [ ] RandomAccess 是一个标志接口，实现这个接口的 List 集合支持快速随机访问，即可以通过元素的序号快速获取元素对象
- [ ] Cloneable 接口，覆盖了函数 clone()，能被克隆
- [ ] Serializable 接口，支持序列化**，**能通过序列化去传输
- [ ] ArrayList 线程不安全，在多线程中可以选择 `Vector `或者 `CopyOnWriteArrayList`









### 核心源码

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    private static final long serialVersionUID = 8683452581122892189L;

    
    //默认初始容量大小
    private static final int DEFAULT_CAPACITY = 10;

    
    //空数组，用于空实例
    private static final Object[] EMPTY_ELEMENTDATA = {};
    

    //不指定大小时，会使用该变量赋值给下面的 elementData
    //初始时是空数组 当添加第一个元素的时候数组容量才变成10
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    
    //保存ArrayList数据的数组
    transient Object[] elementData;

    
    //ArrayList 所包含的元素个数
    private int size;
    
    
    //...
}
```



带初始容量参数的构造函数

```java
public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        //如果传入的参数大于0，创建initialCapacity大小的数组
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        //如果传入的参数等于0，创建空数组
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        //其他情况，抛出异常
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    }
}
```



默认无参构造函数

```java
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
```



构造一个包含指定集合的元素的列表，按照参数中集合的迭代器返回的顺序

```java
public ArrayList(Collection<? extends E> c) {
    //将指定集合转换为数组
    elementData = c.toArray();
    //如果elementData数组的长度不为0
    if ((size = elementData.length) != 0) {
        // 如果elementData不是Object类型数据
        // c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断  
        if (elementData.getClass() != Object[].class)
            //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        // 其他情况，用空数组代替
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
```



修改ArrayList实例的容量是列表的当前大小， 可以使用此操作来最小化ArrayList实例的存储

```java
public void trimToSize() {
    modCount++;
    if (size < elementData.length) {
        elementData = (size == 0)
            ? EMPTY_ELEMENTDATA
            : Arrays.copyOf(elementData, size);
    }
}
```



ArrayList扩容机制

```java
/**
* 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量
* @param   minCapacity   所需的最小容量
*/
public void ensureCapacity(int minCapacity) {
    //如果是true，minExpand的值为0，如果是false,minExpand的值为10
    int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
        // any size if not default element table
        ? 0
        // larger than default for default empty table. It's already
        // supposed to be at default size.
        : DEFAULT_CAPACITY;
    //如果最小容量大于已有的最大容量
    if (minCapacity > minExpand) {
        ensureExplicitCapacity(minCapacity);
    }
}
```



获取最小扩容量

```java
private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        // 获取“默认的容量”和“传入参数”两者之间的最大值
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}
```



判断是否需要扩容

```java
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        //调用grow方法进行扩容，调用此方法代表已经开始扩容了
        grow(minCapacity);
}
```



要分配的最大数组大小

```java
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
```



ArrayList核心扩容方法

```java
private void grow(int minCapacity) {
    // oldCapacity为旧容量，newCapacity为新容量
    int oldCapacity = elementData.length;
    //将oldCapacity 右移一位，其效果相当于oldCapacity /2，
    //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    //再检查新容量是否超出了ArrayList所定义的最大容量，
    //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，
    //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```



https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList.md#arraylist%E7%AE%80%E4%BB%8B