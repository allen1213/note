

### 为什么要使用缓存

在并发量比较高的系统中，缓存可以提高程序查询/执行效率，减轻数据库的压力









### 1.Redis的好处

1. 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)

2. 支持丰富数据类型，支持string，list，set，sorted set，hash

3. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

4. 可用于缓存，消息，按key设置过期时间，过期后将会自动删除



### 1.redis相比memcached有哪些优势

共同点：

1. 都基于内存，一般都用来做缓存，性能高
2. 都有过期策略

不同点：

1. memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
2. redis可以持久化其数据，memcached断电后数据会丢失
3. redis支持原生集群
4. memcached 多线程，非阻塞IO复用网络模型；redis单线程采用IO多路复用模型
5. redis支持发布订阅，LUA脚本，事务等
6. memcached仅支持惰性删除，而redis支持惰性+定期删除







### 1.Redis如何实现分布式锁

Redis要实现分布式锁，以下条件应该得到满足：

1. 互斥性：在任意时刻，只有一个客户端能持有锁
2. 不能死锁：客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁
3. 容错性：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁



使用Redis做分布式锁的思路大概是这样的：在redis中设置一个值表示加了锁，然后释放锁的时候就把这个key删除,具体代码是这样的：

```
// 获取锁
// NX是指如果key不存在就成功，key存在返回false，PX可以指定过期时间
SET anyLock unique_value NX PX 30000


// 释放锁：通过执行一段lua脚本
// 释放锁涉及到两条指令，这两条指令不是原子性的
// 需要用到redis的lua脚本支持特性，redis执行lua脚本是原子性的
if redis.call("get",KEYS[1]) == ARGV[1] then
return redis.call("del",KEYS[1])
else
return 0
end
```



### 1.Redisson 分布式锁

```java
Config config = new Config();
config.useClusterServers()
.addNodeAddress("redis://192.168.31.101:7001")
.addNodeAddress("redis://192.168.31.101:7002")
.addNodeAddress("redis://192.168.31.101:7003")
.addNodeAddress("redis://192.168.31.102:7001")
.addNodeAddress("redis://192.168.31.102:7002")
.addNodeAddress("redis://192.168.31.102:7003");

RedissonClient redisson = Redisson.create(config);


RLock lock = redisson.getLock("anyLock");
lock.lock();
lock.unlock();
```



### 2.Redis 缓存穿透

缓存查询一个没有的 key，同时数据库也没有，如果黑客大量的使用这种方式，那么就会导致 DB 宕机

解决方案：缓存空对象并设置过期时间，或者使用布隆过滤器



### 3.Redis 缓存击穿

大量请求查询一个刚刚失效的 key，导致 DB 压力倍增，可能导致宕机，但实际上，查询的都是相同的数据

解决方案：

1. 对于热点数据，可以不设置过期时间，或者在访问数据时对数据进行续期
2. 对于访问量较高的数据，可以设置多级缓存
3. 使用分布式锁，可以在这些请求代码加上双重检查锁，没有获取到锁的线程只需要等待重试



### 4.Redis  缓存雪崩

造成redis 缓存雪崩有两个原因：redis 宕机，大部分数据失效

解决方案：redis集群高可用，设置不同的过期时间，让缓存失效的时间点尽量均匀



### 5.Redis 缓存并发竞争

多个客户端写一个 key，如果顺序错了，数据就不对了

解决方案：使用分布式锁，例如 zk，同时加入数据的时间戳。同一时刻，只有抢到锁的客户端才能写入，同时，写入时，比较当前数据的时间戳和缓存中数据的时间戳



### 6.缓存和数据库双写不一致

连续写数据库和缓存，但是操作期间，出现并发导致数据不一致

更新缓存和数据库有以下几种顺序：

1. 先更新数据库，再更新缓存
2. 先删缓存，再更新数据库
3. 先更新数据库，再删除缓存



![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85ce00ef5ad54984a0bbe183bd00b75e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)





### 7.Redis的过期键删除策略

常见的删除策略有以下3种，其中定时删除和定期删除为主动删除策略，惰性删除为被动删除策略：

1. 定时删除，在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作
2. 惰性删除，放任过期键不管，每次从键空间中获取键时，检查该键是否过期，如果过期，就删除该键，如果没有过期，就返回该键
3. 定期删除，每隔一段时间，程序对数据库进行一次检查，删除里面的过期键，至于要删除哪些数据库的哪些过期键，则由算法决定



#### RDB对过期键的处理

1. 生成RDB文件：在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中
2. 载入RDB文件：在启动Redis服务器时，服务器将会载入RDB文件，对主机来说，未过期的键会被载入到数据库中，过期键会被忽略；从机不论是否过期，都会被载入到数据库中，因为主从服务器在进行数据同步的时候，从服务器的数据库会被清空，所以一般情况下，过期键对载入RDB文件的从服务器不会造成影响



#### AOF对过期键的处理

1. AOF文件写入：当过期键被惰性删除或者定期删除后，程序会向AOF文件追加一条DEL命令，显式记录该键已被删除
2. AOF文件重写：在执行AOF文件重写时，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中



#### 复制功能对过期键的处理

在主从复制模式下，从服务器的过期键删除动作由主服务器控制：

- 从服务器在执行客户端发送的读命令时，即使发现该键已过期也不会删除该键，照常返回该键的值
- 主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键，从服务器只有接收到主服务器发送的DEL命令后，才会删除过期键



### 8.Redis 过期策略算法

当内存达到maxmemory，会触发内存回收策略，具体策略依据maxmemory-policy来执行

|      策略       |                         描述                         |
| :-------------: | :--------------------------------------------------: |
|  volatile-lru   | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
|  volatile-ttl   |   从已设置过期时间的数据集中挑选将要过期的数据淘汰   |
| volatile-random |      从已设置过期时间的数据集中任意选择数据淘汰      |
|   allkeys-lru   |       从所有数据集中挑选最近最少使用的数据淘汰       |
| allkeys-random  |          从所有数据集中任意选择数据进行淘汰          |
|   noeviction    |                     禁止驱逐数据                     |



### 9.Redis占用内存大小

通过在Redis安装目录下面的redis.conf配置文件中添加以下配置设置内存大小：

```config
// 设置Redis最大占用内存大小为100M
maxmemory 100mb
```



或者通过命令修改：

```
//设置Redis最大占用内存大小为100M
127.0.0.1:6379> config set maxmemory 100mb

//获取设置的Redis能使用的最大内存大小
127.0.0.1:6379> config get maxmemory
```



获取当前内存淘汰策略：

```
127.0.0.1:6379> config get maxmemory-policy
```



通过配置文件设置淘汰策略（修改redis.conf文件）：

```
maxmemory-policy allkeys-lru
```



通过命令修改淘汰策略：

```
127.0.0.1:6379> config set maxmemory-policy allkeys-lru
```





### 10.Redis 持久化机制

单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放



RDB是Redis默认的持久化方式







### .Redis两种持久化方式的优缺点

1. RDB持久化可以在指定的时间间隔内生成数据集的时间点快照
2. AOF持久化记录服务器执行的所有写操作命令,并在服务器启动时,通过重新执行这些命令来还原数据集,AOF文件中全部以redis协议的格式来保存,新命令会被追加到文件的末尾,redis还可以在后台对AOF文件进行重写,文件的体积不会超出保存数据集状态所需要的实际大小,
3. redis还可以同时使用AOF持久化和RDB持久化,在这种情况下,当redis重启时,它会优先使用AOF文件来还原数据集,因为AOF文件保存的数据集通常比RDB文件所保存的数据集更加完





### RDB 优缺点

1. 优点：紧凑的文件，适合备份和灾难性恢复，主进程fork一个子进程保存工作，主进程不进行任何io操作
2. 缺点：rdb无法做到实时同步，频繁fork子进程内存中的数据被复制一份，替换新的rdb文件会影响性能，而且rdb是隔一段时间同步，如果这段时间发生异常那会导致这部分数据丢失



### AOF 优缺点

1. 优点：提供多种同步频率，持久化速度快，每次都是追加不想rdb全量同步，数据丢失少
2. 缺点：文件过大，恢复数据速度没有rdb快





### 单线程的redis为什么这么快

1. 纯内存操作
2. 单线程操作，避免了频繁的上下文切换
3. 采用了非阻塞I/O多路复用机制



### Redis 为什么是单线程的

Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽，既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了





### 对于大量的请求怎么样处理

redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求；

redis是通过IO多路复用（select，epoll, kqueue，依据不同的平台，采取不同的实现）来处理多个客户端请求的







### Redis 常见性能问题和解决方案

1. Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
2. 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
3. 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内
4. 尽量避免在压力很大的主库上增加从库
5. 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <-
   Slave3…



### Redis事务

Redis事务功能是通过`MULTI、EXEC、DISCARD和WATCH` 四个原语实现的

Redis会将一个事务中的所有命令序列化，然后按顺序执行：

1. redis 不支持回滚，Redis 在事务失败时不进行回滚，而是继续执行余下的命令， 所以 Redis 的内部可以保持简单且快速
2. 如果在一个事务中的命令出现错误，那么所有的命令都不会执行
3. 如果在一个事务中出现运行错误，那么正确的命令会被执行
4. redis的discard只是结束本次事务，正确命令造成的影响仍然存在





1. MULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行
2. EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 
3. 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出
4. WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令













### Redis和MongoDB的区别





### 主从复制

1. 全量复制，一般发生在Slave初始化阶段：

   - slave连接到master并发送psync命令
   - master收到命令后使用bgsave生成rdb快照，并使用缓冲区记录此后的写操作
   - master执行完bgsave命令后，将rdb发送给所有slave
   - slave接受rbd，并清空旧数据，使用新的rdb载入数据
   - master发送完rdb之后将缓冲区中的写命令也发送给slave
   - slave完成rdb数据载入之后，接收并执行来自master缓冲区的写命令
   - 若slave开启了aof，则写入/重写aof

2. 增量复制

   指在初始化的全量复制并开始正常工作之后，master每执行一个写命令就会向slave发送相同的写命令，slave接收并执行收到的写命令

3. 断点续传

   当master-slave网络连接断掉后，slave重新连接master时，会触发全量复制，但是从2.8版本开始，slave与master能够在网络连接断开重连后，只从中断处继续进行复制，而不必重新同步，这就是所谓的断点续传

   

4. 无盘复制

   在Redis2.8之后，可以通过无盘复制来达到目的，由master直接开启一个socket，在内存中创建RDB文件，再将rdb文件发送给slave服务器，不使用磁盘作为中间存储

   ```
   repl-diskless-sync ：是否开启无磁盘复制
   repl-diskless-sync-delay：等待一定时长再开始复制，因为要等更多slave重新连接过来
   ```



优点：读写分离，master和slave同步时都是以非阻塞的方式完成数据同步的

缺点：不具备自动容错和恢复功能，master/slave宕机都会导致部分数据读写失败而且需要手动操作恢复，master若有部分数据未能及时同步到slave，切换后可能会造成数据不一致





### 哨兵模式

哨兵的作用就是监控Redis系统的运行状况，主要监控master和slave是否正常运行，以及当master出现故障时自动将从slave转换为master

优点：与主从复制一样，但解决了结点故障需要人工手动操作的问题

缺点：较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂



### 集群

支持动态扩展结点





### 尽量减少主从复制丢失数据

在redis的配置文件中可以设置：

```
min-slaves-to-write 1
min-slaves-max-lag 10
```



这两个参数表示至少有1个salve的与master的同步复制延迟不能超过10s，一旦所有的slave复制和同步的延迟达到了10s，那么此时master就不会接受任何请求



可以减小min-slaves-max-lag参数的值，这样就可以避免在发生故障时大量的数据丢失，一旦发现延迟超过了该值就不会往master中写入数据



可以采取降级措施，将数据暂时写入本地缓存和磁盘中，在一段时间后重新写入master来保证数据不丢失；也可以将数据写入kafka消息队列，隔一段时间去消费kafka中的数据









### Redis性能问题及解决方案

1. 持久化性能问题：增量同步，master不要做持久化给slave做
2. aof同步，每秒同步一次
3. 主从复制，网络问题







https://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247486457&idx=1&sn=c73f7a423fc151db693b3e4db1c8bb61&chksm=e80dbd8fdf7a3499d4f004ce72f1d9581478bb29eb32fff99a3b3b6b799315b8ef166020fff3&scene=21#wechat_redirect

















































































### Redis字符串的实现

Redis虽然是用C语言写的，但却没有直接用C语言的字符串，而是自己实现了一套字符串。目的就是为了提升速度，提升性能，Redis构建了一个叫做简单动态字符串Simple Dynamic String：

```c
struct sdshdr{
    //  记录已使用长度
    int len;
    // 记录空闲未使用的长度
    int free;
    // 字符数组
    char[] buf;
};
```





### 项目中使用的 Redis 版本

### Redis 在项目中的使用场景

### Redis 怎么保证高可用

### Redis 的选举流程

### Redis 和 Memcache 的区别

### Redis 的集群模式

### Redis 集群要增加分片，槽的迁移怎么保证无损

### Redis 分布式锁的实现

### Redis 删除过期键的策略

### Redis 的内存淘汰策略

### Redis 的 Hash 对象底层结构

### Redis 中 Hash 对象的扩容流程

### Redis 的 Hash 对象的扩容流程在数据量大的时候会有什么问题吗

### Redis 的持久化机制有哪几种

### RDB 和 AOF 的实现原理、优缺点

### AOF 重写的过程

### 哨兵模式的原理

### 使用缓存时，先操作数据库还是先操作缓存

### 为什么是让缓存失效，而不是更新缓存

### 缓存穿透、缓存击穿、缓存雪崩

### 更新缓存的几种设计模式















































































































































































































































































































































































































































































































