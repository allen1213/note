### 1.Redis的好处

1. 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)

2. 支持丰富数据类型，支持string，list，set，sorted set，hash

3. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

4. 可用于缓存，消息，按key设置过期时间，过期后将会自动删除



### 1.redis相比memcached有哪些优势

1. memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型

2. redis的速度比memcached快很多

3. redis可以持久化其数据







### 1.Redis如何实现分布式锁

Redis要实现分布式锁，以下条件应该得到满足：

1. 互斥性：在任意时刻，只有一个客户端能持有锁
2. 不能死锁：客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁
3. 容错性：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁



使用Redis做分布式锁的思路大概是这样的：在redis中设置一个值表示加了锁，然后释放锁的时候就把这个key删除,具体代码是这样的：

```
// 获取锁
// NX是指如果key不存在就成功，key存在返回false，PX可以指定过期时间
SET anyLock unique_value NX PX 30000


// 释放锁：通过执行一段lua脚本
// 释放锁涉及到两条指令，这两条指令不是原子性的
// 需要用到redis的lua脚本支持特性，redis执行lua脚本是原子性的
if redis.call("get",KEYS[1]) == ARGV[1] then
return redis.call("del",KEYS[1])
else
return 0
end
```



### 1.Redisson 分布式锁

```java
Config config = new Config();
config.useClusterServers()
.addNodeAddress("redis://192.168.31.101:7001")
.addNodeAddress("redis://192.168.31.101:7002")
.addNodeAddress("redis://192.168.31.101:7003")
.addNodeAddress("redis://192.168.31.102:7001")
.addNodeAddress("redis://192.168.31.102:7002")
.addNodeAddress("redis://192.168.31.102:7003");

RedissonClient redisson = Redisson.create(config);


RLock lock = redisson.getLock("anyLock");
lock.lock();
lock.unlock();
```



### 2.Redis 缓存穿透

缓存查询一个没有的 key，同时数据库也没有，如果黑客大量的使用这种方式，那么就会导致 DB 宕机

解决方案：缓存空对象并设置过期时间，或者使用布隆过滤器



### 3.Redis 缓存击穿

大量请求查询一个刚刚失效的 key，导致 DB 压力倍增，可能导致宕机，但实际上，查询的都是相同的数据

解决方案：可以在这些请求代码加上双重检查锁。但是那个阶段的请求会变慢。不过总比 DB 宕机好



### 4.Redis  缓存雪崩

造成redis 缓存雪崩有两个原因：redis 宕机，大部分数据失效

解决方案：redis集群高可用，设置不同的过期时间，让缓存失效的时间点尽量均匀



### 5.Redis 缓存并发竞争

多个客户端写一个 key，如果顺序错了，数据就不对了

解决方案：使用分布式锁，例如 zk，同时加入数据的时间戳。同一时刻，只有抢到锁的客户端才能写入，同时，写入时，比较当前数据的时间戳和缓存中数据的时间戳



### 6.缓存和数据库双写不一致

连续写数据库和缓存，但是操作期间，出现并发导致数据不一致

更新缓存和数据库有以下几种顺序：

1. 先更新数据库，再更新缓存
2. 先删缓存，再更新数据库
3. 先更新数据库，再删除缓存





### 7.Redis的过期键删除策略

常见的删除策略有以下3种，其中定时删除和定期删除为主动删除策略，惰性删除为被动删除策略：

1. 定时删除，在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作
2. 惰性删除，放任过期键不管，每次从键空间中获取键时，检查该键是否过期，如果过期，就删除该键，如果没有过期，就返回该键
3. 定期删除，每隔一段时间，程序对数据库进行一次检查，删除里面的过期键，至于要删除哪些数据库的哪些过期键，则由算法决定



#### RDB对过期键的处理

1. 生成RDB文件：在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中
2. 载入RDB文件：在启动Redis服务器时，服务器将会载入RDB文件，对主机来说，未过期的键会被载入到数据库中，过期键会被忽略；从机不论是否过期，都会被载入到数据库中，因为主从服务器在进行数据同步的时候，从服务器的数据库会被清空，所以一般情况下，过期键对载入RDB文件的从服务器不会造成影响



#### AOF对过期键的处理

1. AOF文件写入：当过期键被惰性删除或者定期删除后，程序会向AOF文件追加一条DEL命令，显式记录该键已被删除
2. AOF文件重写：在执行AOF文件重写时，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中



#### 复制功能对过期键的处理

在主从复制模式下，从服务器的过期键删除动作由主服务器控制：

- 从服务器在执行客户端发送的读命令时，即使发现该键已过期也不会删除该键，照常返回该键的值
- 主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键，从服务器只有接收到主服务器发送的DEL命令后，才会删除过期键



### 8.Redis 过期策略算法

当内存达到maxmemory，会触发内存回收策略，具体策略依据maxmemory-policy来执行

|      策略       |                         描述                         |
| :-------------: | :--------------------------------------------------: |
|  volatile-lru   | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
|  volatile-ttl   |   从已设置过期时间的数据集中挑选将要过期的数据淘汰   |
| volatile-random |      从已设置过期时间的数据集中任意选择数据淘汰      |
|   allkeys-lru   |       从所有数据集中挑选最近最少使用的数据淘汰       |
| allkeys-random  |          从所有数据集中任意选择数据进行淘汰          |
|   noeviction    |                     禁止驱逐数据                     |



### 9.Redis占用内存大小

通过在Redis安装目录下面的redis.conf配置文件中添加以下配置设置内存大小：

```config
// 设置Redis最大占用内存大小为100M
maxmemory 100mb
```



或者通过命令修改：

```
//设置Redis最大占用内存大小为100M
127.0.0.1:6379> config set maxmemory 100mb

//获取设置的Redis能使用的最大内存大小
127.0.0.1:6379> config get maxmemory
```



获取当前内存淘汰策略：

```
127.0.0.1:6379> config get maxmemory-policy
```



通过配置文件设置淘汰策略（修改redis.conf文件）：

```
maxmemory-policy allkeys-lru
```



通过命令修改淘汰策略：

```
127.0.0.1:6379> config set maxmemory-policy allkeys-lru
```





### 10.Redis 持久化机制

单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放



RDB是Redis默认的持久化方式







### .Redis两种持久化方式的优缺点

1. RDB持久化可以在指定的时间间隔内生成数据集的时间点快照
2. AOF持久化记录服务器执行的所有写操作命令,并在服务器启动时,通过重新执行这些命令来还原数据集,AOF文件中全部以redis协议的格式来保存,新命令会被追加到文件的末尾,redis还可以在后台对AOF文件进行重写,文件的体积不会超出保存数据集状态所需要的实际大小,
3. redis还可以同时使用AOF持久化和RDB持久化,在这种情况下,当redis重启时,它会优先使用AOF文件来还原数据集,因为AOF文件保存的数据集通常比RDB文件所保存的数据集更加完





### 单线程的redis为什么这么快

1. 纯内存操作
2. 单线程操作，避免了频繁的上下文切换
3. 采用了非阻塞I/O多路复用机制



### Redis 为什么是单线程的

Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽，既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了





### 对于大量的请求怎么样处理

redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求；

redis是通过IO多路复用（select，epoll, kqueue，依据不同的平台，采取不同的实现）来处理多个客户端请求的







### Redis 常见性能问题和解决方案

1. Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
2. 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
3. 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内
4. 尽量避免在压力很大的主库上增加从库
5. 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <-
   Slave3…



### Redis事务

Redis事务功能是通过`MULTI、EXEC、DISCARD和WATCH` 四个原语实现的

Redis会将一个事务中的所有命令序列化，然后按顺序执行：

1. redis 不支持回滚，Redis 在事务失败时不进行回滚，而是继续执行余下的命令， 所以 Redis 的内部可以保持简单且快速
2. 如果在一个事务中的命令出现错误，那么所有的命令都不会执行
3. 如果在一个事务中出现运行错误，那么正确的命令会被执行
4. redis的discard只是结束本次事务，正确命令造成的影响仍然存在





1. MULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行
2. EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 
3. 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出
4. WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令







### Redis和MongoDB的区别





### 主从复制





### 哨兵模式





### 集群











https://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247486457&idx=1&sn=c73f7a423fc151db693b3e4db1c8bb61&chksm=e80dbd8fdf7a3499d4f004ce72f1d9581478bb29eb32fff99a3b3b6b799315b8ef166020fff3&scene=21#wechat_redirect

















































































### Redis字符串的实现

Redis虽然是用C语言写的，但却没有直接用C语言的字符串，而是自己实现了一套字符串。目的就是为了提升速度，提升性能，Redis构建了一个叫做简单动态字符串Simple Dynamic String：

```c
struct sdshdr{
    //  记录已使用长度
    int len;
    // 记录空闲未使用的长度
    int free;
    // 字符数组
    char[] buf;
};
```





















































































































































































































































































































































































































































































































