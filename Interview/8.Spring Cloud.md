### 什么是微服务

微服务就是一个独立的职责单一的服务应用程序，具体就是使用springboot 开发的一个小的模块，处理单一专业的业务逻辑，一个模块只做一个事情





### SpringCloud 组件

1. Eureka
2. Gateway
3. Feign，Ribbon / Hystrix
4. 



### 2.微服务之间如何独立通讯的

1. 同步通信：dobbo通过 RPC 远程过程调用、springcloud通过 REST  接口json调用 等
2. 异步：消息队列，如：RabbitMq、ActiveM、Kafka 等



### 3.SpringCloud 和 Dubbo 有哪些区别

1. 他们都是分布式管理框架，dubbo 是二进制传输，占用带宽会少一点，SpringCloud是http 传输，带宽会多一点，同时使用http协议一般会使用JSON报文，消耗会更大
2. dubbo 开发难度较大，所依赖的 jar 包有很多问题大型工程无法解决，SpringCloud 对第三方的继承可以一键式生成，天然集成
3. SpringCloud 接口协议约定比较松散，需要强有力的行政措施来限制接口无序升级
4. 最大的区别：Spring Cloud抛弃了Dubbo 的RPC通信，采用的是基于HTTP的REST方式



严格来说，这两种方式各有优劣。虽然在一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适





### 4.SpringBoot 和 SpringCloud 的关系

1. SpringBoot：专注于快速方便的开发单个个体微服务（关注微观）；SpringCloud：关注全局的微服务协调治理框架，将SpringBoot开发的一个个单体微服务组合并管理起来（关注宏观）
2. SpringBoot可以离开SpringCloud独立使用，但是SpringCloud不可以离开SpringBoot，属于依赖关系





### 5.熔断和服务降级

1. 服务熔断：当某服务出现不可用或响应超时时，为了防止整个系统出现雪崩，暂时停止对该服务的调用
2. 服务降级是从整个系统的负荷情况出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性



### 6.微服务的优缺点

1. 优点：松耦合，聚焦单一业务功能，无关开发语言，团队规模降低。在开发中，不需要了解多有业务，只专注于当前功能，便利集中，功能小而精。微服务一个功能受损，对其他功能影响并不是太大，可以快速定位问题。微服务只专注于当前业务逻辑代码，不会和 html、css 或其他界面进行混合。可以灵活搭配技术，独立性比较舒服
2. 缺点：随着服务数量增加，管理复杂，部署复杂，服务器需要增多，服务通信和调用压力增大，运维工程师压力增大，人力资源增多，系统依赖增强，数据一致性，性能监控



### 7.eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别

CAP：一致性，可用性，分区容错性

1. zookeeper 是CP原则，强一致性和分区容错性
2. eureka 是AP 原则 可用性和分区容错性
3. zookeeper当主节点故障时，zk会在剩余节点重新选择主节点，耗时过长，虽然最终能够恢复，但是选取主节点期间会导致服务不可用，这是不能容忍的
4. eureka各个节点是平等的，一个节点挂掉，其他节点仍会正常保证服务





### 8.微服务技术栈

| 微服务条目   | 落地技术                      |
| ------------ | ----------------------------- |
| 服务开发     | Spring、SpringMVC、SpringBoot |
| 服务注册管理 | Eueka、Zookeeper              |
| 服务调用     | REST、RPC                     |
| 服务熔断     | Hystrix                       |
| 负载均衡     | Nginx、Ribbon                 |
| 服务接口调用 | Fegin                         |
| 消息队列     | Kafka、RabbitMQ、RocketMQ     |
| 路由网关     | Gateway                       |
| 服务部署     | Docker、K8                    |







### 9.什么是微服务架构

微服务架构 就是 对微服务进行管理整合应用，微服务架构 依赖于 微服务，是在微服务基础之上的

例如：在医院里，每一个科室都是一个独立的微服务，那么 这个医院 就是 一个大型的`微服务架构`，院长 可以 对下面的 科室进行管理，微服务架构主要就是这种功能





### 10.分布式事务

分布式事务是指一个业务流程跨越多个分布式系统/服务的事物处理，需要确保在多个参与者之间数据的一致性及原子性

#### 2PC/两阶段提交

顾名思义，二阶段提交就是将事务的提交过程分成了两个阶段来进行处理：

1. 准备阶段：事务管理器给每个参与者发送Prepare消息，`每个数据库参与者在本地执行事务`，并写本地的Undo/Redo日志，`此时事务没有提交`，Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数 据文件
2. 提交阶段：如果事务管理器收到了参与者的执行失败或者`超时`消息时，直接给每个参与者发送回滚Rollback消息；否则，发送提交Commit消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源

![_Users_allen_Library_Application Support_typora-user-images_image-20230409151038228.png](https://s2.loli.net/2023/04/09/ICMfOtuXoiycDap.png)

优点：能利用数据库自身的事务提交/回滚，提交/回滚操作并不需要自己去实现，所以不会侵入业务逻辑

缺点：

1. 同步阻塞：`2PC`中的所有的参与者节点都为`事务阻塞型`，当某一个`参与者`节点出现通信超时，其余`参与者`都会被动阻塞占用资源不能释放
2. 单点故障：2PC中事务管理器是关键组件，若发生了故障很有可能导致整个分布式事务不可用，尽管可以通过备份管理器和日志去实现一定程度上的容错，但仍然存在单点故障的风险
3. 数据不一致：当管理器发出提交/回滚通知时，有部分参与者没有收到，导致数据不一致
4. 资源占用率高：参与者在提交事务之前可能会锁定部分资源，若事务执行比较慢，资源被长时间占用，可能会降低系统的吞吐量



##### 如何处理参与者和事务管理器之间的通信故障

1. 设置超时时间：若事务管理器在一定时间内没有收到参与者的回复则认定事务失败，发送回滚请求
2. 心跳机制：事务管理器每隔一段时间发送一个心跳，确保参与者存活
3. 预备性提交：
4. 事务管理器高可用
5. MQ



由于 2PC 的简单方便，所以会产生上述的同步阻塞、单点故障、数据不一致等情况，所以在 2PC 的基础上做了改进，推行出了3PC/三阶段提交



#### 3PC/三阶段提交

1. `3PC`在`2PC`的第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前，各参与者节点的状态都一致
2. 同时在协调者和参与者中都引入超时机制，当`参与者`各种原因未收到`协调者`的commit请求后，会对本地事务进行commit，不会一直阻塞等待，解决了`2PC`的单点故障问题，但`3PC` 还是没能从根本上解决数据一致性的问题

![_Users_allen_Library_Application Support_typora-user-images_image-20230409160109737.png](https://s2.loli.net/2023/04/09/tOb2Ia96WpC4XNc.png)





### TCC

TCC 是 Try、Conﬁrm、Cancel 三个词语的缩写：

TM 首先发起所有的分支事务的 Try 操作，任何一个分支事务的Try操作执行失败，TM 将会发起所有分支事务的 Cancel 操作，若 Try 操作全部成功，TM 将会发起所有分支事务的 Conﬁrm 操作，其中 Conﬁrm/Cancel 操作若执行失败，TM 会进行重试



1. 应用侵入性强：TCC由于基于在业务层面，至使每个操作都需要有 `try`、`confirm`、`cancel`三个接口
2. 开发难度大：代码开发量很大，要保证数据一致性 `confirm` 和 `cancel` 接口还必须实现幂等性





### 12.分布式系统接口，如何避免表单的重复提交

幂等性：系统对某接口的多次请求，都应该返回同样的结果，网络访问失败的场景除外，目的是避免因为各种原因，重复请求导致的业务重复处理



重复请求场景案例：

1. 客户端第一次请求后，网络异常导致收到请求执行逻辑但是没有返回给客户端，客户端的重新发起请求
2. 客户端迅速点击按钮提交，导致同一逻辑被多次发送到服务器



简单来划分，业务逻辑无非都可以归纳为增删改查：

1. 对于查询，内部不包含其他操作，属于只读性质的那种业务必然符合幂等性要求的
2. 对于删除，重复做删除请求至少不会造成数据杂乱
3. 对于新增和修改，新增需要避免重复插入，修改避免进行无效的重复修改



幂等性实现方法：客户端做某一请求的时候带上识别参数标识，服务端对此标识进行识别，重复请求则重复返回第一次的结果即可，举个栗子：

1. 比如添加请求的表单里，在打开添加表单页面的时候，就生成一个AddId标识，这个AddId跟着表单一起提交到后台接口
2. 后台接口根据这个AddId，服务端就可以进行缓存标记并进行过滤，缓存值可以是AddId作为缓存key，返回内容作为缓存Value，这样即使添加按钮被多次点下也可以识别出来
3. 只有在保存成功并且清空表单之后，才变更这个AddId标识，从而实现新数据的表单提交





### 幂等的实现方案

1. 使用分布式ID，数据库唯一主键
2. UUID，Redis+Lua







### SpringCloud如何实现服务的注册和发现

spring cloud 提供了一套完整的服务注册和发现解决方案，主要包括两个核心组件：eureka 服务器和 eureka 客户端

1. eureka 服务器：

   管理各个微服务实例的注册和发现，服务提供者可以将自己注册到eureka服务器，也可以通过eureka服务器查询需要调用的服务

   eureka 服务器根据心跳机制来维护服务实例的注册情况，并将最新的服务信息广播给其它服务实例

   

2. eureka 客户端：

   用来与 eureka 服务器进行交互，作为服务提供者，当服务启动时，eureka 客户端就会向 eureka 服务器发送注册请求，并启动一个定时任务发送心跳消息告知 eureka 服务器自己的状态





### Eureka心跳和服务剔除机制

心跳机制：客户端启动后，就会启动一个定时任务，定时向服务端发送心跳数据，告知服务端自己还活着，默认的心跳时间间隔是`30秒`

服务剔除机制：

1. 如果开启了自我保护机制，那么所有的服务，包括长时间没有收到心跳的服务，即已过期的服务，都不会被剔除
2. 如果未开启自我保护机制，那么将判断最后一分钟收到的心跳数与一分钟收到心跳数临界值比较，如果前者大于后者，且后者大于0的话，则启用服务剔除机制
3. 一旦服务剔除机制开启，Eureka服务端并不会直接剔除所有已过期的服务，而是通过随机数的方式进行剔除，避免自我保护开启之前将所有的服务，包括正常的服务，给剔除





### Eureka自我保护机制

Eureka Server在一定时间内，默认90秒，没有接收到某个微服务实例的心跳，Eureka Server将会移除该实例

但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制

自我保护机制的工作机制是：**如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制**，此时会出现以下几种情况：

1. Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务
2. Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用
3. 当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中



Eureka自我保护机制，通过配置 `eureka.server.enable-self-preservation` 为  `true`打开，`false`禁用自我保护机制，默认打开状态：

```yml
# 注册中心关闭自我保护机制，修改检查失效服务的时间
eureka:
  server:
     enable-self-preservation: false
     eviction-interval-timer-in-ms: 3000


# 微服务修改减短服务心跳的时间     
# 默认90秒
lease-expiration-duration-in-seconds:  10

# 默认30秒
lease-renewal-interval-in-seconds:  3
```





### Eureka客户端启动时如何注册到服务端

Eureka客户端在启动时，首先会创建一个心跳的定时任务，定时向服务端发送心跳信息，服务端会对客户端心跳做出响应，如果响应状态码为404时，表示服务端没有该客户端的服务信息，那么客户端则会向服务端发送注册请求，注册信息包括服务名、ip、端口、唯一实例ID等信息



### Eureka服务端如何保存客户端服务信息

客户端通过Jersey框架，亚马逊的一个http框架，将服务实例信息发送到服务端，服务端将客户端信息放在一个ConcurrentHashMap对象中



### Eureka客户端如何拉取服务端已保存的服务信息

客户端拉取服务端服务信息是通过一个定时任务定时拉取的，每次拉取后刷新本地已保存的信息，需要使用时直接从本地直接获取



### 如何构建高可用的Eureka集群

```java
eureka.client.service-url.defaultZone
```





### Spring Cloud Gateway

网关是整个微服务API请求的入口，负责拦截所有请求，并分发到各个服务，可以实现日志拦截、权限控制、解决跨域问题、限流、熔断、负载均衡，其中的几个重要概念：

1. Route（路由）：它是网关的基本组件，由ID、目标URL、Predicate 集合、Filter 集合组成。
2. Predicate（断言）：它是 Java 8 中引入的函数式接口，提供了断言的功能。它可以匹配 HTTP 请求中的任何内容。如果 Predicate 的聚合判断结果为 true，则意味着该请求会被当前 Router 进行转发。
3. Filter（过滤器）：为请求提供前置和后置的过滤





### 过滤器/网关

- 过滤器：对单个服务器的请求进行拦截控制

- 网关：对所有的服务器的请求进行拦截控制

  

### Gateway/Zuul

1. zuul：是Netflix的，是基于servlet实现的，阻塞式的api，不支持长连接。
2. gateway：是springcloud自己研制的微服务网关，是基于Spring5构建，能够实现响应式非阻塞式的Api，支持长连接



### Gateway/Nginx

都可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等，不同点：

1. Nginx采用C语言编写，Gateway属于Java语言编写的
2. Nginx 属于服务器端负载均衡器
3. Gateway 属于本地负载均衡器







### 19.CAP

Consistency  一致性：all nodes see the same data at the same time，更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题，从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致

Availability  可用性：Reads and writes always succeed，即服务一直可用，而且是正常响应时间，好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况

Partition Tolerance  分区容错性：即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务



分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体，比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响



比如说有3台机器ABC，正常情况下3台机器互相数据同步，对外提供服务，如果某一时刻，A机器和BC机器断开：

1. 要么就是继续都对外提供服务，那么此时就会出现ABC三台机器对外数据不一致的情况，这就是满足了可用性，但不满足一致性
2. 另一种情况就是一旦发现机器不可用了，就暂停对外服务，直到ABC互相连通，再对外提供服务，这就是满足了一致性，但不满足可用性了，因为暂定服务这段时间服务就不可用了
3. 银行业务首要的是数据一致性，只要数据不一致，哪怕对外停止服务，也要数据一致，所以会考虑CP，而秒杀业务，首要的更多是可用性，所以会适当放弃数据一致性，大不了用户看到有货，但下订单付款的时候失败了，这种事也算勉强正常吧，所以这种业务会考虑AP





### BASE 理论

BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent （最终一致性）三个短语的缩写

BASE 理论是对 CAP 中 AP 的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态：

1. **基本可用**：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如电商网站交易付款出现问题了，商品依然可以正常浏览。
2. **软状态**：由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫**软状态**），这个状态不影响系统可用性，如订单的"支付中"、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。
3. **最终一致**：最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的"支付中"状态，最终会变 为“支付成功”或者"支付失败"，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待



### Open Feigin

feign采用的是基于接口的注解，整合了ribbon 和 Hystrix，具有负载均衡和熔断的能力，使用：

1. 添加pom依赖
2. 启动类添加@EnableFeignClients
3. 定义一个接口@FeignClient(name=“xxx”)指定调用哪个服务



原理：

1. 通过 @EnableFeignCleints 注解启动 Feign Starter 组件
2. Feign Starter 在项目启动过程中注册全局配置，扫描包下所有的 @FeignClient 接口类，并进行注册 IOC 容器
3. @FeignClient 接口类被注入时，通过 `FactoryBean#getObject` 返回动态代理类
4. 接口被调用时被动态代理类逻辑拦截，将 @FeignClient 请求信息通过编码器生成 Request
5. 交由 Ribbon 进行负载均衡，挑选出一个健康的 Server 实例
6. 继而通过 Client 携带 Request 调用远端服务返回请求响应
7. 通过解码器生成 Response 返回客户端，将信息流解析成为接口返回数据





### Ribbon和Feign的区别

SpringCloud的Netflix中提供了两个组件实现软负载均衡调用：ribbon 和 feign，Ribbon和Feign都是用于调用其他服务的，不过方式不同，Ribbon使用`@RibbonClient(value="服务名称")` 使用`RestTemplate`调用远程服务对应的方法，Feign使用@FeignClient("指定服务名")调用提供方提供对外接口，Ribbon和Feign的区别：

1. 启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的是@EnableFeignClients

2. 服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明

3. 调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐

   

Feign则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可





### @FeignClient 如何根据接口生成实现类

JDK动态代理









### ZooKeeper

ZooKeeper是一个开源分布式协同服务系统，主要用来解决分布式集群中应用系统的一致性问题



### Zookeeper 的使用场景

1. 数据发布订阅
2. 负载均衡
3. 集群管理/服务注册
4. master选举
5. 分布式锁
6. 分布式队列



### Zookeeper集群角色

1. Leader：处理写请求，管理调度集群中的其他结点
2. Follower：处理查询请求，选举leader
3. Observer：分担follower的压力，不参与leader选举，也不会被选举为leader





### ZNode的类型

1. 持久节点：一旦创建，除非主动移除，否则会一直保存在ZooKeeper
2. 临时节点：生命周期和客户端会话绑定，会话失效，相关的临时节点被移除
3. 持久顺序性：同时具备顺序性
4. 临时顺序性：同时具备顺序性





### Zookeeper 怎么实现分布式锁

创建临时有序结点：

1. 当多个客户端要获取锁时，则发送写请求
2. 新增的结点类型为临时有序结点
3. 若当前客户端结点序号最小，则获取锁，否则查找比该结点序号小的一个结点并监听

创建临时结点是防止zk宕机时无法释放锁，有序则保证一个结点只监听前一个序号的结点避免释放锁之后发生惊群效应

以般使用curator实现zk分布式锁





### Zookeeper 怎么保证数据的一致性

### ZAB 协议的原理

### Zookeeper 遵循 CAP 中的哪些

### Zookeeper 和 Eureka 的区别

### Zookeeper 的 Leader 选举

过半选举，当集群中有超过一半的结点都投票给一个结点时，该结点则成为leader：

1. 若在启动集群阶段，启动到一半时，服务器id最大的为leader
2. 若已经存在leader，并且leader宕机重新选择结点时，则：
   - leader任期id（epoch）大的为leader
   - 若任期id相同，则结点处理的事务id大的为leader
   - 若事务id仙童，则服务器id大的胜出





### Leader 发送了 commit 消息，但是所有的 follower 都没有收到这条消息，Leader 就挂了，后续会怎么处理





### Paxos 算法、Raft 算法





## 分布式锁

### 分布式锁实现有哪些方式





### redis怎么实现分布式锁的，实现的原理







## 分布式事务





## 消息队列

### 用过什么消息中间件



### 什么是消息队列

一个用来通信的队列，本质就是一个转发器，包含发消息，存消息，消费消息



### 消息队列使用场景

1. 异步，用户注册成功后，发送短信/邮件，由短信/邮件服务读取并消费消息
2. 解耦，下单成功后，发送消息到MQ，在由库存服务消费消息
3. 削峰，常用于秒杀系统，通常只有一段时间请求量很大，积压的消息可以慢慢处理，若队列中消息太多则可以抛弃用户请求返回错误



### 消息队列如何保证消息不丢失

1. 生产者：同步等待MQ返回ack，异常则重新发送，或者使用事务消息实现零丢失
2. MQ：持久化数据到磁盘，同步刷盘/异步刷盘，异步刷盘则是写到缓存中，若断电则数据丢失
3. 消费者：消费成功后，返回ack给MQ



### 消息队列如何保证消息的消费顺序

单线程下，先发送M1并且同步等待M1消费成功之后，在发送M2





### 哪些情况会导致重复消费消息

1. 生产者没有收到MQ的ack，重复发送消息
2. 消费者处理完业务，需要更新消费位移时突然宕机，重新/另起服务时导致重复消费



### 如何避免消费者重复消费消息

1. 生产者发送消息时，携带唯一id，可放入redis中
2. 消费者使用redis+lua提供幂等接口



### 消息积压如何处理

消息积压是指生产速度大于消费速度，处理方法：

1. 查看消费逻辑，是否可以使用批量消费
2. 若使用批量处理消息还是很慢，则可以考虑水平扩容，添加topic的队列数和消费者数量，以提升消费速度





### 消息队列技术选型

1. kafka是基于pull模式来处理消费消息的，追求高吞吐量，一开始是用来做日志收集的，后也常用于大数据的数据收集业务
2. rocketmq：适合用于对可靠性要求高的系统，用于业务削峰
3. rabbitmq：使用erlang开发，性能较好，但不利于二次开发维护





### 消息中间件如何做到高可用

集群，kafka与es类似，将数据保存在不同的分片中，并可以设置分片的副本，使得副本数量均有的保存在其他结点中，就算挂掉了一个结点，其他结点也有该结点的数据信息





### 如何保证数据一致性，事务消息如何实现

事务消息的实现方式：

1. 生产者产生消息，发送一条半事务消息到MQ服务器
2. MQ收到消息后，将消息持久化到存储系统，这条消息的状态是待发送状态。
3. MQ服务器返回ACK确认到生产者，此时MQ不会触发消息推送事件
4. 生产者执行本地事务
5. 如果本地事务执行成功，即commit执行结果到MQ服务器；如果执行失败，发送rollback。
6. 如果是正常的commit，MQ服务器更新消息状态为可发送；如果是rollback，即删除消息。
7. 如果消息状态更新为可发送，则MQ服务器会push消息给消费者。消费者消费完就回ACK。
8. 如果MQ服务器长时间没有收到生产者的commit或者rollback，它会反查生产者，然后根据查询到的结果执行最终状态





### 写一个消息队列，该如何进行架构设计

1. 确认好流程，生产者发布消息后获取ack，MQ存储消息，消费者消费回复确认
2. 各个角色之间的通信
3. MQ持久化
4. 保证消息可靠性
5. 集群及机器的扩展性，如消息积压时如何













































































































































































































































