### 1.什么是微服务

微服务就是一个独立的职责单一的服务应用程序，具体就是使用springboot 开发的一个小的模块，处理单一专业的业务逻辑，一个模块只做一个事情





### SpringCloud 组件

1. Eureka
2. Gateway
3. Feign，Ribbon / Hystrix
4. 



### 2.微服务之间如何独立通讯的

1. 同步通信：dobbo通过 RPC 远程过程调用、springcloud通过 REST  接口json调用 等
2. 异步：消息队列，如：RabbitMq、ActiveM、Kafka 等



### 3.SpringCloud 和 Dubbo 有哪些区别

1. 他们都是分布式管理框架，dubbo 是二进制传输，占用带宽会少一点，SpringCloud是http 传输，带宽会多一点，同时使用http协议一般会使用JSON报文，消耗会更大
2. dubbo 开发难度较大，所依赖的 jar 包有很多问题大型工程无法解决，SpringCloud 对第三方的继承可以一键式生成，天然集成
3. SpringCloud 接口协议约定比较松散，需要强有力的行政措施来限制接口无序升级
4. 最大的区别：Spring Cloud抛弃了Dubbo 的RPC通信，采用的是基于HTTP的REST方式



严格来说，这两种方式各有优劣。虽然在一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适





### 4.SpringBoot 和 SpringCloud 的关系

1. SpringBoot：专注于快速方便的开发单个个体微服务（关注微观）；SpringCloud：关注全局的微服务协调治理框架，将SpringBoot开发的一个个单体微服务组合并管理起来（关注宏观）
2. SpringBoot可以离开SpringCloud独立使用，但是SpringCloud不可以离开SpringBoot，属于依赖关系





### 5.熔断和服务降级

1. 服务熔断：当某服务出现不可用或响应超时时，为了防止整个系统出现雪崩，暂时停止对该服务的调用
2. 服务降级是从整个系统的负荷情况出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性



### 6.微服务的优缺点

1. 优点：松耦合，聚焦单一业务功能，无关开发语言，团队规模降低。在开发中，不需要了解多有业务，只专注于当前功能，便利集中，功能小而精。微服务一个功能受损，对其他功能影响并不是太大，可以快速定位问题。微服务只专注于当前业务逻辑代码，不会和 html、css 或其他界面进行混合。可以灵活搭配技术，独立性比较舒服
2. 缺点：随着服务数量增加，管理复杂，部署复杂，服务器需要增多，服务通信和调用压力增大，运维工程师压力增大，人力资源增多，系统依赖增强，数据一致性，性能监控



### 7.eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别

CAP：一致性，可用性，分区容错性

1. zookeeper 是CP原则，强一致性和分区容错性
2. eureka 是AP 原则 可用性和分区容错性
3. zookeeper当主节点故障时，zk会在剩余节点重新选择主节点，耗时过长，虽然最终能够恢复，但是选取主节点期间会导致服务不可用，这是不能容忍的
4. eureka各个节点是平等的，一个节点挂掉，其他节点仍会正常保证服务





### 8.微服务技术栈

| 微服务条目   | 落地技术                      |
| ------------ | ----------------------------- |
| 服务开发     | Spring、SpringMVC、SpringBoot |
| 服务注册管理 | Eueka、Zookeeper              |
| 服务调用     | REST、RPC                     |
| 服务熔断     | Hystrix                       |
| 负载均衡     | Nginx、Ribbon                 |
| 服务接口调用 | Fegin                         |
| 消息队列     | Kafka、RabbitMQ、RocketMQ     |
| 路由网关     | Gateway                       |
| 服务部署     | Docker、K8                    |







### 9.什么是微服务架构

微服务架构 就是 对微服务进行管理整合应用，微服务架构 依赖于 微服务，是在微服务基础之上的

例如：在医院里，每一个科室都是一个独立的微服务，那么 这个医院 就是 一个大型的`微服务架构`，院长 可以 对下面的 科室进行管理，微服务架构主要就是这种功能





### 10.分布式事务





### 11.SOA架构和微服务架构的区别













### 12.分布式系统接口，如何避免表单的重复提交

幂等性：系统对某接口的多次请求，都应该返回同样的结果，网络访问失败的场景除外，目的是避免因为各种原因，重复请求导致的业务重复处理



重复请求场景案例：

1. 客户端第一次请求后，网络异常导致收到请求执行逻辑但是没有返回给客户端，客户端的重新发起请求
2. 客户端迅速点击按钮提交，导致同一逻辑被多次发送到服务器



简单来划分，业务逻辑无非都可以归纳为增删改查：

1. 对于查询，内部不包含其他操作，属于只读性质的那种业务必然符合幂等性要求的
2. 对于删除，重复做删除请求至少不会造成数据杂乱
3. 对于新增和修改，新增需要避免重复插入，修改避免进行无效的重复修改



幂等性实现方法：客户端做某一请求的时候带上识别参数标识，服务端对此标识进行识别，重复请求则重复返回第一次的结果即可，举个栗子：

1. 比如添加请求的表单里，在打开添加表单页面的时候，就生成一个AddId标识，这个AddId跟着表单一起提交到后台接口
2. 后台接口根据这个AddId，服务端就可以进行缓存标记并进行过滤，缓存值可以是AddId作为缓存key，返回内容作为缓存Value，这样即使添加按钮被多次点下也可以识别出来
3. 只有在保存成功并且清空表单之后，才变更这个AddId标识，从而实现新数据的表单提交







### 13.SpringCloud如何实现服务的注册和发现





### 14.feigin

feign采用的是基于接口的注解，整合了ribbon 和 Hystrix，具有负载均衡和熔断的能力，使用：

1. 添加pom依赖
2. 启动类添加@EnableFeignClients
3. 定义一个接口@FeignClient(name=“xxx”)指定调用哪个服务



### 14.ribbon和feign的区别

SpringCloud的Netflix中提供了两个组件实现软负载均衡调用：ribbon 和 feign，Ribbon和Feign都是用于调用其他服务的，不过方式不同，Ribbon使用`@RibbonClient(value="服务名称")` 使用`RestTemplate`调用远程服务对应的方法，Feign使用@FeignClient("指定服务名")调用提供方提供对外接口，Ribbon和Feign的区别：

1. 启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的是@EnableFeignClients

2. 服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明

3. 调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐

   

Feign则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可



### 15.zuul路由网关



### 16.SpringCloud Config分布式配置中心





### 17.eureka自我保护机制

当Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，保护注册信息，不再删除注册数据，故障恢复时，自动退出自我保护模式





### 18.Spring Cloud Gateway







### 19.CAP

Consistency  一致性：all nodes see the same data at the same time，更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题，从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致

Availability  可用性：Reads and writes always succeed，即服务一直可用，而且是正常响应时间，好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况

Partition Tolerance  分区容错性：即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务



分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体，比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响



比如说有3台机器ABC，正常情况下3台机器互相数据同步，对外提供服务，如果某一时刻，A机器和BC机器断开：

1. 要么就是继续都对外提供服务，那么此时就会出现ABC三台机器对外数据不一致的情况，这就是满足了可用性，但不满足一致性
2. 另一种情况就是一旦发现机器不可用了，就暂停对外服务，直到ABC互相连通，再对外提供服务，这就是满足了一致性，但不满足可用性了，因为暂定服务这段时间服务就不可用了
3. 银行业务首要的是数据一致性，只要数据不一致，哪怕对外停止服务，也要数据一致，所以会考虑CP，而秒杀业务，首要的更多是可用性，所以会适当放弃数据一致性，大不了用户看到有货，但下订单付款的时候失败了，这种事也算勉强正常吧，所以这种业务会考虑AP







### 客户端启动时如何注册到服务端

Eureka客户端在启动时，首先会创建一个心跳的定时任务，定时向服务端发送心跳信息，服务端会对客户端心跳做出响应，如果响应状态码为404时，表示服务端没有该客户端的服务信息，那么客户端则会向服务端发送注册请求，注册信息包括服务名、ip、端口、唯一实例ID等信息



### 服务端如何保存客户端服务信息

客户端通过Jersey框架，亚马逊的一个http框架，将服务实例信息发送到服务端，服务端将客户端信息放在一个ConcurrentHashMap对象中



### 客户端如何拉取服务端已保存的服务信息

客户端拉取服务端服务信息是通过一个定时任务定时拉取的，每次拉取后刷新本地已保存的信息，需要使用时直接从本地直接获取





### 如何构建高可用的Eureka集群

```java
eureka.client.service-url.defaultZone
```





### 心跳和服务剔除机制

心跳机制：客户端启动后，就会启动一个定时任务，定时向服务端发送心跳数据，告知服务端自己还活着，默认的心跳时间间隔是30秒

服务剔除机制：

1. 如果开启了自我保护机制，那么所有的服务，包括长时间没有收到心跳的服务，即已过期的服务，都不会被剔除
2. 如果未开启自我保护机制，那么将判断最后一分钟收到的心跳数与一分钟收到心跳数临界值比较，如果前者大于后者，且后者大于0的话，则启用服务剔除机制
3. 一旦服务剔除机制开启，Eureka服务端并不会直接剔除所有已过期的服务，而是通过随机数的方式进行剔除，避免自我保护开启之前将所有的服务，包括正常的服务，给剔除





### Eureka自我保护机制

Eureka Server在一定时间内，默认90秒，没有接收到某个微服务实例的心跳，Eureka Server将会移除该实例

但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制

自我保护机制的工作机制是：**如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制**，此时会出现以下几种情况：

1. Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务
2. Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用
3. 当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中



Eureka自我保护机制，通过配置 `eureka.server.enable-self-preservation` 为  `true`打开，`false`禁用自我保护机制，默认打开状态



```yml
# 注册中心关闭自我保护机制，修改检查失效服务的时间
eureka:
  server:
     enable-self-preservation: false
     eviction-interval-timer-in-ms: 3000


# 微服务修改减短服务心跳的时间     
# 默认90秒
lease-expiration-duration-in-seconds:  10

# 默认30秒
lease-renewal-interval-in-seconds:  3
```









### Zookeeper 的使用场景

### Zookeeper 怎么实现分布式锁

### Zookeeper 怎么保证数据的一致性

### ZAB 协议的原理

### Zookeeper 遵循 CAP 中的哪些

### Zookeeper 和 Eureka 的区别

### Zookeeper 的 Leader 选举

### Observer 的作用

### Leader 发送了 commit 消息，但是所有的 follower 都没有收到这条消息，Leader 就挂了，后续会怎么处理





### CAP 理论

### BASE 理论

### 分布式事务 2PC 和 TCC 的原理

### TCC 在 cancel 阶段如果出现失败怎么处理

### Paxos 算法、Raft 算法





## 分布式锁

### 分布式锁实现有哪些方式





### redis怎么实现分布式锁的，实现的原理







## 分布式事务





## 消息队列

### 用过什么消息中间件

















































































































































































































































