## Java基础

### 1.内部类

1. 静态内部类：可以访问外部的静态资源，包括静态私有资源。但不能访问非静态资源，可以不依赖外部类实例而实例化

2. 成员内部类：可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类

3. 局部内部类： 局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰，局部内部类只能访问所在代码块或者方法中被定义为final的局部变量

4. 匿名内部类：没有类名的内部类，不能使用class，extends和implements，没有构造方法，不能定义静态资源，只能创建一个匿名内部类实例，一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口，匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效



### 2.Object类中的13个方法

| 方法                            | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| Object()                        | 构造方法                                                     |
| registerNatives()               |                                                              |
| `clone()`                       | 对象拷贝，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常 |
| `getClass()`                    | final方法，用于获得运行时的类型，方法返回的是此Object对象的类对象/运行时类对象Class，效果与`Object.class`相同 |
| `equals()`                      | 用来比较两个对象的内容是否相等                               |
| `hashCode()`                    | 返回其所在对象的物理地址（哈希码值），常会和`equals`方法同时重写，确保相等的两个对象拥有相等的hashCode |
| toString()                      |                                                              |
| `wait()`                        | 导致当前的线程等待，直到其他线程调用此对象的 `notify()` 方法或 `notifyAll()` 方法 |
| `wait(long timeout)`            | 导致当前的线程等待，直到其他线程调用此对象的 `notify()` 方法或 `notifyAll()` 方法，或者超过指定的时间量 |
| `wait(long timeout, int nanos)` |                                                              |
| `notify()`                      | 随机唤醒在此对象监视器上等待的某个线程                       |
| `notifyAll()`                   | 唤醒在此对象监视器上等待的所有线程                           |
| finalize()                      | 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法 |



### Object类的equal和hashCode方法重写



### hashCode() 和 equals() 之间的关系

关于这两个方法，必须遵循的规则：

1. 只要重写equals()，就必须重写hashCode()
   - 首先有两个对象相等，即equals返回true，则hashcode一定相同的结论
   - 如果只重写equals没有冲洗hashcode，那equals返回true，hashcode比较的还是两个对象的地址，显然和上面的结论相悖
   - 所以重写equals时就必须重写hashcode
   - 重写hashcode也是为了提高程序的效率，hashcode不同则没必要用equals比较

`hashCode()` 的作用是获取哈希码，也称为散列码，返回一个int整数，这个哈希码的作用是确定该对象在哈希表中的索引位置

重写equals的时候还要注意要满足自反性、对称性、传递性、一致性





### Java中==和equals/hashCode的区别





### 自动装箱/拆箱

```java
//自动装箱
Integer total = 99;

//自动拆箱
int totalprim = total;


// 反编译得到的代码 javap -c StringTest 
Integer total = Integer.valueOf(99);

int totalprim = total.intValue();
```



### Java中String的了解

Java中String是一种不可变对象，即一旦创建就不可以更改其内容。它是一个常用的数据类型，可以储存任何字符串值



### String为什么要设计成不可变的

- ###### 字符串常量池需要String不可变：因为String设计成不可变，当创建一个String对象时，若此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象。如果字符串变量允许必变，会导致各种逻辑错误，如改变一个对象会影响到另一个独立对象

- ###### String对象可以缓存hashCode：字符串的不可变性保证了hash码的唯一性，因此可以缓存String的hashCode，这样不用每次去重新计算哈希码。在进行字符串比较时，可以直接比较hashCode，提高了比较性能



### String、StringBuffer、StringBuilder区别

- 可变与不可变：String为不可变，`private final char value[]` 
- 线程安全：StringBuilder并没有对方法进行加同步锁，所以是线程不安全的



### String 转换成 Integer的方式及原理

- parseInt(String s)--内部调用parseInt(s,10)（默认为10进制）
- 正常判断null，进制范围，length等
- 判断第一个字符是否是符号位
- 循环遍历确定每个字符的十进制值
- 通过*= 和-= 进行计算拼接
- 判断是否为负值 返回结果



### Java的8种基本类型及其所占字节

```java
整型：byte、short、int、long

byte: 1字节（8位），取值范围是 -128 ~ 127。

short: 2字节（16位），取值范围是 -32768 ~ 32767。

int: 4字节（32位），取值范围是 -2147483648 ~ 2147483647。

long: 8字节（64位），取值范围是 -9223372036854775808 ~ 9223372036854775807。

浮点型：float、double

float: 4字节（32位），单精度浮点数，取值范围是 -3.40282347E+38 ~ 3.40282347E+38。

double: 8字节（64位），双精度浮点数，取值范围是 -1.79769313486231570E+308 ~ 1.79769313486231570E+308。

字符型：char

char: 2字节（16位），用于表示单个字符，取值范围是 0 ~ 65535。

布尔型：boolean

boolean: 1字节（8位），表示 true 或 false。

这些基本类型都有固定的字节长度和取值范围。在Java中，基本数据类型的变量的值是直接存储在内存中的，因此它们的操作效率较高
```



### int与Integer的区别

```java
基本类型和引用类型：int是Java的基本数据类型，而Integer是一个封装类，是Java中的引用类型。

可以为空：int是一个原始数据类型，它不能为null。而Integer是一个对象类型，可以赋值为null。

自动装箱和拆箱：Java5之后，Java增加了自动装箱和拆箱机制，可以在int和Integer之间进行自动转换。自动装箱是指将基本类型转换为对应的包装类型，例如int转换为Integer。而自动拆箱则是指将包装类型转换为对应的基本类型，例如Integer转换为int。

效率：int比Integer更高效，因为int是一个原始数据类型，存储在栈中，它的读取和操作速度比Integer快。而Integer是一个对象类型，存储在堆中，它的读取和操作速度比int慢。因此，在大量计算和需要高效性能的场景下，建议使用int。

总的来说，int和Integer都是表示整数的数据类型，但是它们的使用场景和特性略有不同，需要根据具体情况来选择使用哪种类型。
```



### UTF-8编码中的中文占几个字节，int占几个字节

utf-8是一种变长编码技术，utf-8编码中的中文占用的字节不确定，可能2个、3个、4个

int类型占用4个字节（32位）。int类型可以表示的整数范围是-2147483648 ~ 2147483647。如果需要更大的整数范围，可以使用long类型，它占用8个字节（64位），可以表示更大的整数范围



### 讲一下常见编码方式

- 编码的意义：计算机中存储的最小单元是一个字节即8bit，所能表示的字符范围是255个，而人类要表示的符号太多，无法用一个字节来完全表示，固需要将符号编码，将各种语言翻译成计算机能懂的语言。

- ASCII码：共有128个，用一个字节的低7位表示

- ISO8859-1：在ASCII码的基础上涵盖了大多数西欧语言字符，仍然是单字节编码，它总共能表示256个字符

- GB2312：双字节编码，总编码范围是A1-A7,A1-A9是符号区，包含682个字符，B0-B7是汉字区，包含6763个汉字

- GBK：为了扩展GB2312,加入了更多的汉字，编码范围是8140~FEFE，有23940个码位，能表示21003个汉字

- UTF-16：具体定义了Unicode字符在计算机中的存取方法。采用2字节来表示Unicode转化格式，它是定长的表示方法，不论什么字符都可以用两个字节表示

- UTF-8：  UTF-16统一采用两字节表示一个字符，但有些字符只用一个字节就可表示，浪费存储空间，而UTF-8采用一种变长技术，每个编码区域有不同的字码长度。 不同类型的字符可以由1~6个字节组成

  ​                  如果一个字节，最高位为0，表示这是一个ASCII字符（00~7F）
  ​                  如果一个字节，以11开头，连续的1的个数暗示这个字符的字节数 



### 多态

通过多态的使用，可以使代码更加灵活，提高代码的可维护性和可扩展性。多态的实现方式在Java中是通过继承、接口和抽象类等机制来实现的。在使用多态时，需要注意继承、方法重写和访问修饰符等细节问题

- 多态是指父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作 作用于不同对象，产生不同的执行结果
- 多态的三个条件：继承父类，重写父类方法，父类引用指向子类对象
- *实现多态的技术称为*动态绑定，在执行期间判断所 引用对象的实际类型，根据其实际的类型调用其相应的方法
- 多态的好处：可扩充
- Java 中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方 法重载





### Java中实现多态的机制

- Java实现多态有三个必要条件：继承、重写、向上转型，在多态中需要将子类的引用赋值给父类对象，只有这样该引用才能够具备调用父类方法和子类的方法



### 为什么要有内部类，说一下成员内部类，静态内部类，局部内部类，匿名内部类

内部类能更好的隐藏一些细节，而且可以实现java多继承 [参考](https://blog.csdn.net/u013728021/article/details/87358517?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control) 



内部类的存在可以提高代码的可读性和可维护性，同时也可以隐藏一些实现细节，增加安全性。但是过度使用内部类可能会增加代码的复杂度，影响程序的性能。所以在使用内部类时，需要权衡好利弊，根据实际情况进行选择



- 内部类提供了更好的封装，可以把内部类隐藏在外部类内，不允许同一个包中的其他类访问该类
- 内部类的方法可以直接访问外部类的所有数据，包括私有的数据
- 内部类的作用：可以访问外部类的所有资源，实现隐藏，实现多重继承，优化简单的接口实现

- ```java
  // 实力化成员内部类，可以访问外部类的所有资源，但不能定义静态资源，因为其实力化需依靠外部类
  Parent.InnerClass innerClass = new Parent().new InnerClass();
  
  // 实力化静态内部类，只能访问外部类的静态资源
  Parent.StaticInnerClass staticInnerClass = new Parent.StaticInnerClass();
  
  // 局部内部类，不能被任何修饰符修饰，且只能访问所在代码块或自定义为final的局部变量
  
  // 匿名内部类
  ```



如果当内部类的引用被外部类以外的其他类引用时，就会造成内部类和外部类无法被GC回收的情况，即使外部类没有被引用，因为内部类持有指向外部类的引用，从而引起内存泄露





### 抽象类的意义

- 抽象方法必须为public或者protected
- 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类



### 接口的意义

- 接口中的变量会被隐式地指定为public static final变量
- 方法会被隐式地指定为public abstract方法
- java8之后可以用static，default写方法体





### 接口和抽象类的区别

1. 定义方式：接口使用interface关键字定义，而抽象类使用abstract关键字定义。
2. 实现方式：类可以实现多个接口，但只能继承一个抽象类。
3. 成员变量：接口中只能定义静态常量，而抽象类中可以定义静态常量、实例变量和静态变量。
4. 方法实现：接口中的方法都是抽象的，只有方法签名，没有方法实现。而抽象类中可以定义抽象方法和非抽象方法，其中抽象方法没有方法体，非抽象方法有方法体。
5. 构造方法：接口没有构造方法，而抽象类有构造方法，可以被子类调用。
6. 使用范围：接口主要用于定义标准，强制实现某些行为，而抽象类则用于封装公共的功能和属性，提供默认的实现。
7. 实现继承关系：接口只能实现继承，即实现接口的类必须实现接口中所有的抽象方法。而抽象类可以被子类继承并扩展，子类可以选择性地实现抽象方法。

总的来说，接口用于定义标准和规范，强制实现某些行为；而抽象类则用于封装公共的功能和属性，提供默认的实现





### 3.Comparable和Comparator

Comparable 可以看作是“对内”进行排序接口，而 Comparator 是“对外”进行排序的接口

Comparable 是通过重写 compareTo 方法实现排序的，而 Comparator 是通过重写 compare 方法实现排序的

Comparable 必须由自定义类内部实现排序方法，而 Comparator 是外部定义并实现排序的







### 6.Wait / Sleep / Yield方法的区别

三个方法都可以用来暂停线程，区别：

1. wait 是 Object 中的方法，而sleep/yield是Thread中的方法
2. 调用 wait 时会释放锁并让出cpu，而调用sleep/yield不会释放锁，只让出cpu
3. 调用 wait 之后，别的线程调用该 Object 的 notify/notifyAll 之后，才有机会获得cpu和锁，而sleep/yield再次获得cpu之后就可以继续运行
4. 调用sleep之后会被阻塞挂起指定的时间，线程调度器不会去调度该线程，而yield则是让出剩余时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器很有可能会调度执行该线程







### 10.Java序列化与反序列化

Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：

1. 序列化：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。
2. 反序列化：客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象



### 11.序列化与反序列化的好处

1. 对象序列化可以实现分布式对象
2. java对象序列化可以递归保存对象引用的每个对象的数据
3. 序列化可以将内存中的类写入文件或数据库中
4. 对象、文件、数据，有许多不同的格式，很难统一传输和保存，序列化以后就都是字节流了，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件



### 12.如何实现Java序列化与反序列化

```java
// 实现 Serializabel接口
public class Person implements Serializable {
    // ...
}


public static void main(String[] args) throws Exception {
    //序列化后生成指定文件路径
    File file = new File("path");
    ObjectOutputStream oos = null;
    
    //装饰流
    oos = new ObjectOutputStream(new FileOutputStream(file));

    //实例化类
    Person per = new Person();
    oos.writeObject(per); //把类对象序列化
    oos.close();
}
```





### 13.Comparable和Comparator的区别

二者都是用来实现对象的比较、排序，Comparable 是在`集合内部`定义的方法实现的排序，Comparator 是在`集合外部`实现的排序

1. 内部排序调用 `Collections.sort(list);` ，外部排序则使用 `list.sort(Comparator 类型的参数)` 
2. 若一个类实现了Comparable接口，就意味着该类支持排序，而Comparator是比较器，若需要控制某个类的次序，可以建立一个该类的比较器来进行排序
3. 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码



Comparable：

```java
package java.lang;
import java.util.*;

public interface Comparable<T> {
  // 通过 x.compareTo(y) 来“比较x和y的大小”
	// 若返回“负数”，意味着“x比y小”
	// 返回“零”，意味着“x等于y”
	// 返回“正数”，意味着“x大于y”
    public int compareTo(T o);
}
```



Comparator：

```java
package java.util;

public interface Comparator<T> {

  	// 返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”
    int compare(T o1, T o2);

    boolean equals(Object obj);
}
```





### IO的理解，NIO，BIO



### 14.IO同步、异步、阻塞、非阻塞的区别







### 19.ClassNotFoundException 和 NoClassDefFoundError 有什么区别

| ClassNotFoundException                                       | NoClassDefFoundError                          |
| ------------------------------------------------------------ | --------------------------------------------- |
| 继承自 `java.lang.Exception`                                 | 继承自 `java.lang.Error`                      |
| 当动态加载Class时找不到类会抛出异常                          | 当编译成功后，执行过程中找不到Class抛出该错误 |
| 一般在执行`Class.forName()`，`ClassLoader.loadClass()`以及使用`ClassLoader.findSystemClass()` 时抛出异常 | 由JVM运行时，系统抛出                         |





### 20.Java中的4种引用类型

强引用、软引用、弱引用、虚引用





### 21.Java中常见的8种锁

#### 公平锁/非公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁，非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，非公平锁会造成优先级反转或者饥饿现象

1. 对于Java `ReentrantLock`而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大
2. 对于`Synchronized`而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁



#### 可重入锁

可重入锁又名递归锁，是指在同一个线程可以多次获得同一个锁

1. 对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁
2. 对于Synchronized而言，也是一个可重入锁，可重入锁的一个好处是可一定程度避免死锁



#### 独享锁/共享锁

独享锁是指该锁一次只能被一个线程所持有，Synchronized / ReentrantLock是独享锁，共享锁是指该锁可被多个线程所持有，Lock的另一个实现类`ReadWriteLock`，其读锁是共享锁，其写锁是独享锁

1. 读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的
2. 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享



#### 互斥锁/读写锁

独享锁/共享锁只是一种广义的说法，互斥锁/读写锁就是具体的实现：

1. 互斥锁在Java中的具体实现就是`ReentrantLock`
2. 读写锁在Java中的具体实现就是`ReadWriteLock`



#### 乐观锁/悲观锁

1. 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题

2. 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的

3. 悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升

   悲观锁在Java中的使用，就是利用各种锁

4. 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新



#### 分段锁

分段锁其实是一种锁的设计，并不是具体的一种锁，对于`ConcurrentHashMap`而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作，以ConcurrentHashMap来说一下分段锁的含义以及设计思想：

1. `ConcurrentHashMap`中的分段锁称为Segment，它即类似于HashMap的结构，内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock，因为Segment继承了`ReentrantLock`
2. 当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入
3. 但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作



#### 偏向锁/轻量级锁/重量级锁



#### 自旋锁

在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU







### 25.Java 内存模型JMM 

JMM 规定了线程的工作内存和主内存的交互关系，以及线程之间的可见性和程序的执行顺序：

1. 一方面，要为程序员提供足够强的内存可见性保证
2. 另一方面，对编译器和处理器的限制要尽可能地放松。JMM 对程序员屏蔽了 CPU 以及 OS 内存的使用问题，能够使程序在不同的 CPU 和 OS 内存上都能够达到预期的效果

Java 采用内存共享的模式来实现线程之间的通信。编译器和处理器可以对程序进行重排序优化处理，但是需要遵守一些规则，不能随意重排序

jmm用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量

JMM 是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的







### 32.深拷贝和浅拷贝

浅拷贝是指将一个对象复制到另一个对象，但复制过程中只复制对象的引用，而不复制对象内部的数据。也就是说，新的对象中的变量指向的是原始对象中的数据，两个对象中如果其中一个对象的数据被修改了，另一个对象也会改变

在java中实现 `Cloneable`，重写 clone()就可以实现浅拷贝：

```java
@Override
protected Line clone() throws CloneNotSupportedException {
    return (Line)super.clone();
}
```



深拷贝是指将一个对象复制到另一个对象，但复制过程中不仅复制对象的引用，而且复制对象内部的数据。也就是说，新的对象与原始对象完全独立，两者之间互不干扰，因此即使一个对象的数据被修改了，另一个对象也不会改变，深拷贝的两种实现方式：

```java
@Override
protected Header clone() throws CloneNotSupportedException {
    Header header = (Header) super.clone();
    Line line = header.getLine().clone();
    header.setLine(line);
    return header;
}

// 序列化，实现 Serializable 接口，当前对象和引用对象都要实现该接口
public Header deepClone () {

    ByteArrayOutputStream bos  = null;
    ObjectOutputStream oos = null;

    ByteArrayInputStream bis = null;
    ObjectInputStream ois = null;

    try {

        bos = new ByteArrayOutputStream();
        oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        bis = new ByteArrayInputStream(bos.toByteArray());
        ois = new ObjectInputStream(bis);
        return (Header) ois.readObject();

    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            bos.close();
            oos.close();
            bis.close();
            ois.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return null;
}
```





### 33.Java 异常

- 所有异常类的基类是Throwable类，两大子类分别是Error和Exception

- 异常又分为RuntimeException和CheckedException，检查时异常如IOException, FileNotFoundException

- Error是程序无法处理的错误，由JVM产生和抛出的，比如OutOfMemoryError，ThreadDeath等，这些异常发生时，Java虚拟机一般会选择线程终止

- 异常处理：throws，throw，try，catch，finnaly

  

#### Throwable

`Throwable` 是 Java 语言中所有错误与异常的超类， 包含两个子类：Error 和 Exception，它们通常用于指示发生了异常情况，提供了 `printStackTrace()` 等接口用于获取堆栈跟踪数据等信息



#### Error

程序中无法处理的错误，表示运行应用程序中出现了严重的错误，此类错误一般表示代码运行时 JVM 出现问题，通常有 `Virtual MachineError` 虚拟机运行错误、`NoClassDefFoundError` 类定义错误， `OutOfMemoryError` 内存不足，`StackOverflowError` 栈溢出错误，此类错误发生时，JVM 将终止线程



#### Exception

程序本身可以捕获并且可以处理的异常，分为运行时异常和编译时异常

1. 运行时异常：RuntimeException 类及其子类，Java 编译器不会检查它没有通过throws声明抛出它，也没有用try-catch语句捕获它，还是会编译通过，如 `NullPointerException ArrayIndexOutBoundException ClassCastException` 
2. 编译时异常：除 RuntimeException 及其子类之外的异常，必须手动在代码里添加`try-catch`捕获语句来处理该异常，否则不能通过编译，如`SQLException  IOException  FileNotFoundException  ClassNotFoundException`





### 34.Error 和 Exception 区别

Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复

Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行





### 35.final、finally、finalize 有什么区别

1. final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值
2. finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码
3. `finalize()`是Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作



### 36.try-catch-finally 中哪个部分可以省略

catch



### 37.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗

会执行，在 return 前执行



### 38.SimpleDateFormat 的线程安全问题

定义为static 的SimpleDateFormat存在线程安全问题

SimpleDateFormat 继承 DateFormat ,DateFormat 有一个成员变量 `calendar`：

SimpleDateFormat中的format方法在执行过程中，会使用一个成员变量calendar来保存时间。这其实就是问题的关键：

```java
private StringBuffer format(Date date, StringBuffer toAppendTo,
                                FieldDelegate delegate) {
        // Convert input date to time field list
        calendar.setTime(date);
  			// ...
}
```



声明SimpleDateFormat的时候，使用的是static定义的，那么这个SimpleDateFormat就是一个共享变量，随之，SimpleDateFormat中的calendar也就可以被多个线程访问到，假设线程1刚刚执行完calendar.setTime把时间设置成2018-11-11，还没等执行完，线程2又执行了calendar.setTime把时间改成了2018-12-12。这时候线程1继续往下执行，拿到的calendar.getTime得到的时间就是线程2改过之后的





### 40.new 一个对象 JVM做了什么

1. 首先去常量池中看能否根据这个类的全路径找到这个类的信息，查看是否加载过，解析，初始化过。如果没有，则先进行类加载过程
2. 接下来JVM从堆内存里为新的对象分配内存，对象所需的内存大小在类加载的时候就可以完全确定





### 41.new String("123") 创建了几个对象

1. 如果方法区的常量池中，已经存在`123`，则只需在堆里创建一个对象就行，栈里的变量引用指向堆
2. 如果常量池中不存在`123`，先在常量池中创建，然后在堆里new一个对象，栈里的变量引用指向堆





### 说一下泛型原理，并举例说明

泛型原理是指在编写代码时，允许参数类型（或返回类型）可以被指定为某个特定类型的变量，而不是具体的数据类型。泛型通常使用类型参数来实现，允许在调用泛型时指定实际的类型。这允许我们编写更灵活、可重用的代码，提高了程序的可读性和可维护性

```java
List<String>  list  =  new  ArrayList<>();
```





### 泛型中extends和super的区别

- `<? extends Fruit>`代表上界通配符，List中存放的对象都是Fruit以及其子类对象，由于不能确定List中是Fruit还是其子类对象，所以add的时候会报错，`确切的说不能add除了null以外的所有对象，包括object`

  ```java
  public void call(List<? extends Fruit> fruits) {
    for (Fruit fruit: fruits) {
      // ...
    }
  }
  
  public static void main(String[] args) {
    List<Banana> bananaList = new ArrayList<>();
    // 编译通过，若call方法中的参数直接写List<Fruit>会编译不通过
    new Fruit().call(bananaList);
  }

- super与extends是完全相反的，其定义的是下界通配符，`List<? super Fruit>`存放的是Fruit和它的父类的对象，如Object等，只能添加Fruit类型及其子类对象，并且取出的数据类型都为Object

  ```java
  public void call(List<? super Fruit> fruits) {
    fruits.add(new Fruit());
    fruits.add(new Banana());
    // 遍历的类型都为Object
    for (Object fruit : fruits) {
      // ... 
    }
  }
  ```

  



### 静态属性和静态方法能不能被继承和重写，为什么

- 静态属性和静态方法是可以被子类继承的，但静态属性和方法不能被子类重写
- 静态成员属于类本身，而不是类的实例，因此在子类中并不创建静态成员的副本，而是直接继承父类的静态成员。而重写是针对实例方法的，因为实例方法是根据对象的实际类型来调用的，所以子类可以根据需要重新实现它们。但是静态成员是基于类本身而不是基于对象的，因此它们不受继承机制的影响，也不能被重写
- 子类可以使用父类的静态成员，包括静态属性和静态方法。这是因为静态成员是公共的，可以被类和它的实例访问。但是，建议在访问静态成员时使用类名来引用它们，而不是使用实例变量。因为静态成员是属于类本身的，而不是实例，使用实例变量访问静态成员可能会导致混淆和意外的行为





### 注解

- 注解是通过@interface关键字来进行定义的，形式和接口差不多，只是前面多了一个@
- 要使注解能正常工作，还需要使用元注解，它是可以注解到注解上的注解，元标签有@Retention @Documented @Target @Inherited @Repeatable五种
- @Retention说明注解的存活时间，取值有RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时被丢弃；RetentionPolicy.CLASS 注解只保留到编译进行的时候，并不会被加载到JVM中，RetentionPolicy.RUNTIME可以留到程序运行的时候，它会被加载进入到JVM中，所以在程序运行时可以获取到它们
- @Target 限定注解的应用场景，ElementType.FIELD给属性进行注解；ElementType.LOCAL_VARIABLE可以给局部变量进行注解；ElementType.METHOD可以给方法进行注解；ElementType.PACKAGE可以给一个包进行注解 ElementType.TYPE可以给一个类型进行注解，如类、接口、枚举



- 何时执行：`@Retention(RetentionPolicy.RUNTIME)`
- 作用对象：`@Target(ElementType.TYPE)` 



### 序列化的方式



### Serializable 和Parcelable 的区别



### 闭包和局部内部类的区别



### 静态代理和动态代理的区别

- 静态代理中的代理类是由程序员编写的，执行之前就已经存在class文件，而且一般来说一个代理类只能代理一个目标对象，静态代理要求代理类和目标类都实现同一接口，代码冗余高
- 动态代理则是根据程序的运行时动态的生成代理类，可以通过反射或者就修改字节码的生成代理类，如jdk，cglib动态代理

`代理解决的问题是当两个类需要通信时，引入第三方代理类，将两个类的关系解耦，代理类和委托类要实现相同的接口，因为代理真正调用的还是委托类的方法` 

- 静态代理：由程序员创建或特定工具自动生成源代码，再对其编译，在程序运行之前，代理类的class类文件就已经被创建了，静态代理通常只代理一个类，需要实现接口，造成代码冗余，只能对固定接口的实现类实现代理，灵活性较差

- 动态代理：在程序运行时通过反射机制动态创建代理类，动态代理代理的是一个接口下的多个实现类，只需将被委托类作为参数传入即可，使用灵活；服务内容只需写在invoke方法中，但效率低

- 动态代理基于JDK实现：通过JDK提供的工具方法Proxy.newProxyInstance动态构建全新的代理类（继承Proxy类，并持有InvocationHandler接口引用）字节码文件并实例化对象返回。由Java内部的反射机制来实例化代理对象，并代理的调用委托类方法

  ```java
 Proxy.newProxyInstance(
                  被代理类.getClass().getClassLoader(),
                  被代理类.getClass().getInterfaces(), 
                  this);
  ```

  

- 动态代理基于CGlib实现：基于继承被代理类生成代理子类，不用实现接口，只需被代理类为非final类，底层借用ASM字节码技术实现

- 动态代理基于AspectJ实现：修改目标类的字节，织入代理的字节，在程序编译的时候，插入动态代理的字节码，不会生成全新的class





### 解析与分派

- ###### 解析：指方法在运行前，即编译期间就可知的，有一个确定的版本，运行期间也不会改变。解析是静态的，在类加载的解析阶段就可将符号引用转变成直接引用

- ###### 分派：可分为静态分派和动态分派，重载属于静态分派，覆盖属于动态分派。 静态分派是指在重载时通过参数的静态类型而非实际类型作为判断依据，在编译阶段，编译器可根据参数的静态类型决定使用哪一个重载版本。 动态分派则需要根据实际类型来调用相应的方法



### 如何将一个Java对象序列化到文件里

- `ObjectOutputStream.writeObject()`负责将指定的流写入，`ObjectInputStream.readObject()`从指定流读取序列化数据

  ```java
  //写入
  try {
      ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream("D:/student.txt"));
      os.writeObject(studentList);
      os.close();
  } catch(FileNotFoundException e) {
      e.printStackTrace();
  } catch(IOException e) {
      e.printStackTrace();
  }
  ```

  

### 反射

- 在运行状态中，对任意一个类，都能知道这个类的所有属性和方法，对任意一个对象，都能调用它的任意一个方法和属性，这种能动态获取信息及动态调用对象方法的功能称为java语言的反射机制
- 开发过程中，经常会遇到某个类的某个成员变量、方法或属性是私有的，或只对系统应用开放，这里就可以利用java的反射机制通过反射来获取所需的私有成员或是方法
- 带有Declared修饰的方法可以反射到私有的方法，没有Declared修饰的只能用来反射公有的方法



### transient

Java中`transient`关键字的作用，就是让某些被修饰的成员属性变量不被序列化





## 集合

### 集合类以及集合框架

Java集合类是Java编程语言中提供的一组数据结构，用于存储和操作一组对象。Java集合框架是由一组接口、类和算法组成的，用于表示和操作集合类。

Java集合框架包括以下接口：Collection、List、Set、Map、Queue、Deque等。其中，Collection是所有集合类的根接口，List表示有序的集合（即可以按照添加顺序访问元素），Set表示无序且不重复的集合，Map表示键值对映射，Queue表示先进先出队列，Deque表示双向队列。

Java集合类主要有ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap等。其中，ArrayList和LinkedList都实现了List接口，HashSet和TreeSet实现了Set接口，HashMap和TreeMap实现了Map接口。这些集合类提供了各种方法，如添加、删除、查找、排序等，以便开发人员在程序中高效地处理数据集合



### 容器类介绍以及之间的区别

容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 [Java容器类](http://alexyyek.github.io/2015/04/06/Collection/) 





### 列举java的集合以及集合之间的继承关系





### ArrayList

默认容量为10，当容量变为10时，扩容为原来的1.5倍，扩容的公式为 ：

```java
int newCapacity = oldCapacity + (oldCapacity >> 1);
```





### ArrayList 和 LinkedList 的区别

1. ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构
2. 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针
3. 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据



### ArrayList 和 Vector 的区别

1. 同步性：Vector是线程安全的，而ArrayList是线程序不安全的，ArrayList效率会高些
2. 数据增长性：Vector默认增长为原来两倍，而ArrayList增长为原来的1.5倍，ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法



### Array 和 ArrayList 的区别

1. Array 可以包含基本数据类型和引用类型，ArrayList只能包含引用类型
2. ArrayList是基于数组实现的，Array大小不可以调整，但ArrayList可以通过内部方法自动调整容量
3. ArrayList是List接口的实现类，相比Array支持更多的方法和特性



### HashSet 的实现原理

1. HashSet是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 `PRESENT`，它是一个静态的 Object 对象
2. 要将某个对象放入HashSet中时，要重写该类的equals(Object obj)方法和 hashCode() 方法
3. HashSet的其他操作都是基于HashMap的



### List如何一边遍历，一边删除

```java
public static void main(String[] args) {
    List<String> platformList = new ArrayList<>();
    platformList.add("博客园");
    platformList.add("CSDN");
    platformList.add("掘金");

    // 使用迭代器删除
    Iterator<String> iterator = platformList.iterator();
    while (iterator.hasNext()) {
        String platform = iterator.next();
        if (platform.equals("博客园")) {
            iterator.remove();
        }
    }
    
    // 正序删除
    for (int i = 0; i < platformList.size(); i++) {
        String item = platformList.get(i);

        if (item.equals("博客园")) {
            platformList.remove(i);
            i = i - 1;
        }
    }
        
    // 倒叙删除
    for (int i = platformList.size() - 1; i >= 0; i--) {
        String item = platformList.get(i);

        if (item.equals("掘金")) {
            platformList.remove(i);
        }
    }

    System.out.println(platformList);
}


```





### Iterater和ListIterator的区别

1. 来遍历Set和List集合，而ListIterator只能遍历List
2. Iterator只能往后遍历，而LIstIterator可以双向遍历
3. ListIterator从Iterator接口继承，添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置





### fail-fast

每次尝试获取下一个元素的时候，Iterator `fail-fast` 属性检查当前集合结构里的任何改动，如果发现任何改动，它抛出`ConcurrentModificationException`，Collection中所有Iterator的实现都是按fail-fast来设计的，ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外

fail—fast迭代器抛出ConcurrentModificationException，fail—safe迭代器从不抛出ConcurrentModificationException，java.util.concurrent中的集合类都为fail-safe的，所以可以使用juc下的并发集合类避免这种异常





### List,Set,Map的区别

List的元素以线性方式存储，有序而且可以存放重复对象，List主要有以下两个实现类：

1. ArrayList：长度可变的数组，可以对元素进行随机的访问，向ArrayList中插入与删除元素的速度慢。JDK8中ArrayList扩容的实现是通过`grow()`方法里使用语句`newCapacity = oldCapacity + (oldCapacity >> 1)`（即1.5倍扩容）计算容量，然后调用`Arrays.copyof()`方法进行对原数组进行复制
2. LinkedList: 采用链表数据结构，插入和删除速度快，但访问速度慢



Set中的对象无序，并且没有重复对象，Set主要有以下两个实现类：

1. HashSet：HashSet按照哈希算法来存取集合中的对象，存取速度比较快
2. TreeSet：TreeSet实现了SortedSet接口，能够对集合中的对象进行排序



Map是一种以键值对映射的集合，主要有以下实现类：

1. HashMap：HashMap基于散列表实现，其插入和查询`<K,V>`的开销是固定的，可以通过构造器设置容量和负载因子来调整容器的性能
2. LinkedHashMap：类似于HashMap，但是迭代遍历它时，取得`<K,V>`的顺序是其插入次序，或者是最近最少使用(LRU)的次序
3. TreeMap：基于红黑树实现。查看`<K,V>`时会被排序，TreeMap是唯一的带有`subMap()`方法的Map，`subMap()`可以返回一个子树



### List和Map的实现方式以及存储方式



### HashMap的实现原理



### HashMap 的底层结构

1. 1.7中采用数组+链表，1.8采用的是数组+链表/红黑树，链表长度超过一定长度后就改成红黑树存储。 
2. 1.7扩容时需要重新计算哈希值和索引位置，1.8并不重新计算哈希值，巧妙地采用和扩容后容量进行&操作来计算新的索引位置
3. 1.7是采用表头插入法插入链表，1.8采用的是尾部插入法
4. 在1.7中采用表头插入法，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题；在1.8中采用尾部插入法，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了



### HashMap 在 Put 时，新链表节点是放在头部还是尾部



### HashMap如何put数据

1. 往map插入元素的时候首先通过对key hash然后与数组长度-1进行与运算((n-1)&hash)，都是2的次幂所以等同于取模，但是位运算的效率更高
2. 找到数组中的位置之后，如果数组中没有元素直接存入，反之则判断key是否相同，key相同就覆盖，否则就会插入到链表的尾部
3. 如果链表的长度超过8，则会转换成红黑树
4. 最后判断数组长度是否超过默认的长度*负载因子也就是12，超过则进行扩容
5. 在第一次 put 的时候，调用 `resize()` 方法进行 table 的初始化，默认情况下`table.length = 16, threshold = 12`，能存放 12 个元素，当存放第 13 个元素后进行扩容

![](https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XDk1m8MBdwesZicKgricM5TicHSSmGXOtd3mVUX7VO2WSgXsFUBbpz85LIhah4AgYh9zqe29OicibMWcLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





### HashMap 扩容流程

[HashMap扩容流程[通俗易懂]](https://cloud.tencent.com/developer/article/2129161) 

1. 当 size > threshold 的时候进行扩容

2. 扩容之后的 table.length = 旧 table.length * 2

3. 扩容之后的 threshold = 旧 threshold * 2

   

JDK1.8 HashMap 扩容阶段重新映射元素时不需要像 1.7 版本那样重新去一个个计算元素的 hash 值，而是通过 `hash & oldCap` 的值来判断，若为 0 则索引位置不变，不为 0 则`新索引=原索引+旧数组长度`，因为指长度扩为原来 2 倍，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置



链表长度大于等于 8且table 数组长度大于等于 64，因为当 table 数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长



### 为何HashMap的数组长度一定是2的次幂

HashMap 通过 `tableSizeFor()` 来返回大于等于输入参数且最近的 2 的整数次幂的数：

```java
/*找到大于或等于 cap 的最小2的幂，用来做容量阈值*/  
static final int tableSizeFor(int cap) {  
    int n = cap - 1;  
    n |= n >>> 1;  
    n |= n >>> 2;  
    n |= n >>> 4;  
    n |= n >>> 8;  
    n |= n >>> 16;  
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;  
}
```

设置成2次幂的好处：

1. 可以使用位运算来计算元素在数组中的下标

   HashMap 是通过 `index=hash&(table.length-1)` 来计算元素在 table 数组中存放的下标，这条公式其实等价于 `hash%table.length-1`，只不过只有当数组长度为 2 的幂次方时，hash&(length-1) 才等价于 hash%length，使用位运算可以提高效率

2. 增加 hash 值的随机性，减少 hash 冲突

   如果 length 为 2 的幂次方，则 length-1 转化为二进制必定是 11111……的形式，这样的话可以使所有位置都能和元素 hash 值做与运算



### 为什么HashMap加载因子的默认值是 0.75

1. 如果loadFactor太小，那么map中的table需要不断的扩容，扩容是个耗时的过程
2. 如果loadFactor太大，那么map中table放满了也不不会扩容，导致冲突越来越多，解决冲突而起的链表越来越长，效率越来越低



### HashMap 边遍历边删除 fail-fast异常

在遍历 HashMap 的时候，若使用 remove 方法删除元素时会抛出 `ConcurrentModificationException` 异常

 HashMap 中有一个名为 modCount 的变量，它用来表示集合被修改的次数，修改指的是插入元素或删除元素，在遍历 HashMap 时，每次遍历下一个元素前都会对 modCount 进行判断，若和原来的不一致说明集合结果被修改过了，然后就会抛出异常



### Map map = new HashMap(1000)什么时候扩容

此时的 table.length = 2^10 = 1024; threshold = 1024 * 0.75 = 768; 所以存入第 769 个元素时进行扩容



### Map map = new HashMap(10000) 存入第 10001个元素时会触发 扩容吗

此时的 table.length = 2^14 = 16384; threshold = 16384 * 0.75 = 12288; 所以存入第 10001 个元素时不会进行扩容



### 手写hashmap需要注意什么

- key在数组中的位置，减少hash冲突
- 扩容阈值
- 何时将链表转红黑树
- 初始容量，加载因子



### ArrayMap和HashMap的对比



### HashTable实现原理





### HashMap 为什么不是线程安全的

1. 在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失
2. 在jdk1.8中，在多线程环境下，会发生数据覆盖的情况







### TreeMap具体实现





### HashMap / TreeMap

1. `TreeMap<K,V>`的Key值要求实现`java.lang.Comparable` （或者在新建时传入comparator），所以迭代的时候TreeMap默认是按照Key值升序排序的

   ```java
   public TreeMap() {
     comparator = null;
   }
   
   
   public TreeMap(Comparator<? super K> comparator) {
     this.comparator = comparator;
   }
   ```

   

2. TreeMap的实现是基于红黑树结构，TreeMap没有调优选项/加载因子，因为该树总处于平衡状态

3. `HashMap<K,V>`的Key值实现散列`hashCode()`，分布是散列的、均匀的，不支持排序；数据结构主要是数组，链表或红黑树。适用于在Map中插入、删除和定位元素

4. HashMap 和 TreeMap 都是非线程安全，HashMap继承AbstractMap抽象类，TreeMap继承自SortedMap接口

5. TreeMap中默认是按照升序进行排序的，要想倒叙可通过自定义的比较器来实现，在返回时多添加了个负号，就将比较的结果以相反的形式返回：

   ```java
   static class MyComparator implements Comparator{
       @Override
       public int compare(Object o1, Object o2) {
           // TODO Auto-generated method stub
           String param1 = (String)o1;
           String param2 = (String)o2;
           return -param1.compareTo(param2);
       }   
   }
   ```

   



### HashMap和HashTable的区别

主要区别：

1. 线程安全：HashTable是线程安全的，而HashMap是非线程安全的。
2. 效率：Hashtable在并发环境下效率较低，而HashMap在并发环境下效率较高。
3. null键值：Hashtable不允许键或值为null，而HashMap则可以。
4. 迭代器：HashMap的迭代器是fail-fast迭代器，而Hashtable的迭代器不是。
5. 继承关系：Hashtable是Dictionary类的子类，而HashMap是AbstractMap类的子类。
6. 扩容机制：Hashtable采用的是增加两倍的方式扩容，而HashMap采用的是增加一倍的方式扩容。
9. 数据结构：Hashtable使用的是链表数组结构，而HashMap使用的是链表和红黑树结构，当链表长度超过阈值时，会转化为红黑树，以提高搜索效率。



### HashMap与HashSet的区别



### HashSet与HashMap怎么判断集合元素重复



### 集合Set实现Hash怎么防止碰撞



### ArrayList和LinkedList的区别，以及应用场景



### Hashmap为什么用红黑树，红黑树的优缺点，为什么不用avl树

- 红黑树不追求"完全平衡"，不像AVL那样要求左右子树高度它相差1，只要求部分达到平衡，但是提出了为节点增加颜色，`任何不平衡都会在三次旋转之内解决`，而AVL是严格平衡树，因此在增加或者删除节点时，旋转的次数可能比红黑树要多



### 经常用到哪些 Map，这几种 Map 的区别

HashMap，LinkedHashMap，ConcurrentHashMap



### Map、List、Set 分别说下你知道的线程安全类和线程不安全的类

```
HashTable，Collections.synchronizedMap()，ConcurrentHashMap

Vector，Collections.synchronizedList(List< T> list)，CopyOnWriteArrayList

Collections.synchronizedSet()，Collections.newSetFromMap()，CopyOnWriteArraySet，ConcurrentHashMap.newKeySet()

```



### 常用并发集合了解哪些





### ConcurrentHashMap 底层结构

JDK1.7 中的 ConcurrentHashMap 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成，即 ConcurrentHashMap 把哈希桶数组切分成小数组Segment，每个小数组有 n 个 HashEntry 组成

![](https://img2020.cnblogs.com/other/2283341/202101/2283341-20210126111703956-642010540.png)



```java
// Segment 继承了 ReentrantLock，所以 Segment 是一个可重入锁，Segment 默认为 16，也就是并发度为 16
static class Segment<K,V> extends ReentrantLock implements Serializable {
  private static final long serialVersionUID = 2249069246763182397L;

  transient volatile HashEntry<K,V>[] table;
  
  // 元素的个数，这里没有加volatile修饰，所以只能在加锁或者确保可见性
  // 如Unsafe.getObjectVolatile的情况下进行访问，不然无法保证数据的正确性
  transient int count;

  // segment元素修改次数记录，由于未进行volatile修饰，所以访问规则和count类似
  transient int modCount;

  // 扩容指标
  transient int threshold;

  // 负载因子
  final float loadFactor;

}

static final class HashEntry<K,V> {
  final int hash;
  final K key;
  // 用 volatile 修饰了 HashEntry 的数据 value 和 下一个节点 next
  // 保证了多线程环境下数据获取时的可见性
  volatile V value;
  volatile HashEntry<K,V> next;
}
```





 JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的Node数组+链表+红黑树结构，在锁的实现上，抛弃了原有的 Segment 分段锁，采用`CAS + synchronized`实现更加细粒度的锁，只锁住这个链表头节点或红黑树的根节点，就不会影响其他的哈希桶数组元素的读写，大大提高了并发度

![](https://img2020.cnblogs.com/other/2283341/202101/2283341-20210126111704792-1503647637.png)



### ConcurrentHashMap的实现原理

Jdk1.7 中采用分段锁和 HashEntry 使锁更加细化，ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量）的线程并发



Jdk1.8 利用 CAS+Synchronized 来保证并发更新的安全，当然底层采用数组+链表+红黑树的存储结构

1. table 中存放 Node 节点数据，默认 Node 数据大小为 16，扩容大小总是 2^N
2. 为了保证可见性，Node 节点中的 val 和 next 节点都用 volatile 修饰
3. 当链表长度大于 8 时，会转换成红黑树，节点会被包装成 TreeNode放在TreeBin 中
4. put()：1. 计算键所对应的 hash 值；2. 如果哈希表还未初始化，调用 initTable() 初始化，否则在 table 中找到 index 位置，并通过 CAS 添加节点。如果链表节点数目超过 8，则将链表转换为红黑树。如果节点总数超过阈值，则进行扩容操作
5. get()：无需加锁，直接根据 key 的 hash 值遍历 node



相关文章参考： [Java并发系列 | ConcurrentHashMap源码分析](http://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&mid=2247485381&idx=2&sn=868acc93976ea82563f8557363b97f9e&chksm=fc7a6a6bcb0de37d89ea3d21297c391355519c4a5d74eeaafc9f52bdce983da8f963012220cf&scene=21#wechat_redirect) 



### ConcurrentHashMap是何保证线程安全

1. 在1.8中ConcurrentHashMap的get操作全程不需要加锁，这也是它比其他并发集合比如hashtable、用Collections.synchronizedMap()包装的hashmap;安全效率高的原因之一
2. get操作全程不需要加锁是因为Node的成员val是用volatile修饰的和数组用volatile修饰没有关系
3. 数组用volatile修饰主要是保证在数组扩容的时候保证可见性



### CocurrentHashMap 在 JDK 1.8 前后的锁有什么区别



### CocurrentHashMap 在 JDK 1.8 有什么改变



### JDK 1.7 ConcurrentHashMap 的 put 方法

1. 先定位到相应的 Segment ，然后再进行 put 操作
2. 首先会尝试获取锁，如果获取失败，则利用 `scanAndLockForPut()` 自旋获取锁
3. 如果重试的次数达到了 `MAX_SCAN_RETRIES` 则改为阻塞锁获取，保证能获取成功





### JDK 1.8 ConcurrentHashMap 的 put 方法 [来源](https://www.cnblogs.com/cosen/p/14329331.html) 

1. 根据 key 计算出 hash 值
2. 判断是否需要进行初始化
3. 定位到 Node，拿到首节点 f，判断首节点 f：
   - 如果为 null ，则通过 CAS 的方式尝试添加
   - 如果为 `f.hash = MOVED = -1` ，说明其他线程在扩容，参与一起扩容
   - 如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入
4. 当在链表长度达到 8 的时候，数组扩容或者将链表转换为红黑树



### JDK 1.8 ConcurrentHashMap 的 initTable 方法





### JDK1.8 中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock

1. 在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁一步步转换
2. 减少内存开销 ，使用ReentrantLock，那么每个节点都需要通过继承 AQS 来获得同步支持，但并不是每个节点都需要获得同步支持的，只有链表的头节点或红黑树的根节点需要同步，这无疑带来了巨大内存浪费



### ConcurrentHashMap 的 get 方法是否要加锁

get 方法不需要加锁。因为 Node 的元素 value 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改节点的 value 或者新增节点的时候是对线程B可见的

这也是它比其他并发集合比如 Hashtable、Collections.synchronizedMap()包装的 HashMap 效率高的原因之一 



### get 方法不需要加锁与 volatile 修饰的哈希桶数组有关吗

没有关系，哈希桶数组`table`用 volatile 修饰主要是保证在数组扩容的时候保证可见性



### JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别

1. 数据结构：取消了 Segment 分段锁的数据结构，取而代之的是数组+链表+红黑树的结构
2. 保证线程安全机制：JDK1.7 采用 Segment 的分段锁机制实现线程安全，其中 Segment 继承自 ReentrantLock ，JDK1.8 采用`CAS+synchronized`保证线程安全
3. 锁的粒度：JDK1.7 是对需要进行数据操作的 Segment 加锁，JDK1.8 调整为对每个数组元素加锁（Node）
4. 链表转化为红黑树：定位节点的 hash 算法简化会带来弊端，hash 冲突加剧，因此在链表节点数量大于 8（且数据总量大于等于 64）时，会将链表转化为红黑树进行存储
5. 查询时间复杂度：从 JDK1.7的遍历链表O(n)， JDK1.8 变成遍历红黑树O(logN)



### ConcurrentHashMap 和 Hashtable 的效率哪个更高

ConcurrentHashMap 的效率要高于 Hashtable，因为 Hashtable 给整个哈希表加了一把大锁从而实现线程安全。而ConcurrentHashMap 的锁粒度更低，在 JDK1.7 中采用分段锁实现线程安全，在 JDK1.8 中采用`CAS+synchronized`实现线程安全











## 并发编程

### 进程和线程的区别

- 进程是操作系统分配资源和调度的基本单位，新建，销毁以及切换进程都需要消耗大量的时间和空间
- 线程是比进程更小的可执行的单位，比进程开销小



### 为什么要有线程，而不是仅仅用进程



### 创建线程的方式

继承`Thread`类、实现`Runnable`接口、使用`Callable和Future`创建线程、使用线程池例如用Executor框架

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    FutureTask<String> task = new FutureTask<>(() -> "Hello");
    new Thread(task, "ThreadName").start();
    System.out.println(task.get());
}
```



### 线程的状态

1. NEW 新建

2. Runnable 可运行

3. Blocked 锁阻塞：竞争锁失败

4. Waiting 无限等待：调用了以下等待方法会进入无线等待，直到调用唤醒方法并获得CPU可变为Runnable

   | 等待方法              | 唤醒方法                                       |
   | --------------------- | ---------------------------------------------- |
   | `obj.wait()`          | `obj.notify(), obj.notifyAll(), t.interrupt()` |
   | `t.join()`            | `t.interrupt()`                                |
   | `LockSupport.park() ` | `LockSupport.unpark(目标线程), t.interrupt() ` |

   

5. TimedWaiting 计时等待：调用了以下等待方法会进入计时等待，直到线程等待时间超过了 n 毫秒或调用唤醒方法并获得CPU可变为Runnable

   | 等待方法                                                     | 唤醒方法                                                     |
   | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | `Thread.sleep(long n)`                                       | 等待时间超过了 n 毫秒                                        |
   | 线程用 `synchronized(obj)` 获取了对象锁后，调用 `obj.wait(long n)` | 等待时间超过了 n 毫秒或调用 `obj.notify(), obj.notifyAll(),  t.interrupt()` |
   | `t.join(long n)`                                             | 等待时间超过了 n 毫秒或调用`t.interrupt()`                   |
   | `LockSupport.parkNanos(long nanos),  LockSupport.parkUntil(long millis)` | 等待时间超过了 n 毫秒或调用`LockSupport.unpark(目标线程), t.interrupt() ` |

   

6. Teminated 被终止：当前线程所有代码运行完毕



![](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufQgw4O7chibY66JoPJQHU7gCnUic0BY9MkTvhc5no97PcPnkb1H6eIgGtcrbUtNStYO833icrpp496g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### run/start方法区别





### 17.如何停止一个正在运行的线程

停止一个线程可以用`Thread.stop()`方法，但最好不要用，虽然它可以停止一个正在运行的线程，但这个方法是不安全的，而且已被废弃，在java中有以下3种方法可以终止正在运行的线程：

1. 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止
2. 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法
3. 使用interrupt方法中断线程



1. interrupt()方法的使用效果并不像for+break语句那样，马上停止循环，调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程

2. Thread类中提供了两个方法来判断线程是否停止状态：`this.interrupted()`：测试当前线程是否已经中断；`this.isInterrupted()`：测试线程是否已经中断，两个方法的区别：

   

   `this.interrupted()`：测试当前线程是否已经中断，当前线程是指运行this.interrupted()这行代码的线程，以下例子是在Main方法种调用的，Main方法没有被中断过，所以两次输出都是false

   ```java
   public class MyThread extends Thread {
       public void run(){
           super.run();
           for(int i=0; i<500000; i++){
               i++;
           }
       }
   }
   
   public class Run {
       public static void main(String args[]){
           Thread thread = new MyThread();
           thread.start();
           try {
               Thread.sleep(2000);
               thread.interrupt();
   
               System.out.println("Is thread Stop? " + thread.interrupted());
               System.out.println("Is thread Stop? " + thread.interrupted());
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   }
   ```

   输出结果：

   ```
   Is thread Stop? false
   Is thread Stop? false
   ```

   

   `Thread.currentThread().interrupt()` 可使main线程产生中断效果，Thread.interrupted() 会清除打断标记，所以第一次调用为true，再次调用时输出false：

   ```java
   public class Run {
       public static void main(String args[]){
           Thread.currentThread().interrupt();
           System.out.println("Is thread Stop? " + Thread.interrupted());
           System.out.println("Is thread Stop?" + Thread.interrupted());
       }
   }    
   
   // 输出
   Is thread Stop? true
   Is thread Stop? false
   ```

   

   `isInterrupted()` 不会清除打断标记：

   ```java
   public class Run {
       public static void main(String args[]){
           Thread thread = new MyThread();
           thread.start();
           thread.interrupt();
           System.out.println("Is thread Stop? " + thread.isInterrupted());
           System.out.println("Is thread Stop? " + thread.isInterrupted());
       }
   }
   
   // 输出
   Is thread Stop? true
   Is thread Stop? true
   ```

   

3. 所以可以利用 `interrupted()`来停止线程：

   ```java
   public class MyThread extends Thread {
       public void run(){
           super.run();
           for(int i=0; i<500000; i++){
               // 判断是否被打断
               if(this.interrupted()) {
                   System.out.println("线程已经终止， for循环不再执行");
                   break;
               }
               // System.out.println("i="+(i+1));
           }
           
           System.out.println("这是for循环外面的语句，也会被执行");
       }
   }
   
   public class Run {
       public static void main(String args[]){
           Thread thread = new MyThread();
           thread.start();
           try {
               Thread.sleep(2000);
               // 打断线程
               thread.interrupt();
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   }
   
   // 输出
   // 线程已经终止， for循环不再执行
   // 这是for循环外面的语句，也会被执行
   ```

   

   虽然停止了线程，但如果for语句下面还有语句，还是会继续运行，若不想让线程继续往下执行，可将 `break` 替换成 ` throw new InterruptedException();` 直接抛异常代码就不会往下执行





### 18.线程间如何通信

synchronized、wait/notify、join



### Wait / Sleep / Yield方法的区别

三个方法都可以用来暂停线程，区别：

1. wait 是 Object 中的方法，而sleep/yield是Thread中的方法
2. 调用 wait 时会释放锁并让出cpu，而调用sleep/yield不会释放锁，只让出cpu
3. 调用 wait 之后，别的线程调用该 Object 的 notify/notifyAll 之后，才有机会获得cpu和锁，而sleep/yield再次获得cpu之后就可以继续运行
4. 调用sleep之后会被阻塞挂起指定的时间，线程调度器不会去调度该线程，而yield则是让出剩余时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器很有可能会调度执行该线程







### 同步方法和同步代码块的区别

1. 同步方法默认用this或者当前类class对象作为锁；
2. 同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法



### 在监视器(Monitor)内部，是如何做线程同步的

监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码

java 提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案



### 死锁

相互竞争不可抢占的资源就会导致死锁



### 如何确保N个线程可以访问N个资源同时又不导致死锁

多线程产生死锁的四个必要条件，只要破坏其中任意一个条件，就可以避免死锁：

1. 互斥条件：一个资源每次只能被一个进程使用
2. 保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
3. 不可剥夺性：进程已获得资源，在未使用完成前，不能被剥夺
4. 循环等待条件（闭环）：若干进程之间形成一种头尾相接的循环等待资源关系



### 如何避免死锁

1. 指定获取锁的顺序，并强制线程按照指定的顺序获取锁，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了
2. 超时锁，先指定时间获取锁，若获取不到则释放所有已经获取到的锁



### 同步方法和同步代码块的区别

1. 同步方法默认用this或者当前类class对象作为锁；
2. 同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法



### 在监视器(Monitor)内部，是如何做线程同步的

监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码

java 提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案



### 死锁

相互竞争不可抢占的资源就会导致死锁



### 如何确保N个线程可以访问N个资源同时又不导致死锁

多线程产生死锁的四个必要条件，只要破坏其中任意一个条件，就可以避免死锁：

1. 互斥条件：一个资源每次只能被一个进程使用
2. 保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
3. 不可剥夺性：进程已获得资源，在未使用完成前，不能被剥夺
4. 循环等待条件（闭环）：若干进程之间形成一种头尾相接的循环等待资源关系





### 9.如何避免死锁

1. 指定获取锁的顺序，并强制线程按照指定的顺序获取锁，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了
2. 超时锁，先指定时间获取锁，若获取不到则释放所有已经获取到的锁







### 如何控制某个方法允许并发访问线程的个数

1. `Semaphore`类可以用来限制同时执行某个代码块的线程数，通过调用acquire()方法来获取一个许可，如果没有许可可用，则该方法将阻塞直到有许可可用。在代码块执行完毕后，必须调用release()方法来释放许可
2. 线程池



### 多线程使用场景

多线程是一种并发编程技术，它允许程序同时执行多个线程，以便在并发任务时提高程序的效率：

1. 网络应用/数据库程序：网络应用程序通常需要与多个客户端同时通信，而多线程可以允许服务器同时处理多个连接，从而提高服务器的吞吐量和响应速度
2. 并行计算：并行计算通常需要同时执行多个计算任务，使用多线程可以将计算任务分配到不同的线程中，以提高计算速度



### 在Java中wait和sleep方法的不同

- Wait 在 object 中，sleep 在 thread 中
- wait 会释放锁，sleep不会
- wait需要调用notify/notifyAll，sleep 自动唤醒



### 谈谈wait/notify关键字的理解



### 什么导致线程阻塞

- Thread.sleep(int n)

- 锁

- IO/远程通信

  

### 线程如何关闭

- thread.interrupt

- this.interrupted

  

### 讲一下java中的同步的方法



### 数据一致性如何保证



### 保证线程安全



### 如何实现线程同步



### 如何使得共享变量变得线程安全

1. 方法内定义局部变量
2. 加锁
3. ThreadLocal



### 两个进程同时要求写或者读，能不能实现，如何防止进程的同步



### 线程间操作List





### 死锁的四个必要条件，怎么避免死锁

- 互斥条件
- 请求和保持
- 不可剥夺
- 请求爆出



### 类锁和对象锁的区别

1. 如果多线程同时访问同一类的 类锁（synchronized 修饰的静态方法）以及对象锁（synchronized 修饰的非静态方法）这两个方法执行是异步的，原因：类锁和对象锁是两种不同的锁
2. 类锁对该类的所有对象都能起作用，而对象锁不能



### 对象锁和类锁是否会互相影响

对象锁和类锁是两个不同的锁，它们不会相互影响。对象锁的锁对象是某个具体的实例对象，不同的实例对象之间不会存在锁竞争问题；而类锁的锁对象是该类的Class对象，因此类锁是对类的所有对象实例起作用的，不同的实例对象之间也会存在锁竞争问题。因此，在使用对象锁和类锁时应根据具体情况选择合适的锁类型，以避免可能的竞争问题。





### 42.进程和线程的区别

1. 进程是一段执行中的程序，是系统进行资源分配和调度的基本单位，因为进程的创建、销毁、切换产生大量的时间和空间开销，进程的数量不能太多，而线程是比进程更小的能独立运行的基本单位
2. 一个进程包含多个线程，线程的开销比进程的少







### 43.synchronized 原理

synchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为监视器锁，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现，作用主要就是实现原子性操作和解决共享变量的内存可见性问题：

1. 执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1，此时其他竞争锁的线程则会进入等待队列中
2. 执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁



如果再深入到源码来说，synchronized实际上有两个队列`waitSet`和`entryList`：

1. 当多个线程进入同步代码块时，首先进入entryList
2. 有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1
3. 如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁
4. 如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null



#### 锁膨胀

偏向锁：在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁，如果一个线程获得了锁，那么锁就进入偏向模式，此时`Mark Word`的结构也就变为偏向锁结构，**当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查**`Mark Word`**的锁标记位为偏向锁以及当前线程ID等于**`Mark Word`**的ThreadID即可**，这样就省去了大量有关锁申请的操作

轻量级锁：由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁，这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块

自旋锁：大多数情况下共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU，得到锁，就顺利进入临界区，否则一直循环获取锁，若锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销

重量级锁：当**同一时间**有多个线程竞争锁时，锁就会被升级成重量级锁



#### 锁消除

```java
public void test() {
    Object obj = new Object();
    synchronized (obj) {
        System.out.println("allen");
    }
}

// jit 编译后优化为以下代码
public void test() {
    Object obj = new Object();
    System.out.println("allen");
}
```



#### 锁粗化

通过扩大锁的范围，避免反复加锁解锁

```java
public void test() {
    for (int i = 0; i < 1000; i++) {
        synchronized (this) {
            System.out.println("allen");
        }
    }
}

// 锁粗化
public void test() {
    synchronized (this) {
        for (int i = 0; i < 1000; i++) {
            System.out.println("allen");
        }
    }
}
```







### 45.CAS 原理及缺点

原理：通过处理器的指令 保证操作的原子性，V为内存值，A旧的预期值，B新值，只有当V=A时才会用B去更新V

缺点：

1. ABA问题：Javay用`AtomicStampedReference`来解决这个问题，加入了版本号(加入了预期标志和更新后标志两个字段)，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新
2. 循环时间长开销大：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销
3. 只能保证一个共享变量的原子操作：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现



### 45.ThreadLocal

在多线程并发访问同一个共享变量时，如果不做同步控制就可能会导致数据不一致的问题，所以需要加锁来解决这个问题，而Thread Local则是以空间换时间的方式来处理多线程的情况

Thread Local本身不存储数据，他使用的是线程中的threadLocals属性，这个数据的类型是一个在Thread Local 中定义的Thread LocalMap，当调用ThreadLocal的set方法时Thread Local会将自身引用作为key，值作为value存到线程的threadLocals中，也就是说每个线程的操作都是基于线程本身的一个私有副本，线程之间的数据相互隔离也就解决了线程安全的问题



ThreadLocalMap 中维护了一个Entry数组，名称为table，用来存储数据：

```java
static class ThreadLocalMap {
  // ...
  static class Entry extends WeakReference<ThreadLocal<?>> {
    Object value;
    
    Entry(ThreadLocal<?> k, Object v) {
      super(k);
      value = v;
    }
  }
  // ...
  private Entry[] table;
  // ...
}
```



因为Entry中的key为弱引用，因此在GC时，key就会被回收，而value为强引用，但key为null，永远无法通过key访问到value却又不能被回收，因此发生了内存泄漏

所以ThreadLocalMap中的Entry对象不在使用了之后，如果没有被及时清理，而程序本身也无法通过GC将其回收的话就会发生内存泄露



ThreadLocalMap属于线程，若线程生命周期短，当线程销毁时value也会随之回收，但一般用的线程池，线程生命周期较长



### 45.如何避免Thread Local内存泄漏

1. 每次使用完之后都掉用remove清除数据
2. 将threadlocal定义为 static fianl ，避免频繁创建thread local实例，保证程序中存在threadlocal的强引用





### synchronized 锁升级的过程

无锁，偏向锁，轻量级锁，重量级锁



### 谈谈对Synchronized关键字，类锁，方法锁，重入锁





### static synchronized 方法的多线程访问和作用



### 同一个类里面两个synchronized方法，两个线程同时访问的问题





### volatile的原理

volatile 是轻量级的锁，它不会引起线程上下文的切换和调度:

1. volatile可见性：对一个volatile 的读，总可以看到对这个变量最终的写
2. volatile 原子性：volatile对单个读 / 写具有原子性（32 位 Long、Double），但是复合操作除外，例如i++ 
3. JVM 底层采用“内存屏障”来实现 volatile 语义，防止指令重排序
4. volatile 经常用于两个两个场景：状态标记变量、Double Check



### volatile关键字的用法/作用





### 内存屏障





### synchronized 和volatile 的区别



### synchronized与Lock的区别





### ReentrantLock 原理，和 synchronized 的区别

ReentrantLock基于AQS(抽象队列同步器)实现：AQS内部维护一个state状态位，尝试加锁的时候通过CAS(CompareAndSwap)修改值，如果成功设置为1，并且把当前线程ID赋值，则代表加锁成功，一旦获取到锁，其他的线程将会被阻塞进入阻塞队列自旋，获得锁的线程释放锁的时候将会唤醒阻塞队列中的线程，释放锁的时候则会把state重新置为0，同时当前线程ID置为空

区别：

1. 显示获取释放锁，公平非公平，尝试获取锁，condition多条件
2. 等待可中断，当持有锁的线程长时间不释放锁的时候，等待中的线程可以选择放弃等待，转而处理其他的任务







### ReentrantLock

ReentrantLock，可重入锁，是一种递归无阻塞的同步机制。它可以等同于 synchronized的使用，但是 ReentrantLock 提供了比synchronized 更强大、灵活的锁机制，可以减少死锁发生的概率：

1. ReentrantLock 实现 Lock 接口，基于内部的 Sync 实现
2. Sync 实现 AQS ，提供了 FairSync 和 NonFairSync 两种实现

##### Condition

Condition 和 Lock 一起使用以实现等待/通知模式，通过 `await()`和`singnal()` 来阻塞和唤醒线程。



Condition 是一种广义上的条件队列。他为线程提供了一种更为灵活的等待 / 通知模式，线程在调用 await 方法后执行挂起操作，直到线程等待的某个条件为真时才会被唤醒。Condition 必须要配合 Lock 一起使用，因为对共享状态变量的访问发生在多线程环境下。一个 Condition 的实例必须与一个 Lock 绑定，因此 Condition 一般都是作为 Lock 的内部实现





### ReentrantLock 、synchronized和volatile比较







### 28.ReentrantReadWriteLock

读写锁维护着一对锁，一个读锁和一个写锁。通过分离读锁和写锁，使得并发性比一般的排他锁有了较大的提升：

1. 在同一时间，可以允许多个读线程同时访问
2. 但是，在写线程访问时，所有读线程和写线程都会被阻塞







### 29.Synchronized 和 Lock 的区别

1. Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；
2. synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock() 去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；
3. Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，- 等待的线程会一直等待下去，不能够响应中断；
4. 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。
5. Lock 可以提高多个线程进行读操作的效率

更深的：

1. 与 synchronized 相比，ReentrantLock 提供了更多，更加全面的功能，具备更强的扩展性。例如：时间锁等候，可中断锁等候，锁投票。
2. ReentrantLock 还提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活，所以在多个条件变量和高度竞争锁的地方，ReentrantLock 更加适合（以后会阐述 Condition）。
3. ReentrantLock 提供了可轮询的锁请求。它会尝试着去获取锁，如果成功则继续，否则可以等到下次运行时处理，而 synchronized则一旦进入锁请求要么成功要么阻塞，所以相比synchronized 而言，ReentrantLock 会不容易产生死锁些。
4. ReentrantLock 支持更加灵活的同步代码块，但是使用 synchronized时，只能在同一个synchronized块结构中获取和释放。注意，ReentrantLock 的锁释放一定要在finally 中处理，否则可能会产生严重的后果。
5. ReentrantLock 支持中断处理，且性能较 synchronized 会好些





### 30.Java 中线程同步的方式

1. sychronized 同步方法或代码块
2. volatile
3. Lock
4. ThreadLocal
5. 阻塞队列（LinkedBlockingQueue）
6. 使用原子变量（java.util.concurrent.atomic）
7. 变量的不可变性









### ReentrantLock的内部实现

### lock原理





### AQS

AQS 是用来构建锁和同步器的基础框架，如 `ReentrantLock、ReentrantReadWriteLock、Semaphore` 等, 包含了实现同步器的细节，即获取同步状态、FIFO 同步队列。AQS 的主要使用方式是继承，子类通过继承同步器，并实现它的抽象方法来管理同步状态

维护一个同步状态 state。当 state > 0时，表示已经获取了锁；当state = 0 时，表示释放了锁

AQS 通过内置的 FIFO 同步队列来完成资源获取线程的排队工作：

1. 如果当前线程获取同步状态失败（锁）时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程
2. 当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态
3. AQS 内部维护的是CLH 双向同步队列

相关文章参考： [AbstractQueuedSynchronizer源码分析之条件队列](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485273&idx=2&sn=f0741b315ba14562317bc3c6fa91b2ae&chksm=ebd63875dca1b163d0338e97a11f8bccee07226890640826d7b0ec822c1e7eaf365f92db15fb&scene=21#wechat_redirect) 

调用signal方法可能唤醒线程也可能不会唤醒线程，但是调用signal方法一定会将线程从条件队列中移到同步队列尾部



![image-20230316113919383.png](https://s2.loli.net/2023/03/16/EQoVNbBF6y2as5H.png)

### AQS 的底层原理

AQS是AbstractQueuedSynchronizer的缩写，用来构建锁和同步器。AQS主要是通过内部维护一个双向链表来实现同步的。下面是AQS的底层原理的简要介绍：

1. 状态变量：AQS内部维护一个int类型的状态变量，用来表示当前同步状态。对于不同的同步操作，状态变量的值有不同的意义。
2. 内部队列：AQS内部维护一个双向链表，用来存储等待获取锁的线程。当线程尝试获取锁时，如果锁已经被其他线程占用，则该线程会被加入到内部队列中，并进入等待状态。
3. CAS操作：AQS使用CAS（Compare and Swap）操作来更新状态变量的值。CAS操作是一种原子操作，可以保证多个线程同时修改同一个变量时的线程安全性。
4. 独占锁：AQS的独占锁是一种排他锁，同一时刻只能有一个线程持有锁。在AQS中，独占锁是通过状态变量来实现的。当一个线程尝试获取独占锁时，如果锁已经被其他线程占用，则该线程会被加入到内部队列中，并进入等待状态。
5. 共享锁：AQS的共享锁是一种共享的读锁，可以允许多个线程同时访问共享资源。在AQS中，共享锁也是通过状态变量来实现的。当一个线程尝试获取共享锁时，如果锁已经被其他线程占用，则该线程会被加入到内部队列中，并进入等待状态。当其他线程释放共享锁时，AQS会通知所有等待获取共享锁的线程，让它们重新尝试获取锁。
6. Condition对象：AQS还提供了Condition对象，用来实现线程间的等待/通知机制。Condition对象本质上是一个等待队列，当一个线程调用Condition对象的await()方法时，该线程会被加入到等待队列中，并释放当前持有的锁。当其他线程调用Condition对象的signal()或者signalAll()方法时，等待队列中的线程会被唤醒，并尝试重新获取锁





### CountDownLatch/CyclicBarrier 区别

CountDownLatch 和 CyclicBarrier 都是 Java 多线程并发编程中用于线程协调的工具类。

CountDownLatch：是可以让一个或多个线程等待另外一个或多个线程完成操作后再执行的工具类。CountDownLatch 的内部有一个计数器，可以设定一个初始值，在等待该计数器的线程数量减至 0 之前，调用 CountDownLatch 的 await() 方法的线程都必须等待。

CyclicBarrier：也是让多个线程等待彼此达到一定状态后再继续执行的工具类，但是它具有“可循环使用”的特点。在 CyclicBarrier 中，可以设定一个状态，当达到该状态时，所有等待的线程都会被释放，并可进行可选的操作。

它们的主要区别如下：

1. CountDownLatch 只能够使用一次，调用 countDown() 方法计数器减 1，当计数器归零后，所有等待线程会被唤醒执行，不能够复用。而 CyclicBarrier 可以反复使用。

2. CountDownLatch 只能等待异步操作执行完毕，而 CyclicBarrier 可以等待多个线程都到达同一个状态之后再执行下一步。

3. CountDownLatch 是通过计数器实现的，而 CyclicBarrier 是通过屏障机制实现的。

在使用 CountDownLatch 和 CyclicBarrier 时，需要注意线程安全问题和执行顺序等问题。







### 悲观锁/乐观锁

悲观锁和乐观锁是并发编程中两种不同的锁机制，用于解决并发访问共享资源时可能出现的数据竞争问题：

1. 悲观锁： 在操作共享资源之前，先获取锁，并且假定其他线程也会竞争这个锁，因此会对共享资源的读写进行保护。适用于对共享资源访问频繁，且冲突概率较高的情况。悲观锁的代表就是Java中的synchronized关键字和ReentrantLock类。
2. 乐观锁： 在操作共享资源之前，不加锁，而是假定其他线程不会竞争这个资源，因此直接进行操作，然后检查操作期间是否有其他线程修改了该资源。如果没有，则操作成功，否则进行重试或者回滚操作。乐观锁适用于对共享资源访问不频繁，且冲突概率较低的情况。乐观锁的代表是Java中的CAS（Compare And Swap）机制，即比较并交换





### ThreadLocal



### JDK 中的并发类知道哪些





### 什么是线程池，为什么要使用线程池

线程复用

1. 过于频繁的创建/销毁线程，会很大程度上影响处理效率，线程池缓存线程，可用已有的闲置线程来执行新任务(keepAliveTime)
2. 运用线程池能有效的控制线程最大并发数，可避免线程并发数量过多，抢占系统资源从而导致阻塞
3. 对线程进行一些简单的管理(延时执行、定时循环执行的策略等)





### ThreadPoolExecutor 的5中运行状态

| 状态       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| RUNNING    | 能接受新任务，也能处理队列中任务                             |
| SHUTDOWN   | 不在接受新提交的任务，但能处理队列中的任务                   |
| STOP       | 不在接受新提交的任务，也不处理队列中的任务，并且中断正在处理任务的线程 |
| TIDYING    | 所有任务已经终止，线程数量为0                                |
| TERMINATED | 终止状态                                                     |

![](https://p0.meituan.net/travelcube/582d1606d57ff99aa0e5f8fc59c7819329028.png)







### 22.JAVA 常见的几种线程池



#### ThreadPoolExecutor



##### 阻塞队列

阻塞队列实现了 BlockingQueue 接口，并且有多组处理方法

1. 抛出异常：add(e) 、remove()、element()
2. 返回特殊值：offer(e) 、pool()、peek()
3. 阻塞：put(e) 、take()



JDK 8 中提供了七个阻塞队列可供使用：

1. ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列，采用 FIFO 的原则对元素进行排序添加的。内部使用可重入锁 ReentrantLock + Condition 来完成多线程环境的并发操作
2. LinkedBlockingQueue ：一个由链表结构组成的无界阻塞队列
3. PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列
4. DelayQueue：一个使用优先级队列实现的无界阻塞队列
5. SynchronousQueue：一个不存储元素的阻塞队列
6. LinkedTransferQueue：一个由链表结构组成的无界阻塞队列
7. LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列

相关文章参考 ：[阻塞队列 BlockingQueue](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487078&idx=2&sn=315f39b6d53862dcb732390729951628&chksm=ebd6314adca1b85c33db1134fbe98bf7526943b02dfc23021781abff265bb231ad9bcd3e1ad1&scene=21#wechat_redirect) [Java并发编程：阻塞队列](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485221&idx=1&sn=056f233e5d1579da75fb3c1ffe6b9a53&chksm=ebd63809dca1b11f801ce66a30dcddc23645e4352ada849066687d4107903d92bdd8ac70bef9&scene=21#wechat_redirect) 



##### 四种拒绝策略

1. AbortPolicy：直接抛出异常，默认策略
2. CallerRunsPolicy：用调用者所在的线程来执行任务
3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务
4. DiscardPolicy：直接丢弃任务
5. 实现 RejectedExecutionHandler 接口，自定义拒绝策略



当添加新的任务到线程池时：

1. 线程数量未达到 corePoolSize，则新建一个线程（核心线程）执行任务
2. 线程数量达到了 corePoolSize，则将任务移入队列等待
3. 队列已满，新建线程（非核心线程）执行任务
4. 队列已满，总线程数又达到了 maximumPoolSize，就会由 handler 的拒绝策略来处理





#### FixedThreadPool

有固定数量线程的线程池，其`corePoolSize=maximumPoolSize`，且keepAliveTime为0，适合线程稳定的场所：

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
   return new ThreadPoolExecutor(nThreads, nThreads,
                                 0L, TimeUnit.MILLISECONDS,
                                 new LinkedBlockingQueue<Runnable>());
}
```



1. FixedThreadPool 使用了无界的 LinkedBlockingQueue, 当任务数量超过 corePoolSize 后，全都会添加到队列中
2. 当线程池满时且阻塞队列也已经满时，如果继续提交任务线程池不会再新建线程，会直接走拒绝策略，FixedThreadPool 使用的是默认的拒绝策略，即 `AbortPolicy`，直接抛出异常





#### SingleThreadExecutor

从数学的角度来看SingleThreadPool应该属于FixedThreadPool的子集。其`corePoolSize=maximumPoolSize=1`,且keepAliveTime为0，适合线程同步操作的场所

```java
public static ExecutorService newSingleThreadExecutor() {
   return new FinalizableDelegatedExecutorService
       (new ThreadPoolExecutor(1, 1,
                               0L, TimeUnit.MILLISECONDS,
                               new LinkedBlockingQueue<Runnable>()));
}
```





#### CachedThreadPool

既然要储存，其容量肯定是很大，所以他的corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE

```java
public static ExecutorService newCachedThreadPool() {
   return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                 60L, TimeUnit.SECONDS,
                                 new SynchronousQueue<Runnable>());
}
```



这个线程池，当任务提交是就会创建线程去执行,执行完成后线程会空闲60s,之后就会销毁。但是如果主线程提交任务的速度远远大于 CachedThreadPool 的处理速度，则 CachedThreadPool 会不断地创建新线程来执行任务，这样有可能会导致系统耗尽 CPU 和内存资源



#### ScheduleThreadPool

ScheduledThreadPool是一个具有定时定期执行任务功能的线程池



关文章参考：[JAVA线程池原理详解（1）](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247484686&idx=1&sn=b4f63e08a018ff7fadc4ecfb9352e439&chksm=ebd63a22dca1b334cc9ae79df71095cfbc6880e671aaa8addd273aa842801ebfaf4d9f95e714&scene=21#wechat_redirect) [JAVA线程池原理详解（2）](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247484699&idx=2&sn=b0e359218437e3eb6223b9acb8cdca68&chksm=ebd63a37dca1b321740fee80579779b6d34cf1997878a896f3a47127a2670afbd2af4f15127d&scene=21#wechat_redirect) [Java多线程和线程池](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247484840&idx=2&sn=6fa3a468ba36e86ab2c73b6c289dd708&chksm=ebd63a84dca1b392ed1674be76df99bcdd1ffb5dcc8245613d24b7cf277db663f3b40fd3fae2&scene=21#wechat_redirect) [Java线程池总结](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486337&idx=2&sn=5abbb5bf79607d437c637c8a968475c8&chksm=ebd634addca1bdbb62788e44feb9ff5692d9809eaeab4af07fa427cd349978d58e5be5ee9133&scene=21#wechat_redirect) 









### 线程池原理

https://juejin.cn/post/6983213662383112206/#heading-9







### 线程池中多余的线程如何回收

工作线程启动后，就进入`runWorker(Worker w)`方法，里面是一个while循环，循环判断任务是否为空，若不为空，执行任务；若取不到任务，或发生异常，退出循环，执行`processWorkerExit(w, completedAbruptly); `在这个方法里把工作线程移除掉



一条线程`getTask()`返回`null`，就会被回收，有一下两种情况会返回空：

1. 线程池的状态是SHUTDOWN且状态是STOP或者队列为空

   ```java
   if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
       decrementWorkerCount();
       return null;
   }
   ```

   

2. 工作线程数已经大于最大线程数或当前工作线程已超时，且，还有其他工作线程或任务队列为空

   ```java
   if ((wc > maximumPoolSize || (timed && timedOut))
           && (wc > 1 || workQueue.isEmpty())) {
       if (compareAndDecrementWorkerCount(c))
            return null;
       continue;
   }
   ```

   ![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2308365b1e7846c29d3410a105723a7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)





### 线程池使用的是哪种



### 线程池参数怎么配置



### 线程池各个参数的作用



### 线程池的参数配置要注意什么







### Java的并发、多线程、线程模型



### 谈谈对多线程的理解



### 多线程有什么要注意的问题



### 谈谈你对并发编程的理解并举例说明



### 谈谈你对多线程同步机制的理解



### 如何保证多线程读写文件的安全



### 多线程断点续传原理



### 断点续传的实现







### 线程池的几个重要参数，为什么要用线程池，线程池是怎么复用线程的

- 在线程池中，线程会从 workQueue 中读取任务来执行，最小的执行单位就是 Worker，Worker 实现了 Runnable 接口，重写了 run 方法，这个 run 方法是让每个线程去执行一个循环，在这个循环代码中，去判断是否有任务待执行，若有则直接去执行这个任务，因此线程数不会增加

- `java.util.concurrent.ThreadPoolExecutor#execute` 

```java
  public void execute(Runnable command) {
      // 如果传入的Runnable的空，就抛出异常
      if (command == null)
          throw new NullPointerException();
      int c = ctl.get();
      // 线程池中的线程比核心线程数少
      if (workerCountOf(c) < corePoolSize) {
          // 新建一个核心线程执行任务
          if (addWorker(command, true))
              return;
          c = ctl.get();
      }
      // 核心线程已满，但是任务队列未满，添加到队列中
      if (isRunning(c) && workQueue.offer(command)) {
          int recheck = ctl.get();
          // 任务成功添加到队列以后，再次检查是否需要添加新的线程，因为已存在的线程可能被销毁了
          if (! isRunning(recheck) && remove(command))
              // 如果线程池处于非运行状态，并且把当前的任务从任务队列中移除成功，则拒绝该任务
              reject(command);
          else if (workerCountOf(recheck) == 0)
              // 如果之前的线程已经被销毁完，新建一个非核心线程
              addWorker(null, false);
      }
      // 核心线程池已满，队列已满，尝试创建一个非核心新的线程
      else if (!addWorker(command, false))
          // 如果创建新线程失败，说明线程池关闭或者线程池满了，拒绝任务
          reject(command);
  }
```



`java.util.concurrent.ThreadPoolExecutor#runWorker` 

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // 释放锁 设置work的state=0 允许中断
    boolean completedAbruptly = true;
    try {
        //一直执行 如果task不为空 或者 从队列中获取的task不为空
        while (task != null || (task = getTask()) != null) {
                task.run();//执行task中的run方法
            }
        }
        completedAbruptly = false;
    } finally {
        //1.将 worker 从数组 workers 里删除掉
        //2.根据布尔值 allowCoreThreadTimeOut 来决定是否补充新的 Worker 进数组 workers
        processWorkerExit(w, completedAbruptly);
    }
}
```





## JVM



### 运行时数据区



### Java 内存模型JMM 

JMM 是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的

JMM用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量



### 如何判断一个对象是否存活/GC对象的判定方法

判断对象是否存活的算法包括：

1. 引用计数算法

   给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是不能再被引用的

2. 可达性分析算法

   通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链Reference Chain，当一个对象到GC Root没有任何引用链相连时，则证明此对象是不可用的

3. 三色标记法



判断一个无用的类需要同时满足下面3个条件：

1. 该类的所有实例都已经被回收
2. 加载该类的ClassLoader已经被回收
3. 该类对应的java.lang.Class对象已经没有任何地方被引用，无法在任何地方通过反射访问该类的方法



### 服务器使用的什么垃圾收集器

### CMS 垃圾收集的原理

### G1 垃圾收集的特点，为什么低延迟

### 有哪些垃圾回收算法，优缺点

### 哪些对象可以作为 GC Roots

### 有哪些类加载器

### 双亲委派模式，哪些场景是打破双亲委派模式

### 线上服务器出现频繁 Full GC，怎么排查

### 定位问题常用哪些命令

### 介绍下 JVM 调优的过程



### 对象什么时候会从servivor区放放old区，jvm中哪些地方会发生oom

- 当对象首次创建时，会放在新生代的eden区, 若没有发生GC，会一直在eden区, GC后，可能进入survivor区或者年老代
- 当对象年龄达到一定的大小 ,就会离开年轻代， 进入老年代，`-XX:MaxTenuringThreshold=n`：在年轻代servivor经过n次GC后进入old区，-XX:TargetSurvivorRatio
- 若对象体积太大, 新生代无法容纳这个对象，也会进入old区，`-XX:PretenureSizeThreshold`：达到这个值的对象直接放入old区



### 何时发生full gc

- 调用System.gc()，可能会fullgc，可通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc

- 老年代空间不足

- 方法区/元空间 空间不足

  

### 方法区会gc吗，什么时候gc



### 各个版本的jdk内存结构的变化

- jdk1.6之前，堆，方法区，静态变量及字符串常量池都在方法区中

- jdk1.7，堆，方法区，静态变量及字符串常量池都在堆中

- Jdk1.8之后，堆，将方法区该为元空间，而且元空间不在jvm当中，被提到了本地内存中，静态变量及字符串常量池都在堆中

  

### 如果年轻代经常发生gc，会是什么原因，怎么解决

1. 内存分配过于频繁：如果程序经常在堆上创建和销毁对象，就会导致频繁的gc。这种情况下，可以考虑重用对象而不是创建和销毁，或者使用对象池等技术来减少内存分配。

2. 内存不足：如果内存不足，会导致gc更加频繁。这种情况下，可以考虑增加堆的大小，或者优化程序的内存使用。

3. 大对象：如果程序创建了大对象（比如超过了年轻代的容量），就可能导致频繁的gc。这种情况下，可以考虑调整年轻代和老年代的比例，或者优化程序的内存使用。

4. 缓存失效：如果程序使用了缓存，但是缓存失效太频繁，也会导致gc更加频繁。这种情况下，可以考虑优化缓存的使用，减少缓存失效的可能性。

针对以上问题，可以从以下几个方面来解决：

1. 减少内存分配：重用对象或使用对象池等技术来减少内存分配。

2. 增加堆的大小：通过增加堆的大小来减少gc的频率。

3. 调整年轻代和老年代的比例：根据程序的特点来调整年轻代和老年代的比例，减少大对象的出现。

4. 优化缓存的使用：通过合理地使用缓存来减少gc的频率。

5. 优化程序的内存使用：对程序进行优化，减少内存消耗。



### 项目上如果发生了oom如何定位问题

如果项目发生了 OutOfMemoryError（OOM），需要进行下面的步骤来定位问题：

1.查看日志。首先需要查看项目的日志，找到 OOM 异常相关的堆栈信息。

2.使用 JVM 工具。在出现 OOM 问题后，使用一些 JVM 工具进行诊断，例如 jmap、jstack、jstat、jvisualvm 等。

3.内存泄露检查。查看项目中是否存在内存泄露问题，例如未关闭的数据库连接等。

4.分析代码。如果在项目的代码中存在大量的对象创建和持有，需要对代码进行分析和优化。

5.调整 JVM 参数。根据项目的实际情况，调整 JVM 参数，例如堆内存大小、GC 策略等。

6.压力测试。进行压力测试，验证在高并发场景下，项目是否会出现 OOM 问题。

通过以上步骤的分析，可以找到 OOM 问题的根本原因，并进行相应的优化和调整，提高系统的稳定性和性能。





### 如何调整新老年代的空间，项目上是怎么设计的，你们生产的比例一般设为多少

调整新老年代的空间大小可以通过JVM的参数来实现，具体参数如下：

- -XX:NewSize：设置新生代初始大小
- -XX:MaxNewSize：设置新生代最大大小
- -XX:SurvivorRatio：设置Eden区与Survivor区的比例，默认为8:1，即Eden区占整个新生代的8/10，Survivor区占2/10

项目上如何设计可以参考以下几个方面：

- 系统中对象的生命周期长短：如果系统中的对象生命周期较短，那么应该增大新生代的比例，以便更快地回收对象，反之应该增大老年代的比例。
- 系统中的内存压力：如果系统中的内存压力较大，可以适当增大新生代的比例。
- 系统对垃圾回收时间的要求：如果对垃圾回收时间要求较高，可以适当增大新生代的比例，以减少垃圾回收的时间。

一般而言，生产环境中新生代和老年代的比例可以设置为1：2或1：3，具体根据应用的情况而定。





### 年轻代经常gc，可以调高年轻代的空间吗，这样做的优缺点是什么

可以调高年轻代的空间，优点是可以减少GC的频率和时间，提高应用程序性能和响应速度；缺点是可能会导致老年代的空间不足，从而导致更加频繁的Full GC和严重的性能问题。同时，调整年轻代的空间还需要考虑到应用程序的实际情况和内存需求，以避免浪费内存或导致内存不足等问题。



### 有没有用过什么gc工具



### g1垃圾回收器的回收流程

G1垃圾回收器的回收流程可以分为以下几个步骤：

1. 初始标记（Initial Mark）

在这个阶段，G1 GC会从根对象开始对活动对象进行标记，并记录下这些对象的引用关系。这个过程是通过扫描堆中的根对象和之前标记的卡片（Card）来完成的。这个过程需要停止所有应用程序线程。

2. 并发标记（Concurrent Mark）

在这个阶段，G1 GC会对堆中的未标记对象进行标记，并记录下这些对象的引用关系。这个过程是与应用程序并发执行的，并且不会停止应用程序线程。

3. 初始标记重标记（Remark）

在这个阶段，G1 GC会重新标记从并发标记开始时到现在发生变化的对象。这个过程需要停止所有应用程序线程。

4. 清理（Cleanup）

在这个阶段，G1 GC会清理掉所有未标记的对象，并进行内存整理。这个过程是与应用程序并发执行的，并且不会停止应用程序线程。

G1垃圾回收器通过分区（Partition）把整个堆划分成多个区域，每个区域都会被分配一个优先级。G1 GC会根据这些优先级来决定哪些区域需要被回收。在进行垃圾回收时，G1 GC会先回收优先级最高的区域，然后再逐步回收其他区域，以此来减少应用程序中断时间。







