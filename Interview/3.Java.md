### 1.内部类

1. 静态内部类：可以访问外部的静态资源，包括静态私有资源。但不能访问非静态资源，可以不依赖外部类实例而实例化

2. 成员内部类：可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类

3. 局部内部类： 局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰，局部内部类只能访问所在代码块或者方法中被定义为final的局部变量

4. 匿名内部类：没有类名的内部类，不能使用class，extends和implements，没有构造方法，不能定义静态资源，只能创建一个匿名内部类实例，一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口，匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效



### 2.Object类中的13个方法

| 方法                            | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| Object()                        | 构造方法                                                     |
| registerNatives()               |                                                              |
| `clone()`                       | 对象拷贝，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常 |
| `getClass()`                    | final方法，用于获得运行时的类型，方法返回的是此Object对象的类对象/运行时类对象Class，效果与`Object.class`相同 |
| `equals()`                      | 用来比较两个对象的内容是否相等                               |
| `hashCode()`                    | 返回其所在对象的物理地址（哈希码值），常会和`equals`方法同时重写，确保相等的两个对象拥有相等的hashCode |
| toString()                      |                                                              |
| `wait()`                        | 导致当前的线程等待，直到其他线程调用此对象的 `notify()` 方法或 `notifyAll()` 方法 |
| `wait(long timeout)`            | 导致当前的线程等待，直到其他线程调用此对象的 `notify()` 方法或 `notifyAll()` 方法，或者超过指定的时间量 |
| `wait(long timeout, int nanos)` |                                                              |
| `notify()`                      | 随机唤醒在此对象监视器上等待的某个线程                       |
| `notifyAll()`                   | 唤醒在此对象监视器上等待的所有线程                           |
| finalize()                      | 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法 |



### 3.hashCode() 和 equals() 之间的关系

关于这两个方法，必须遵循的规则：

1. 只要重写equals()，就必须重写hashCode()
   - 首先有两个对象相等，即equals返回true，则hashcode一定相同的结论
   - 如果只重写equals没有冲洗hashcode，那equals返回true，hashcode比较的还是两个对象的地址，显然和上面的结论相悖
   - 所以重写equals时就必须重写hashcode
   - 重写hashcode也是为了提高程序的效率，hashcode不同则没必要用equals比较

`hashCode()` 的作用是获取哈希码，也称为散列码，返回一个int整数，这个哈希码的作用是确定该对象在哈希表中的索引位置

重写equals的时候还要注意要满足自反性、对称性、传递性、一致性





### 4.创建线程的方式

继承`Thread`类、实现`Runnable`接口、使用`Callable和Future`创建线程、使用线程池例如用Executor框架

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    FutureTask<String> task = new FutureTask<>(() -> "Hello");
    new Thread(task, "ThreadName").start();
    System.out.println(task.get());
}
```



### 5.线程的状态

1. NEW 新建

2. Runnable 可运行

3. Blocked 锁阻塞：竞争锁失败

4. Waiting 无限等待：调用了以下等待方法会进入无线等待，直到调用唤醒方法并获得CPU可变为Runnable

   | 等待方法              | 唤醒方法                                       |
   | --------------------- | ---------------------------------------------- |
   | `obj.wait()`          | `obj.notify(), obj.notifyAll(), t.interrupt()` |
   | `t.join()`            | `t.interrupt()`                                |
   | `LockSupport.park() ` | `LockSupport.unpark(目标线程), t.interrupt() ` |

   

5. TimedWaiting 计时等待：调用了以下等待方法会进入计时等待，直到线程等待时间超过了 n 毫秒或调用唤醒方法并获得CPU可变为Runnable

   | 等待方法                                                     | 唤醒方法                                                     |
   | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | `Thread.sleep(long n)`                                       | 等待时间超过了 n 毫秒                                        |
   | 线程用 `synchronized(obj)` 获取了对象锁后，调用 `obj.wait(long n)` | 等待时间超过了 n 毫秒或调用 `obj.notify(), obj.notifyAll(),  t.interrupt()` |
   | `t.join(long n)`                                             | 等待时间超过了 n 毫秒或调用`t.interrupt()`                   |
   | `LockSupport.parkNanos(long nanos),  LockSupport.parkUntil(long millis)` | 等待时间超过了 n 毫秒或调用`LockSupport.unpark(目标线程), t.interrupt() ` |

   

6. Teminated 被终止：当前线程所有代码运行完毕



![](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufQgw4O7chibY66JoPJQHU7gCnUic0BY9MkTvhc5no97PcPnkb1H6eIgGtcrbUtNStYO833icrpp496g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





### 6.Wait / Sleep / Yield方法的区别

三个方法都可以用来暂停线程，区别：

1. wait 是 Object 中的方法，而sleep/yield是Thread中的方法
2. 调用 wait 时会释放锁并让出cpu，而调用sleep/yield不会释放锁，只让出cpu
3. 调用 wait 之后，别的线程调用该 Object 的 notify/notifyAll 之后，才有机会获得cpu和锁，而sleep/yield再次获得cpu之后就可以继续运行
4. 调用sleep之后会被阻塞挂起指定的时间，线程调度器不会去调度该线程，而yield则是让出剩余时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器很有可能会调度执行该线程



### 6.同步方法和同步代码块的区别

1. 同步方法默认用this或者当前类class对象作为锁；
2. 同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法



### <u>7.在监视器(Monitor)内部，是如何做线程同步的</u>

监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码

java 提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案



### 8.死锁

相互竞争不可抢占的资源就会导致死锁



### 9.如何确保N个线程可以访问N个资源同时又不导致死锁

多线程产生死锁的四个必要条件，只要破坏其中任意一个条件，就可以避免死锁：

1. 互斥条件：一个资源每次只能被一个进程使用
2. 保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
3. 不可剥夺性：进程已获得资源，在未使用完成前，不能被剥夺
4. 循环等待条件（闭环）：若干进程之间形成一种头尾相接的循环等待资源关系



一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了





### <u>10.Java序列化与反序列化</u>

Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：

1. 序列化：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。
2. 反序列化：客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象



### <u>11.序列化与反序列化的好处</u>

1. 对象序列化可以实现分布式对象
2. java对象序列化可以递归保存对象引用的每个对象的数据
3. 序列化可以将内存中的类写入文件或数据库中
4. 对象、文件、数据，有许多不同的格式，很难统一传输和保存，序列化以后就都是字节流了，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件



### <u>12.如何实现Java序列化与反序列化</u>

```java
// 实现 Serializabel接口
public class Person implements Serializable {
    // ...
}


public static void main(String[] args) throws Exception {
    //序列化后生成指定文件路径
    File file = new File("path");
    ObjectOutputStream oos = null;
    
    //装饰流
    oos = new ObjectOutputStream(new FileOutputStream(file));

    //实例化类
    Person per = new Person();
    oos.writeObject(per); //把类对象序列化
    oos.close();
}
```





### 13.Comparable和Comparator的区别

二者都是用来实现对象的比较、排序，Comparable 是在`集合内部`定义的方法实现的排序，Comparator 是在`集合外部`实现的排序

1. 内部排序调用 `Collections.sort(list);` ，外部排序则使用 `list.sort(Comparator 类型的参数)` 
2. 若一个类实现了Comparable接口，就意味着该类支持排序，而Comparator是比较器，若需要控制某个类的次序，可以建立一个该类的比较器来进行排序
3. 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码



Comparable：

```java
package java.lang;
import java.util.*;

public interface Comparable<T> {
  // 通过 x.compareTo(y) 来“比较x和y的大小”
	// 若返回“负数”，意味着“x比y小”
	// 返回“零”，意味着“x等于y”
	// 返回“正数”，意味着“x大于y”
    public int compareTo(T o);
}
```



Comparator：

```java
package java.util;

public interface Comparator<T> {

  	// 返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”
    int compare(T o1, T o2);

    boolean equals(Object obj);
}
```



### 14.IO同步、异步、阻塞、非阻塞的区别



### 15.如何判断一个对象是否存活/GC对象的判定方法

判断对象是否存活的算法包括：

1. 引用计数算法

   给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是不能再被引用的

2. 可达性分析算法

   通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链Reference Chain，当一个对象到GC Root没有任何引用链相连时，则证明此对象是不可用的
   
3. 三色标记法



判断一个无用的类需要同时满足下面3个条件：

1. 该类的所有实例都已经被回收
2. 加载该类的ClassLoader已经被回收
3. 该类对应的java.lang.Class对象已经没有任何地方被引用，无法在任何地方通过反射访问该类的方法



### 16.线程池内部工作原理





### 17.如何停止一个正在运行的线程

停止一个线程可以用`Thread.stop()`方法，但最好不要用，虽然它可以停止一个正在运行的线程，但这个方法是不安全的，而且已被废弃，在java中有以下3种方法可以终止正在运行的线程：

1. 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止
2. 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法
3. 使用interrupt方法中断线程



1. interrupt()方法的使用效果并不像for+break语句那样，马上停止循环，调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程

2. Thread类中提供了两个方法来判断线程是否停止状态：`this.interrupted()`：测试当前线程是否已经中断；`this.isInterrupted()`：测试线程是否已经中断，两个方法的区别：

   

   `this.interrupted()`：测试当前线程是否已经中断，当前线程是指运行this.interrupted()这行代码的线程，以下例子是在Main方法种调用的，Main方法没有被中断过，所以两次输出都是false

   ```java
   public class MyThread extends Thread {
       public void run(){
           super.run();
           for(int i=0; i<500000; i++){
               i++;
           }
       }
   }
   
   public class Run {
       public static void main(String args[]){
           Thread thread = new MyThread();
           thread.start();
           try {
               Thread.sleep(2000);
               thread.interrupt();
   
               System.out.println("Is thread Stop? " + thread.interrupted());
               System.out.println("Is thread Stop? " + thread.interrupted());
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   }
   ```

   输出结果：

   ```
   Is thread Stop? false
   Is thread Stop? false
   ```

   

   `Thread.currentThread().interrupt()` 可使main线程产生中断效果，Thread.interrupted() 会清除打断标记，所以第一次调用为true，再次调用时输出false：

   ```java
   public class Run {
       public static void main(String args[]){
           Thread.currentThread().interrupt();
           System.out.println("Is thread Stop? " + Thread.interrupted());
           System.out.println("Is thread Stop?" + Thread.interrupted());
       }
   }    
   
   // 输出
   Is thread Stop? true
   Is thread Stop? false
   ```

   

   `isInterrupted()` 不会清除打断标记：

   ```java
   public class Run {
       public static void main(String args[]){
           Thread thread = new MyThread();
           thread.start();
           thread.interrupt();
           System.out.println("Is thread Stop? " + thread.isInterrupted());
           System.out.println("Is thread Stop? " + thread.isInterrupted());
       }
   }
   
   // 输出
   Is thread Stop? true
   Is thread Stop? true
   ```

   

3. 所以可以利用 `interrupted()`来停止线程：

   ```java
   public class MyThread extends Thread {
       public void run(){
           super.run();
           for(int i=0; i<500000; i++){
               // 判断是否被打断
               if(this.interrupted()) {
                   System.out.println("线程已经终止， for循环不再执行");
                   break;
               }
               // System.out.println("i="+(i+1));
           }
           
           System.out.println("这是for循环外面的语句，也会被执行");
       }
   }
   
   public class Run {
       public static void main(String args[]){
           Thread thread = new MyThread();
           thread.start();
           try {
               Thread.sleep(2000);
               // 打断线程
               thread.interrupt();
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   }
   
   // 输出
   // 线程已经终止， for循环不再执行
   // 这是for循环外面的语句，也会被执行
   ```

   

   虽然停止了线程，但如果for语句下面还有语句，还是会继续运行，若不想让线程继续往下执行，可将 `break` 替换成 ` throw new InterruptedException();` 直接抛异常代码就不会往下执行





### 18.线程间如何通信

synchronized、wait/notify、join





### 19.ClassNotFoundException 和 NoClassDefFoundError 有什么区别

| ClassNotFoundException                                       | NoClassDefFoundError                          |
| ------------------------------------------------------------ | --------------------------------------------- |
| 继承自 `java.lang.Exception`                                 | 继承自 `java.lang.Error`                      |
| 当动态加载Class时找不到类会抛出异常                          | 当编译成功后，执行过程中找不到Class抛出该错误 |
| 一般在执行`Class.forName()`，`ClassLoader.loadClass()`以及使用`ClassLoader.findSystemClass()` 时抛出异常 | 由JVM运行时，系统抛出                         |





### 20.Java中的4种引用类型

强引用、软引用、弱引用、虚引用





### 21.Java中常见的8种锁

#### 公平锁/非公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁，非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，非公平锁会造成优先级反转或者饥饿现象

1. 对于Java `ReentrantLock`而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大
2. 对于`Synchronized`而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁



#### 可重入锁

可重入锁又名递归锁，是指在同一个线程可以多次获得同一个锁

1. 对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁
2. 对于Synchronized而言，也是一个可重入锁，可重入锁的一个好处是可一定程度避免死锁



#### 独享锁/共享锁

独享锁是指该锁一次只能被一个线程所持有，Synchronized / ReentrantLock是独享锁，共享锁是指该锁可被多个线程所持有，Lock的另一个实现类`ReadWriteLock`，其读锁是共享锁，其写锁是独享锁

1. 读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的
2. 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享



#### 互斥锁/读写锁

独享锁/共享锁只是一种广义的说法，互斥锁/读写锁就是具体的实现：

1. 互斥锁在Java中的具体实现就是`ReentrantLock`
2. 读写锁在Java中的具体实现就是`ReadWriteLock`



#### 乐观锁/悲观锁

1. 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题

2. 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的

3. 悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升

   悲观锁在Java中的使用，就是利用各种锁

4. 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新



#### 分段锁

分段锁其实是一种锁的设计，并不是具体的一种锁，对于`ConcurrentHashMap`而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作，以ConcurrentHashMap来说一下分段锁的含义以及设计思想：

1. `ConcurrentHashMap`中的分段锁称为Segment，它即类似于HashMap的结构，内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock，因为Segment继承了`ReentrantLock`
2. 当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入
3. 但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作



#### 偏向锁/轻量级锁/重量级锁



#### 自旋锁

在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU







### 22.JAVA 常见的几种线程池



#### ThreadPoolExecutor



##### 阻塞队列

阻塞队列实现了 BlockingQueue 接口，并且有多组处理方法

1. 抛出异常：add(e) 、remove()、element()
2. 返回特殊值：offer(e) 、pool()、peek()
3. 阻塞：put(e) 、take()



JDK 8 中提供了七个阻塞队列可供使用：

1. ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列，采用 FIFO 的原则对元素进行排序添加的。内部使用可重入锁 ReentrantLock + Condition 来完成多线程环境的并发操作
2. LinkedBlockingQueue ：一个由链表结构组成的无界阻塞队列
3. PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列
4. DelayQueue：一个使用优先级队列实现的无界阻塞队列
5. SynchronousQueue：一个不存储元素的阻塞队列
6. LinkedTransferQueue：一个由链表结构组成的无界阻塞队列
7. LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列

相关文章参考 ：[阻塞队列 BlockingQueue](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487078&idx=2&sn=315f39b6d53862dcb732390729951628&chksm=ebd6314adca1b85c33db1134fbe98bf7526943b02dfc23021781abff265bb231ad9bcd3e1ad1&scene=21#wechat_redirect) [Java并发编程：阻塞队列](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485221&idx=1&sn=056f233e5d1579da75fb3c1ffe6b9a53&chksm=ebd63809dca1b11f801ce66a30dcddc23645e4352ada849066687d4107903d92bdd8ac70bef9&scene=21#wechat_redirect) 



##### 四种拒绝策略

1. AbortPolicy：直接抛出异常，默认策略
2. CallerRunsPolicy：用调用者所在的线程来执行任务
3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务
4. DiscardPolicy：直接丢弃任务
5. 实现 RejectedExecutionHandler 接口，自定义拒绝策略



当添加新的任务到线程池时：

1. 线程数量未达到 corePoolSize，则新建一个线程（核心线程）执行任务
2. 线程数量达到了 corePoolSize，则将任务移入队列等待
3. 队列已满，新建线程（非核心线程）执行任务
4. 队列已满，总线程数又达到了 maximumPoolSize，就会由 handler 的拒绝策略来处理





#### FixedThreadPool

有固定数量线程的线程池，其`corePoolSize=maximumPoolSize`，且keepAliveTime为0，适合线程稳定的场所：

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
   return new ThreadPoolExecutor(nThreads, nThreads,
                                 0L, TimeUnit.MILLISECONDS,
                                 new LinkedBlockingQueue<Runnable>());
}
```



1. FixedThreadPool 使用了无界的 LinkedBlockingQueue, 当任务数量超过 corePoolSize 后，全都会添加到队列中
2. 当线程池满时且阻塞队列也已经满时，如果继续提交任务线程池不会再新建线程，会直接走拒绝策略，FixedThreadPool 使用的是默认的拒绝策略，即 `AbortPolicy`，直接抛出异常





#### SingleThreadExecutor

从数学的角度来看SingleThreadPool应该属于FixedThreadPool的子集。其`corePoolSize=maximumPoolSize=1`,且keepAliveTime为0，适合线程同步操作的场所

```java
public static ExecutorService newSingleThreadExecutor() {
   return new FinalizableDelegatedExecutorService
       (new ThreadPoolExecutor(1, 1,
                               0L, TimeUnit.MILLISECONDS,
                               new LinkedBlockingQueue<Runnable>()));
}
```





#### CachedThreadPool

既然要储存，其容量肯定是很大，所以他的corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE

```java
public static ExecutorService newCachedThreadPool() {
   return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                 60L, TimeUnit.SECONDS,
                                 new SynchronousQueue<Runnable>());
}
```



这个线程池，当任务提交是就会创建线程去执行,执行完成后线程会空闲60s,之后就会销毁。但是如果主线程提交任务的速度远远大于 CachedThreadPool 的处理速度，则 CachedThreadPool 会不断地创建新线程来执行任务，这样有可能会导致系统耗尽 CPU 和内存资源



#### ScheduleThreadPool

ScheduledThreadPool是一个具有定时定期执行任务功能的线程池



关文章参考：[JAVA线程池原理详解（1）](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247484686&idx=1&sn=b4f63e08a018ff7fadc4ecfb9352e439&chksm=ebd63a22dca1b334cc9ae79df71095cfbc6880e671aaa8addd273aa842801ebfaf4d9f95e714&scene=21#wechat_redirect) [JAVA线程池原理详解（2）](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247484699&idx=2&sn=b0e359218437e3eb6223b9acb8cdca68&chksm=ebd63a37dca1b321740fee80579779b6d34cf1997878a896f3a47127a2670afbd2af4f15127d&scene=21#wechat_redirect) [Java多线程和线程池](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247484840&idx=2&sn=6fa3a468ba36e86ab2c73b6c289dd708&chksm=ebd63a84dca1b392ed1674be76df99bcdd1ffb5dcc8245613d24b7cf277db663f3b40fd3fae2&scene=21#wechat_redirect) [Java线程池总结](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486337&idx=2&sn=5abbb5bf79607d437c637c8a968475c8&chksm=ebd634addca1bdbb62788e44feb9ff5692d9809eaeab4af07fa427cd349978d58e5be5ee9133&scene=21#wechat_redirect) 





### 22为什么要使用线程池

线程复用

1. 过于频繁的创建/销毁线程，会很大程度上影响处理效率，线程池缓存线程，可用已有的闲置线程来执行新任务(keepAliveTime)
2. 运用线程池能有效的控制线程最大并发数，可避免线程并发数量过多，抢占系统资源从而导致阻塞
3. 对线程进行一些简单的管理(延时执行、定时循环执行的策略等)





### 23.GC 垃圾回收





### 24.volatile 的实现原理

volatile 是轻量级的锁，它不会引起线程上下文的切换和调度:

1. volatile可见性：对一个volatile 的读，总可以看到对这个变量最终的写
2. volatile 原子性：volatile对单个读 / 写具有原子性（32 位 Long、Double），但是复合操作除外，例如i++ 
3. JVM 底层采用“内存屏障”来实现 volatile 语义，防止指令重排序
4. volatile 经常用于两个两个场景：状态标记变量、Double Check





### 25.Java 内存模型JMM 

JMM 规定了线程的工作内存和主内存的交互关系，以及线程之间的可见性和程序的执行顺序：

1. 一方面，要为程序员提供足够强的内存可见性保证
2. 另一方面，对编译器和处理器的限制要尽可能地放松。JMM 对程序员屏蔽了 CPU 以及 OS 内存的使用问题，能够使程序在不同的 CPU 和 OS 内存上都能够达到预期的效果

Java 采用内存共享的模式来实现线程之间的通信。编译器和处理器可以对程序进行重排序优化处理，但是需要遵守一些规则，不能随意重排序



jmm用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量



### 26.有关队列 AQS 队列同步器

AQS 是构建锁或者其他同步组件的基础框架，如 `ReentrantLock、ReentrantReadWriteLock、Semaphore` 等, 包含了实现同步器的细节，即获取同步状态、FIFO 同步队列。AQS 的主要使用方式是继承，子类通过继承同步器，并实现它的抽象方法来管理同步状态



维护一个同步状态 state。当 state > 0时，表示已经获取了锁；当state = 0 时，表示释放了锁



AQS 通过内置的 FIFO 同步队列来完成资源获取线程的排队工作：

1. 如果当前线程获取同步状态失败（锁）时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程
2. 当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态
3. AQS 内部维护的是CLH 双向同步队列

相关文章参考： [AbstractQueuedSynchronizer源码分析之条件队列](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485273&idx=2&sn=f0741b315ba14562317bc3c6fa91b2ae&chksm=ebd63875dca1b163d0338e97a11f8bccee07226890640826d7b0ec822c1e7eaf365f92db15fb&scene=21#wechat_redirect) 



调用signal方法可能唤醒线程也可能不会唤醒线程，但是调用signal方法一定会将线程从条件队列中移到同步队列尾部



### 27.ReentrantLock

ReentrantLock，可重入锁，是一种递归无阻塞的同步机制。它可以等同于 synchronized的使用，但是 ReentrantLock 提供了比synchronized 更强大、灵活的锁机制，可以减少死锁发生的概率：

1. ReentrantLock 实现 Lock 接口，基于内部的 Sync 实现
2. Sync 实现 AQS ，提供了 FairSync 和 NonFairSync 两种实现

##### Condition

Condition 和 Lock 一起使用以实现等待/通知模式，通过 `await()`和`singnal()` 来阻塞和唤醒线程。



Condition 是一种广义上的条件队列。他为线程提供了一种更为灵活的等待 / 通知模式，线程在调用 await 方法后执行挂起操作，直到线程等待的某个条件为真时才会被唤醒。Condition 必须要配合 Lock 一起使用，因为对共享状态变量的访问发生在多线程环境下。一个 Condition 的实例必须与一个 Lock 绑定，因此 Condition 一般都是作为 Lock 的内部实现



### 28.ReentrantReadWriteLock

读写锁维护着一对锁，一个读锁和一个写锁。通过分离读锁和写锁，使得并发性比一般的排他锁有了较大的提升：

1. 在同一时间，可以允许多个读线程同时访问
2. 但是，在写线程访问时，所有读线程和写线程都会被阻塞





### 29.Synchronized 和 Lock 的区别

1. Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；
2. synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock() 去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；
3. Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，- 等待的线程会一直等待下去，不能够响应中断；
4. 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。
5. Lock 可以提高多个线程进行读操作的效率

更深的：

1. 与 synchronized 相比，ReentrantLock 提供了更多，更加全面的功能，具备更强的扩展性。例如：时间锁等候，可中断锁等候，锁投票。
2. ReentrantLock 还提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活，所以在多个条件变量和高度竞争锁的地方，ReentrantLock 更加适合（以后会阐述 Condition）。
3. ReentrantLock 提供了可轮询的锁请求。它会尝试着去获取锁，如果成功则继续，否则可以等到下次运行时处理，而 synchronized则一旦进入锁请求要么成功要么阻塞，所以相比synchronized 而言，ReentrantLock 会不容易产生死锁些。
4. ReentrantLock 支持更加灵活的同步代码块，但是使用 synchronized时，只能在同一个synchronized块结构中获取和释放。注意，ReentrantLock 的锁释放一定要在finally 中处理，否则可能会产生严重的后果。
5. ReentrantLock 支持中断处理，且性能较 synchronized 会好些





### 30.Java 中线程同步的方式

1. sychronized 同步方法或代码块
2. volatile
3. Lock
4. ThreadLocal
5. 阻塞队列（LinkedBlockingQueue）
6. 使用原子变量（java.util.concurrent.atomic）
7. 变量的不可变性





### 31.类锁和对象锁的区别

1. 如果多线程同时访问同一类的 类锁（synchronized 修饰的静态方法）以及对象锁（synchronized 修饰的非静态方法）这两个方法执行是异步的，原因：类锁和对象锁是两种不同的锁
2. 类锁对该类的所有对象都能起作用，而对象锁不能





### 32.深拷贝和浅拷贝

在java中实现 `Cloneable`，重写 clone()就可以实现浅拷贝：

```java
@Override
protected Line clone() throws CloneNotSupportedException {
    return (Line)super.clone();
}
```



深拷贝的两种实现方式：

```java
@Override
protected Header clone() throws CloneNotSupportedException {
    Header header = (Header) super.clone();
    Line line = header.getLine().clone();
    header.setLine(line);
    return header;
}

// 序列化，实现 Serializable 接口，当前对象和引用对象都要实现该接口
public Header deepClone () {

    ByteArrayOutputStream bos  = null;
    ObjectOutputStream oos = null;

    ByteArrayInputStream bis = null;
    ObjectInputStream ois = null;

    try {

        bos = new ByteArrayOutputStream();
        oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        bis = new ByteArrayInputStream(bos.toByteArray());
        ois = new ObjectInputStream(bis);
        return (Header) ois.readObject();

    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            bos.close();
            oos.close();
            bis.close();
            ois.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return null;
}
```









### 33.Java 异常

#### Throwable

`Throwable` 是 Java 语言中所有错误与异常的超类， 包含两个子类：= 和 Exception，它们通常用于指示发生了异常情况，提供了 `printStackTrace()` 等接口用于获取堆栈跟踪数据等信息



#### Error

程序中无法处理的错误，表示运行应用程序中出现了严重的错误，此类错误一般表示代码运行时 JVM 出现问题，通常有 `Virtual MachineError` 虚拟机运行错误、`NoClassDefFoundError` 类定义错误， `OutOfMemoryError` 内存不足，`StackOverflowError` 栈溢出错误，此类错误发生时，JVM 将终止线程



#### Exception

程序本身可以捕获并且可以处理的异常，分为运行时异常和编译时异常

1. 运行时异常：RuntimeException 类及其子类，Java 编译器不会检查它没有通过throws声明抛出它，也没有用try-catch语句捕获它，还是会编译通过，如 `NullPointerException ArrayIndexOutBoundException ClassCastException` 
2. 编译时异常：除 RuntimeException 及其子类之外的异常，必须手动在代码里添加`try-catch`捕获语句来处理该异常，否则不能通过编译，如`SQLException  IOException  FileNotFoundException  ClassNotFoundException`





### 34.Error 和 Exception 区别

Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复

Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行



### 35.final、finally、finalize 有什么区别

1. final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值
2. finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码
3. `finalize()`是Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作



### 36.try-catch-finally 中哪个部分可以省略





### 37.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗

会执行，在 return 前执行



### 38.SimpleDateFormat 的线程安全问题









### 39.线程池中多余的线程如何回收

ThreadPoolExecutor回收工作线程，一条线程`getTask()`返回`null`，就会被回收，分以下两种情况：

1. 未调用shutdown() ，RUNNING状态下全部任务执行完成的场景
2. 







### 40.new 一个对象 JVM做了什么

1. 首先去常量池中看能否根据这个类的全路径找到这个类的信息，查看是否加载过，解析，初始化过。如果没有，则先进行类加载过程
2. 接下来JVM从堆内存里为新的对象分配内存，对象所需的内存大小在类加载的时候就可以完全确定





### 41.new String("123") 创建了几个对象

1. 如果方法区的常量池中，已经存在`123`，则只需在堆里创建一个对象就行，栈里的变量引用指向堆
2. 如果常量池中不存在`123`，先在常量池中创建，然后在堆里new一个对象，栈里的变量引用指向堆







### 42.进程和线程的区别

1. 进程是一段执行中的程序，是系统进行资源分配和调度的基本单位，因为进程的创建、销毁、切换产生大量的时间和空间开销，进程的数量不能太多，而线程是比进程更小的能独立运行的基本单位
2. 一个进程包含多个线程，线程的开销比进程的少







### 43.synchronized 原理

synchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为监视器锁，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现，作用主要就是实现原子性操作和解决共享变量的内存可见性问题：

1. 执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1，此时其他竞争锁的线程则会进入等待队列中
2. 执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁



如果再深入到源码来说，synchronized实际上有两个队列waitSet和entryList：

1. 当多个线程进入同步代码块时，首先进入entryList
2. 有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1
3. 如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁
4. 如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null





### 44.ReentrantLock 原理，和 synchronized 的区别

ReentrantLock基于AQS(抽象队列同步器)实现：AQS内部维护一个state状态位，尝试加锁的时候通过CAS(CompareAndSwap)修改值，如果成功设置为1，并且把当前线程ID赋值，则代表加锁成功，一旦获取到锁，其他的线程将会被阻塞进入阻塞队列自旋，获得锁的线程释放锁的时候将会唤醒阻塞队列中的线程，释放锁的时候则会把state重新置为0，同时当前线程ID置为空

区别：

1. 显示获取释放锁，公平非公平，尝试获取锁，condition多条件
2. 等待可中断，当持有锁的线程长时间不释放锁的时候，等待中的线程可以选择放弃等待，转而处理其他的任务







### 45.CAS 原理及缺点

原理：通过处理器的指令 保证操作的原子性，V为内存值，A旧的预期值，B新值，只有当V=A时才会用B去更新V

缺点：

1. ABA问题：Javay用`AtomicStampedReference`来解决这个问题，加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新
2. 循环时间长开销大：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销
3. 只能保证一个共享变量的原子操作：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现





### 46.JMM









1. java的8种基本类型，及其所占字节

2. int与integer的区别

3. utf-8编码中的中文占几个字节，int占几个字节

4. 多态

5. 为什么要有内部类，说一下成员内部类，静态内部类，局部内部类，匿名内部类

   内部类能更好的隐藏一些细节，而且可以实现java多继承

6. 什么时候用接口，什么时候用抽象类

   - 当注重代码的扩展性和维护性时有限考虑接口
   - 需要为一些类提供公共的代码实现时使用抽象类

7. 泛型中extends和super的区别

   - `<? extends Fruit>`代表上界通配符，List中存放的对象都是Fruit以及其子类对象，由于不能确定List中是Fruit还是其子类对象，所以add的时候会报错，`确切的说不能add除了null以外的所有对象，包括object`

     ```java
     public void call(List<? extends Fruit> fruits) {
       for (Fruit fruit: fruits) {
         // ...
       }
     }
     
     public static void main(String[] args) {
       List<Banana> bananaList = new ArrayList<>();
       // 编译通过，若call方法中的参数直接写List<Fruit>会编译不通过
       new Fruit().call(bananaList);
     }

   - super与extends是完全相反的，其定义的是下界通配符，`List<? super Fruit>`存放的是Fruit和它的父类的对象，如Object等，只能添加Fruit类型及其子类对象，并且取出的数据类型都为Object

     ```java
     public void call(List<? super Fruit> fruits) {
       fruits.add(new Fruit());
       fruits.add(new Banana());
       // 遍历的类型都为Object
       for (Object fruit : fruits) {
         // ... 
       }
     }
     ```

     

8. 静态属性和静态方法能不能被继承和重写，为什么

   - 静态属性和静态方法是可以被子类继承的，但静态属性不能被子类重写

9. 静态代理和动态代理的区别

   - 静态代理中的代理类是由程序员编写的，执行之前就已经存在class文件，而且一般来说一个代理类只能代理一个目标对象，静态代理要求代理类和目标类都实现同一接口，代码冗余高
   - 动态代理则是根据程序的运行时动态的生成代理类，可以通过反射或者就修改字节码的生成代理类，如jdk，cglib动态代理

10. 说一下注解

    - 何时执行：`@Retention(RetentionPolicy.RUNTIME)`
    - 作用对象：`@Target(ElementType.TYPE)`

11. 手写hashmap需要注意什么

    - key在数组中的位置，减少hash冲突
    - 扩容阈值
    - 何时将链表转红黑树
    - 初始容量，加载因子

12. 说一下常用的数据结构

13. 链表，往一个有序的循环链表中差一个数据保持链表顺序不变，说一下具体的思路

14. 堆排序

15. 树的深度优先遍历和广度优先遍历

16. 并发集合

17. ConcurrentHashMap的实现原理

18. IO的理解，NIO，BIO。。。

19. 线程run和start的区别







1. java中==和equals和hashCode的区别

2. int、char、long各占多少字节数

   - byte 1
   - short 2
   - int 4
   - float 4
   - double 8
   - long 8
   - char 2
   - boolean 4？

3. int与integer的区别

4. 自动拆箱装箱

   ```java
   //自动装箱
   Integer total = 99;
   
   //自动拆箱
   int totalprim = total;
   
   
   // 反编译得到的代码 javap -c StringTest 
   Integer total = Integer.valueOf(99);
   
   int totalprim = total.intValue();
   ```

   

5. 谈谈对java多态的理解

   - 多态是指父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作 作用于不同对象，产生不同的执行结果
   - 多态的三个条件：继承父类，重写父类方法，父类引用指向子类对象
   - *实现多态的技术称为*动态绑定，在执行期间判断所 引用对象的实际类型，根据其实际的类型调用其相应的方法
   - 多态的好处：可扩充
   - Java 中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方 法重载

6. String、StringBuffer、StringBuilder区别

   - 可变与不可变：String为不可变，`private final char value[]` 
   - 线程安全：StringBuilder并没有对方法进行加同步锁，所以是线程不安全的

7. 什么是内部类？内部类的作用 [参考](https://blog.csdn.net/u013728021/article/details/87358517?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control) 

   - 内部类提供了更好的封装，可以把内部类隐藏在外部类内，不允许同一个包中的其他类访问该类

   - 内部类的方法可以直接访问外部类的所有数据，包括私有的数据

   - 内部类的作用：可以访问外部类的所有资源，实现隐藏，实现多重继承，优化简单的接口实现

     ```java
     // 实力化成员内部类，可以访问外部类的所有资源，但不能定义静态资源，因为其实力化需依靠外部类
     Parent.InnerClass innerClass = new Parent().new InnerClass();
     
     // 实力化静态内部类，只能访问外部类的静态资源
     Parent.StaticInnerClass staticInnerClass = new Parent.StaticInnerClass();
     
     // 局部内部类，不能被任何修饰符修饰，且只能访问所在代码块或自定义为final的局部变量
     
     // 匿名内部类
     ```



如果当内部类的引用被外部类以外的其他类引用时，就会造成内部类和外部类无法被GC回收的情况，即使外部类没有被引用，因为内部类持有指向外部类的引用，从而引起内存泄露


​     

8. 抽象类的意义

   - 抽象方法必须为public或者protected
   - 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类
   - 

9. 接口的意义

   - 接口中的变量会被隐式地指定为public static final变量
   - 方法会被隐式地指定为public abstract方法
   - java8之后可以用static，default写方法体

10. 抽象类和接口区别

    - 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的
    - ~~接口中不能含有静态代码块以及静态方法~~，而抽象类可以有静态代码块和静态方法
    - 抽象类可以有构造方法，而接口没有

13. 抽象类是否可以没有方法和属性

12. 父类的静态方法能否被子类重写

    - 不能，父类的静态方法能够被子类继承，但是不能够被子类重写，即使子类中的静态方法与父类中的静态方法完全一样，也是两个完全不同的方法
    - 静态变量也不能够被重写，如果想要调用父类的静态方法，应该使用类来调用
    - 重写指的是根据运行时对象的类型来决定调用哪个方法，而静态变量和静态方法在编译的时候就将其与类绑定在一起，在编译的时候就决定了调用的方法、变量，和重写没有关系
    - 静态变量和静态方法可以被继承，如果子类中有相同的静态方法和静态变量，那么父类的方法以及变量就会被覆盖

    

13. 进程和线程的区别

    - 进程是操作系统分配资源和调度的基本单位，新建，销毁以及切换进程都需要消耗大量的时间和空间
    - 线程是比进程更小的可执行的单位，比进程开销小

14. final，finally，finalize的区别

15. 序列化的方式

16. Serializable 和Parcelable 的区别

17. 闭包和局部内部类的区别

18. string 转换成 integer的方式及原理

    - parseInt(String s)--内部调用parseInt(s,10)（默认为10进制）
    - 正常判断null，进制范围，length等
    - 判断第一个字符是否是符号位
    - 循环遍历确定每个字符的十进制值
    - 通过*= 和-= 进行计算拼接
    - 判断是否为负值 返回结果







[来源](https://zhuanlan.zhihu.com/p/259155325) 

1. 哪些情况下的对象会被垃圾回收机制处理掉

   - 引用计数法
   - 可达性分析算法

2. 讲一下常见编码方式

   - 编码的意义：计算机中存储的最小单元是一个字节即8bit，所能表示的字符范围是255个，而人类要表示的符号太多，无法用一个字节来完全表示，固需要将符号编码，将各种语言翻译成计算机能懂的语言。

   - ASCII码：共有128个，用一个字节的低7位表示

   - ISO8859-1：在ASCII码的基础上涵盖了大多数西欧语言字符，仍然是单字节编码，它总共能表示256个字符

   - GB2312：双字节编码，总编码范围是A1-A7,A1-A9是符号区，包含682个字符，B0-B7是汉字区，包含6763个汉字

   - GBK：为了扩展GB2312,加入了更多的汉字，编码范围是8140~FEFE，有23940个码位，能表示21003个汉字

   - UTF-16：具体定义了Unicode字符在计算机中的存取方法。采用2字节来表示Unicode转化格式，它是定长的表示方法，不论什么字符都可以用两个字节表示

   - UTF-8：  UTF-16统一采用两字节表示一个字符，但有些字符只用一个字节就可表示，浪费存储空间，而UTF-8采用一种变长技术，每个编码区域有不同的字码长度。 不同类型的字符可以由1~6个字节组成

     ​                  如果一个字节，最高位为0，表示这是一个ASCII字符（00~7F）
     ​                  如果一个字节，以11开头，连续的1的个数暗示这个字符的字节数 

     

3. utf-8编码中的中文占几个字节，int型几个字节

   utf-8是一种变长编码技术，utf-8编码中的中文占用的字节不确定，可能2个、3个、4个，int型占4个字节

   

4. 静态代理和动态代理的区别，什么场景使用

   `代理解决的问题是当两个类需要通信时，引入第三方代理类，将两个类的关系解耦，代理类和委托类要实现相同的接口，因为代理真正调用的还是委托类的方法` 

   

   - 静态代理：由程序员创建或特定工具自动生成源代码，再对其编译，在程序运行之前，代理类的class类文件就已经被创建了，静态代理通常只代理一个类，需要实现接口，造成代码冗余，只能对固定接口的实现类实现代理，灵活性较差

   - 动态代理：在程序运行时通过反射机制动态创建代理类，动态代理代理的是一个接口下的多个实现类，只需将被委托类作为参数传入即可，使用灵活；服务内容只需写在invoke方法中，但效率低

   - 动态代理基于JDK实现：通过JDK提供的工具方法Proxy.newProxyInstance动态构建全新的代理类（继承Proxy类，并持有InvocationHandler接口引用）字节码文件并实例化对象返回。由Java内部的反射机制来实例化代理对象，并代理的调用委托类方法

     ```java
  Proxy.newProxyInstance(
                     被代理类.getClass().getClassLoader(),
                     被代理类.getClass().getInterfaces(), 
                     this);
     ```
   
     

   - 动态代理基于CGlib实现：基于继承被代理类生成代理子类，不用实现接口，只需被代理类为非final类，底层借用ASM字节码技术实现

   - 动态代理基于AspectJ实现：修改目标类的字节，织入代理的字节，在程序编译的时候，插入动态代理的字节码，不会生成全新的class

   - 

5. Java的异常体系

   - 所有异常类的基类是Throwable类，两大子类分别是Error和Exception

   - 异常又分为RuntimeException和CheckedException，检查时异常如IOException, FileNotFoundException

   - Error是程序无法处理的错误，由JVM产生和抛出的，比如OutOfMemoryError，ThreadDeath等，这些异常发生时，Java虚拟机一般会选择线程终止

   - 异常处理：throws，throw，try，catch，finnaly

   - 

      

6. 谈谈你对解析与分派的认识

   - ###### 解析：指方法在运行前，即编译期间就可知的，有一个确定的版本，运行期间也不会改变。解析是静态的，在类加载的解析阶段就可将符号引用转变成直接引用

   - ###### 分派：可分为静态分派和动态分派，重载属于静态分派，覆盖属于动态分派。 静态分派是指在重载时通过参数的静态类型而非实际类型作为判断依据，在编译阶段，编译器可根据参数的静态类型决定使用哪一个重载版本。 动态分派则需要根据实际类型来调用相应的方法

   - 

7. 修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法

   会调用对象的equals方法，如果对象的equals方法没有被重写，equals方法和==都是比较栈内局部变量表中指向堆内存地址值是否相等

   

   

8. Java中实现多态的机制是什么

   - Java实现多态有三个必要条件：继承、重写、向上转型，在多态中需要将子类的引用赋值给父类对象，只有这样该引用才能够具备调用父类方法和子类的方法

     

9. 如何将一个Java对象序列化到文件里

   - `ObjectOutputStream.writeObject()`负责将指定的流写入，`ObjectInputStream.readObject()`从指定流读取序列化数据

     ```java
     //写入
     try {
         ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream("D:/student.txt"));
         os.writeObject(studentList);
         os.close();
     } catch(FileNotFoundException e) {
         e.printStackTrace();
     } catch(IOException e) {
         e.printStackTrace();
     }
     ```

     

10. 说说你对Java反射的理解

    - 在运行状态中，对任意一个类，都能知道这个类的所有属性和方法，对任意一个对象，都能调用它的任意一个方法和属性，这种能动态获取信息及动态调用对象方法的功能称为java语言的反射机制
    - 开发过程中，经常会遇到某个类的某个成员变量、方法或属性是私有的，或只对系统应用开放，这里就可以利用java的反射机制通过反射来获取所需的私有成员或是方法
    - 带有Declared修饰的方法可以反射到私有的方法，没有Declared修饰的只能用来反射公有的方法
    - 

11. 说说你对Java注解的理解

    - 注解是通过@interface关键字来进行定义的，形式和接口差不多，只是前面多了一个@
    - 要使注解能正常工作，还需要使用元注解，它是可以注解到注解上的注解，元标签有@Retention @Documented @Target @Inherited @Repeatable五种
    - @Retention说明注解的存活时间，取值有RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时被丢弃；RetentionPolicy.CLASS 注解只保留到编译进行的时候，并不会被加载到JVM中，RetentionPolicy.RUNTIME可以留到程序运行的时候，它会被加载进入到JVM中，所以在程序运行时可以获取到它们
    - @Target 限定注解的应用场景，ElementType.FIELD给属性进行注解；ElementType.LOCAL_VARIABLE可以给局部变量进行注解；ElementType.METHOD可以给方法进行注解；ElementType.PACKAGE可以给一个包进行注解 ElementType.TYPE可以给一个类型进行注解，如类、接口、枚举
    - 

12. 说说你对依赖注入的理解

13. 说一下泛型原理，并举例说明

14. Java中String的了解

15. String为什么要设计成不可变的

    - ###### 字符串常量池需要String不可变：因为String设计成不可变，当创建一个String对象时，若此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象。如果字符串变量允许必变，会导致各种逻辑错误，如改变一个对象会影响到另一个独立对象

    - ###### String对象可以缓存hashCode：字符串的不可变性保证了hash码的唯一性，因此可以缓存String的hashCode，这样不用每次去重新计算哈希码。在进行字符串比较时，可以直接比较hashCode，提高了比较性能

    - 

16. Object类的equal和hashCode方法重写，为什么







1. 常用数据结构简介
2. 并发集合了解哪些
3. 列举java的集合以及集合之间的继承关系
4. 集合类以及集合框架
5. 容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 [Java容器类](http://alexyyek.github.io/2015/04/06/Collection/)）
6. List,Set,Map的区别
7. List和Map的实现方式以及存储方式
8. HashMap的实现原理
9. HashMap数据结构？
10. HashMap源码理解
11. HashMap如何put数据（从HashMap源码角度讲解）？
12. HashMap怎么手写实现？
13. ConcurrentHashMap的实现原理
14. ArrayMap和HashMap的对比
15. HashTable实现原理
16. TreeMap具体实现
17. HashMap和HashTable的区别
18. HashMap与HashSet的区别
19. HashSet与HashMap怎么判断集合元素重复？
20. 集合Set实现Hash怎么防止碰撞
21. ArrayList和LinkedList的区别，以及应用场景
22. 数组和链表的区别
23. 二叉树的深度优先遍历和广度优先遍历的具体实现
24. 堆的结构
25. 堆和树的区别
26. 堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？
27. 什么是深拷贝和浅拷贝
28. 手写链表逆序代码
29. 讲一下对树，B+树的理解
30. 讲一下对图的理解
31. 判断单链表成环与否？
32. 链表翻转（即：翻转一个单项链表）
33. 合并多个单有序链表（假设都是递增的）





1. 开启线程的三种方式？
2. 线程和进程的区别？
3. 为什么要有线程，而不是仅仅用进程？
4. run()和start()方法区别
5. 如何控制某个方法允许并发访问线程的个数？
6. 在Java中wait和seelp方法的不同；
7. 谈谈wait/notify关键字的理解
8. 什么导致线程阻塞？
9. 线程如何关闭？
10. 讲一下java中的同步的方法
11. 数据一致性如何保证？
12. 保证线程安全？
13. 如何实现线程同步
14. 两个进程同时要求写或者读，能不能实现？如何防止进程的同步？
15. 线程间操作List
16. Java中对象的生命周期
17. Synchronized用法
18. synchronize的原理
19. 谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解
20. static synchronized 方法的多线程访问和作用
21. 同一个类里面两个synchronized方法，两个线程同时访问的问题
22. volatile的原理
23. 谈谈volatile关键字的用法
24. 谈谈volatile关键字的作用
25. 谈谈NIO的理解
26. synchronized 和volatile 关键字的区别
27. synchronized与Lock的区别
28. ReentrantLock 、synchronized和volatile比较
29. ReentrantLock的内部实现
30. lock原理
31. 死锁的四个必要条件？
32. 怎么避免死锁？
33. 对象锁和类锁是否会互相影响？
34. 什么是线程池，如何使用?
35. Java的并发、多线程、线程模型
36. 谈谈对多线程的理解
37. 多线程有什么要注意的问题？
38. 谈谈你对并发编程的理解并举例说明
39. 谈谈你对多线程同步机制的理解？
40. 如何保证多线程读写文件的安全？
41. 多线程断点续传原理
42. 断点续传的实现
43. 





1. 线程池的几个重要参数，为什么要用线程池，线程池是怎么复用线程的

   - 在线程池中，线程会从 workQueue 中读取任务来执行，最小的执行单位就是 Worker，Worker 实现了 Runnable 接口，重写了 run 方法，这个 run 方法是让每个线程去执行一个循环，在这个循环代码中，去判断是否有任务待执行，若有则直接去执行这个任务，因此线程数不会增加

   - `java.util.concurrent.ThreadPoolExecutor#execute` 

   ```java
     public void execute(Runnable command) {
         // 如果传入的Runnable的空，就抛出异常
         if (command == null)
             throw new NullPointerException();
         int c = ctl.get();
         // 线程池中的线程比核心线程数少
         if (workerCountOf(c) < corePoolSize) {
             // 新建一个核心线程执行任务
             if (addWorker(command, true))
                 return;
             c = ctl.get();
         }
         // 核心线程已满，但是任务队列未满，添加到队列中
         if (isRunning(c) && workQueue.offer(command)) {
             int recheck = ctl.get();
             // 任务成功添加到队列以后，再次检查是否需要添加新的线程，因为已存在的线程可能被销毁了
             if (! isRunning(recheck) && remove(command))
                 // 如果线程池处于非运行状态，并且把当前的任务从任务队列中移除成功，则拒绝该任务
                 reject(command);
             else if (workerCountOf(recheck) == 0)
                 // 如果之前的线程已经被销毁完，新建一个非核心线程
                 addWorker(null, false);
         }
         // 核心线程池已满，队列已满，尝试创建一个非核心新的线程
         else if (!addWorker(command, false))
             // 如果创建新线程失败，说明线程池关闭或者线程池满了，拒绝任务
             reject(command);
     }
   ```

   

   `java.util.concurrent.ThreadPoolExecutor#runWorker` 

   ```java
   final void runWorker(Worker w) {
       Thread wt = Thread.currentThread();
       Runnable task = w.firstTask;
       w.firstTask = null;
       w.unlock(); // 释放锁 设置work的state=0 允许中断
       boolean completedAbruptly = true;
       try {
           //一直执行 如果task不为空 或者 从队列中获取的task不为空
           while (task != null || (task = getTask()) != null) {
                   task.run();//执行task中的run方法
               }
           }
           completedAbruptly = false;
       } finally {
           //1.将 worker 从数组 workers 里删除掉
           //2.根据布尔值 allowCoreThreadTimeOut 来决定是否补充新的 Worker 进数组 workers
           processWorkerExit(w, completedAbruptly);
       }
   }
   ```

   

   - 

2. hashmap的结构，为什么用红黑树，红黑树的优缺点，为什么不用avl树，avl树优缺点

   - 红黑树不追求"完全平衡"，不像AVL那样要求左右子树高度它相差1，只要求部分达到平衡，但是提出了为节点增加颜色，`任何不平衡都会在三次旋转之内解决`，而AVL是严格平衡树，因此在增加或者删除节点时，旋转的次数可能比红黑树要多

   - 

     

3. 从分代的思想说一下垃圾回收

   ![image-20210508134206067](https://i.loli.net/2021/05/08/sC7ofH25vZBMFVP.png)

4. 对象什么时候会从servivor区放放old区，jvm中哪些地方会发生oom

   - 当对象首次创建时，会放在新生代的eden区, 若没有发生GC，会一直在eden区, GC后，可能进入survivor区或者年老代
   - 当对象年龄达到一定的大小 ,就会离开年轻代， 进入老年代，`-XX:MaxTenuringThreshold=n`：在年轻代servivor经过n次GC后进入old区，-XX:TargetSurvivorRatio
   - 若对象体积太大, 新生代无法容纳这个对象，也会进入old区，`-XX:PretenureSizeThreshold`：达到这个值的对象直接放入old区

5. 何时发生full gc

   - 调用System.gc()，可能会fullgc，可通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc
   - 老年代空间不足
   - 方法区/元空间 空间不足
   - 

6. 方法区会gc吗，什么时候gc

7. 各个版本的jdk内存结构的变化

   - jdk1.6之前，堆，方法区，静态变量及字符串常量池都在方法区中
   - jdk1.7，堆，方法区，静态变量及字符串常量池都在堆中
   - Jdk1.8之后，堆，将方法区该为元空间，而且元空间不在jvm当中，被提到了本地内存中，静态变量及字符串常量池都在堆中

8. 如果年轻代经常发生gc，会是什么原因，怎么解决

9. 项目上如果发生了oom如何定位问题

10. 如何调整新老年代的空间，项目上是怎么设计的，你们生产的比例一般设为多少

11. 年轻代经常gc，可以调高年轻代的空间吗，这样做的优缺点是什么

12. 有没有用过什么gc工具

13. g1垃圾回收器的回收流程

14. 用过什么消息中间件

15. 分布式锁实现有哪些方式

16. redis怎么实现分布式锁的，实现的原理

17. mysql 索引结构，聚簇索引和非聚簇索引的区别

18. `select a from table where b=15 order by c`，应该怎么建索引

19. 项目上遇到什么难题，怎么解决

20. 说一下你项目上的合同这个模块的背景（我说我做的大多都是合同系统），怎么操作的，给谁用，具体流程是什么





https://blog.csdn.net/weixin_44152379/article/details/112399155



synchronized 锁升级的过程

无锁，偏向锁，轻量级锁，重量级锁







































































































































































































































































































### TCP / HTTP

TCP协议对应于传输层，而HTTP协议对应于应用层，从本质上来说，二者没有可比性。但是，http是基于tcp协议的，TCP/IP 协议分层模型：

1. 物理层将二进制的0和1和电压高低，光的闪灭和电波的强弱信号进行转换

2. 链路层代表驱动

3. 网络层

4. - 使用 IP 协议，IP 协议基于 IP 转发分包数据
   - IP 协议是个不可靠协议，不会重发
   - IP 协议发送失败会使用ICMP 协议通知失败
   - ARP 解析 IP 中的 MAC 地址，MAC 地址由网卡出厂提供
   - IP 还隐含链路层的功能，不管双方底层的链路层是啥，都能通信

5. 传输层

6. - TCP 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开连接，需要至少7次的发包收包，资源浪费
   - UDP 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层
   - 通用的 TCP 和 UDP 协议

7. 会话层以上分层

8. - TCP/IP 分层中，会话层，表示层，应用层集中在一起
   - 网络管理通过 SNMP 协议



### TCP三次握手和四次挥手

**三次握手：**

1. 客户端–发送带有SYN标志的数据包–一次握手–服务端
2. 服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端
3. 客户端–发送带有带有ACK标志的数据包–三次握手–服务端



**四次挥手：**

1. 客户端-发送一个FIN，用来关闭客户端到服务器的数据传送
2. 服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号
3. 服务器-关闭与客户端的连接，发送一个FIN给客户端
4. 客户端-发回ACK报文确认，并将确认序号设置为收到序号加1



































































































































































































