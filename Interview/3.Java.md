## Java基础

### 1.内部类

1. 静态内部类：可以访问外部的静态资源，包括静态私有资源。但不能访问非静态资源，可以不依赖外部类实例而实例化

2. 成员内部类：可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类

3. 局部内部类： 局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰，局部内部类只能访问所在代码块或者方法中被定义为final的局部变量

4. 匿名内部类：没有类名的内部类，不能使用class，extends和implements，没有构造方法，不能定义静态资源，只能创建一个匿名内部类实例，一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口，匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效



### 内部类的作用

内部类能更好的隐藏一些细节，而且可以实现java多继承 [参考](https://blog.csdn.net/u013728021/article/details/87358517?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control) 

内部类的存在可以提高代码的可读性和可维护性，同时也可以隐藏一些实现细节，增加安全性。但是过度使用内部类可能会增加代码的复杂度，影响程序的性能。所以在使用内部类时，需要权衡好利弊，根据实际情况进行选择：

- 内部类提供了更好的封装，可以把内部类隐藏在外部类内，不允许同一个包中的其他类访问该类
- 内部类的方法可以直接访问外部类的所有数据，包括私有的数据
- 内部类的作用：可以访问外部类的所有资源，实现隐藏，实现多重继承，优化简单的接口实现

- ```java
  // 实力化成员内部类，可以访问外部类的所有资源，但不能定义静态资源，因为其实力化需依靠外部类
  Parent.InnerClass innerClass = new Parent().new InnerClass();
  
  // 实力化静态内部类，只能访问外部类的静态资源
  Parent.StaticInnerClass staticInnerClass = new Parent.StaticInnerClass();
  
  // 局部内部类，不能被任何修饰符修饰，且只能访问所在代码块或自定义为final的局部变量
  
  // 匿名内部类
  ```



如果当内部类的引用被外部类以外的其他类引用时，就会造成内部类和外部类无法被GC回收的情况，即使外部类没有被引用，因为内部类持有指向外部类的引用，从而引起内存泄露



### 2.Object类中的13个方法

| 方法                            | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| Object()                        | 构造方法                                                     |
| registerNatives()               |                                                              |
| `clone()`                       | 对象拷贝，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常 |
| `getClass()`                    | final方法，用于获得运行时的类型，方法返回的是此Object对象的类对象/运行时类对象Class，效果与`Object.class`相同 |
| `equals()`                      | 用来比较两个对象的内容是否相等                               |
| `hashCode()`                    | 返回其所在对象的物理地址（哈希码值），常会和`equals`方法同时重写，确保相等的两个对象拥有相等的hashCode |
| toString()                      |                                                              |
| `wait()`                        | 导致当前的线程等待，直到其他线程调用此对象的 `notify()` 方法或 `notifyAll()` 方法 |
| `wait(long timeout)`            | 导致当前的线程等待，直到其他线程调用此对象的 `notify()` 方法或 `notifyAll()` 方法，或者超过指定的时间量 |
| `wait(long timeout, int nanos)` |                                                              |
| `notify()`                      | 随机唤醒在此对象监视器上等待的某个线程                       |
| `notifyAll()`                   | 唤醒在此对象监视器上等待的所有线程                           |
| finalize()                      | 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法 |





### hashCode() 和 equals() 之间的关系

关于这两个方法，必须遵循的规则：

1. 只要重写equals()，就必须重写hashCode()
   - 首先有两个对象相等，即equals返回true，则hashcode一定相同的结论
   - 如果只重写equals没有冲洗hashcode，那equals返回true，hashcode比较的还是两个对象的地址，显然和上面的结论相悖
   - 所以重写equals时就必须重写hashcode
   - 重写hashcode也是为了提高程序的效率，hashcode不同则没必要用equals比较

`hashCode()` 的作用是获取哈希码，也称为散列码，返回一个int整数，这个哈希码的作用是确定该对象在哈希表中的索引位置

重写equals的时候还要注意要满足自反性、对称性、传递性、一致性





### Java中==和equals/hashCode的区别

1. '=='运算符检查两个对象是否指向相同的内存地址
2. 两个对象具有不同的物理地址但包含相同的内容，则它们将在使用`equals()`时被视为相等
3. 如果两个对象相等，则它们的哈希码也必须相等





### 自动装箱/拆箱

```java
//自动装箱
Integer total = 99;

//自动拆箱
int totalprim = total;


// 反编译得到的代码 javap -c StringTest 
Integer total = Integer.valueOf(99);

int totalprim = total.intValue();
```



### Java中String的了解

1. 不可变性：`String`对象是不可变的。一旦创建了一个`String`对象，就不能更改它的内容。如果试图更改一个`String`对象，那么将创建一个新的`String`对象
2. 字符串池：Java平台提供了一个字符串池（String Pool），在这个池中，相同的字符串只保存一次。当创建一个字符串时，如果字符串池中已经存在相同的字符串，则返回池中的实例。可以使用`intern()`方法将任何字符串添加到字符串池中



```java
				String s1 = "123";
        String s2 = "123";
        System.out.println(s1 == s2); // true


        String s3 = s2;
        System.out.println(s1 == s3); // true

        String s4 = "1234";
        String s5 = s3 + "4";
        System.out.println(s4 == s5); // false

        String s6 = new String("allen");
        String s7 = new String("allen");
        System.out.println(s6 == s7); // false

        String s8 = "allen";
        System.out.println(s7 == s8); // false
```



### String为什么要设计成不可变的

1. 性能方面：字符串常量池（String pool）是 Java 堆内存中一个特殊的存储区域，若创建的 String 对象时已经存在于常量池中，则不会创建新的对象，而是直接引用已经存在的对象，由于字符串常常被频繁使用，若其为可变对象，每次修改都需要重新开辟新的内存空间，导致资源浪费，防止频繁GC
2. 线程安全：由于String是不可变的，多个线程可以同时访问同一字符串对象，无需担心数据被修改而引起线程安全问题
3. 缓存hashCode：字符串的不可变性保证了hash码的唯一性，在进行字符串比较时，可以直接比较hashCode



### String 类是如何实现不可变的

1. 私有成员常量，而且没有对外提供可以修改这两个属性的方法

   ```java
   private final char value[];
   
   private int hash; // Default to 0
   ```

2. String 有很多 public 方法，每个方法都将创建新的 String 对象

3. String 被 final 修饰，就不能通过继承重写方法

4. 构造函数深拷贝，当传入可变数组 value[] 时，进行 copy 而不是直接将 value[] 复制给内部变量

   ```java
   public String(char value[]) {
       this.value = Arrays.copyOf(value, value.length);
   }
   ```

   



### String、StringBuffer、StringBuilder区别

- 可变与不可变：String为不可变，`private final char value[]` 
- 线程安全：StringBuilder并没有对方法进行加同步锁，所以是线程不安全的



### String 转换成 Integer的方式及原理

- parseInt(String s)--内部调用parseInt(s,10)（默认为10进制）
- 正常判断null，进制范围，length等
- 判断第一个字符是否是符号位
- 循环遍历确定每个字符的十进制值
- 通过*= 和-= 进行计算拼接
- 判断是否为负值 返回结果



### Java的8种基本类型及其所占字节

```java
整型：byte、short、int、long

byte: 1字节（8位），取值范围是 -128 ~ 127。

short: 2字节（16位），取值范围是 -32768 ~ 32767。

int: 4字节（32位），取值范围是 -2147483648 ~ 2147483647。

long: 8字节（64位），取值范围是 -9223372036854775808 ~ 9223372036854775807。

浮点型：float、double

float: 4字节（32位），单精度浮点数，取值范围是 -3.40282347E+38 ~ 3.40282347E+38。

double: 8字节（64位），双精度浮点数，取值范围是 -1.79769313486231570E+308 ~ 1.79769313486231570E+308。



char: 2字节（16位），用于表示单个字符，取值范围是 0 ~ 65535。

布尔型：boolean

boolean: 1字节（8位），表示 true 或 false。

这些基本类型都有固定的字节长度和取值范围。在Java中，基本数据类型的变量的值是直接存储在内存中的，因此它们的操作效率较高
```



### int与Integer的区别

1. 基本类型和引用类型：int是Java的基本数据类型，而Integer是一个封装类，是Java中的引用类型

2. 可以为空：int是一个原始数据类型，它不能为null。而Integer是一个对象类型，可以赋值为null

3. 自动装箱和拆箱：Java5之后，Java增加了自动装箱和拆箱机制，可以在int和Integer之间进行自动转换。自动装箱是指将基本类型转换为对应的包装类型，例如int转换为Integer。而自动拆箱则是指将包装类型转换为对应的基本类型，例如Integer转换为int

   ```java
   // 装箱
   Integer i = 10;
   Integer i = Integer.valueOf(10);
   
   // 拆箱
   int n = i;
   int m = i.intValue();
   ```

   

4. 效率：int比Integer更高效，因为int是一个原始数据类型，存储在栈中，它的读取和操作速度比Integer快。而Integer是一个对象类型，存储在堆中，它的读取和操作速度比int慢。因此，在大量计算和需要高效性能的场景下，建议使用int

总的来说，int和Integer都是表示整数的数据类型，但是它们的使用场景和特性略有不同，需要根据具体情况来选择使用哪种类型

```java
				Integer i1 = 100;
        Integer i2 = 100;
        Integer i3 = 200;
        Integer i4 = 200;

        Integer one=new Integer(100);
        Integer two=new Integer(100);
        System.out.println(i1==i2);   // true
        System.out.println(i3==i4);   // false
        System.out.println(one==two);  // false
        System.out.println(i1==100);   // true
        System.out.println(i1==one);   // false
```



### UTF-8编码中的中文占几个字节，int占几个字节

utf-8是一种变长编码技术，utf-8编码中的中文占用的字节不确定，可能2个、3个、4个

int类型占用4个字节（32位）。int类型可以表示的整数范围是-2147483648 ~ 2147483647。如果需要更大的整数范围，可以使用long类型，它占用8个字节（64位），可以表示更大的整数范围



### 讲一下常见编码方式

- 编码的意义：计算机中存储的最小单元是一个字节即8bit，所能表示的字符范围是255个，而人类要表示的符号太多，无法用一个字节来完全表示，固需要将符号编码，将各种语言翻译成计算机能懂的语言。

- ASCII码：共有128个，用一个字节的低7位表示

- ISO8859-1：在ASCII码的基础上涵盖了大多数西欧语言字符，仍然是单字节编码，它总共能表示256个字符

- GB2312：双字节编码，总编码范围是A1-A7,A1-A9是符号区，包含682个字符，B0-B7是汉字区，包含6763个汉字

- GBK：为了扩展GB2312,加入了更多的汉字，编码范围是8140~FEFE，有23940个码位，能表示21003个汉字

- UTF-16：具体定义了Unicode字符在计算机中的存取方法。采用2字节来表示Unicode转化格式，它是定长的表示方法，不论什么字符都可以用两个字节表示

- UTF-8：  UTF-16统一采用两字节表示一个字符，但有些字符只用一个字节就可表示，浪费存储空间，而UTF-8采用一种变长技术，每个编码区域有不同的字码长度。 不同类型的字符可以由1~6个字节组成

  ​                  如果一个字节，最高位为0，表示这是一个ASCII字符（00~7F）
  ​                  如果一个字节，以11开头，连续的1的个数暗示这个字符的字节数 



### 多态

通过多态的使用，可以使代码更加灵活，提高代码的可维护性和可扩展性。多态的实现方式在Java中是通过继承、接口和抽象类等机制来实现的。在使用多态时，需要注意继承、方法重写和访问修饰符等细节问题

- 多态是指父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作 作用于不同对象，产生不同的执行结果
- 多态的三个条件：继承父类，重写父类方法，父类引用指向子类对象
- *实现多态的技术称为*动态绑定，在执行期间判断所 引用对象的实际类型，根据其实际的类型调用其相应的方法
- 多态的好处：可扩充
- Java 中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方 法重载



### 抽象类的意义

- 抽象方法必须为public或者protected
- 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类



### 接口的意义

- 接口中的变量会被隐式地指定为public static final变量
- 方法会被隐式地指定为public abstract方法
- java8之后可以用static，default写方法体





### 接口和抽象类的区别

1. 定义方式：接口使用interface关键字定义，而抽象类使用abstract关键字定义。
2. 实现方式：类可以实现多个接口，但只能继承一个抽象类。
3. 成员变量：接口中只能定义静态常量，而抽象类中可以定义静态常量、实例变量和静态变量。
4. 方法实现：接口中的方法都是抽象的，只有方法签名，没有方法实现。而抽象类中可以定义抽象方法和非抽象方法，其中抽象方法没有方法体，非抽象方法有方法体。
5. 构造方法：接口没有构造方法，而抽象类有构造方法，可以被子类调用。
6. 使用范围：接口主要用于定义标准，强制实现某些行为，而抽象类则用于封装公共的功能和属性，提供默认的实现。
7. 实现继承关系：接口只能实现继承，即实现接口的类必须实现接口中所有的抽象方法。而抽象类可以被子类继承并扩展，子类可以选择性地实现抽象方法。

总的来说，接口用于定义标准和规范，强制实现某些行为；而抽象类则用于封装公共的功能和属性，提供默认的实现



### Comparable和Comparator

二者都是用来实现对象的比较、排序，Comparable 是在`集合内部`定义的方法实现的排序，Comparator 是在`集合外部`实现的排序

1. 内部排序调用 `Collections.sort(list);` ，外部排序则使用 `list.sort(Comparator 类型的参数)` 
2. 若一个类实现了Comparable接口，就意味着该类支持排序，而Comparator是比较器，若需要控制某个类的次序，可以建立一个该类的比较器来进行排序
3. 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码



Comparable：

```java
package java.lang;
import java.util.*;

public interface Comparable<T> {
  // 通过 x.compareTo(y) 来“比较x和y的大小”
	// 若返回“负数”，意味着“x比y小”
	// 返回“零”，意味着“x等于y”
	// 返回“正数”，意味着“x大于y”
    public int compareTo(T o);
}
```



Comparator：

```java
package java.util;

public interface Comparator<T> {

  	// 返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”
    int compare(T o1, T o2);

    boolean equals(Object obj);
}
```



1. Comparable 可以看作是“对内”进行排序接口，而 Comparator 是“对外”进行排序的接口
2. Comparable 是通过重写 compareTo 方法实现排序的，而 Comparator 是通过重写 compare 方法实现排序
3. Comparable 必须由自定义类内部实现排序方法，而 Comparator 是外部定义并实现排序的



### Collections.sort/Arrays.sort

1. Collections.sort，对集合排序，需要继承Comparable重写compareTo方法，若没有重写可传入Comparator外部排序实现

   ```java
   		@SuppressWarnings("unchecked")
       public static <T extends Comparable<? super T>> void sort(List<T> list) {
           list.sort(null);
       }
       @SuppressWarnings({"unchecked", "rawtypes"})
       public static <T> void sort(List<T> list, Comparator<? super T> c) {
           list.sort(c);
       }
   ```

2. Arrays.sort，对数组排序

3. Collections.sort实质上是调用的Arrays.sort



### 6.Wait / Sleep / Yield方法的区别

三个方法都可以用来暂停线程，区别：

1. wait 是 Object 中的方法，而sleep/yield是Thread中的方法
2. 调用 wait 时会释放锁并让出cpu，而调用sleep/yield不会释放锁，只让出cpu
3. 调用 wait 之后，别的线程调用该 Object 的 notify/notifyAll 之后，才有机会获得cpu和锁，而sleep/yield再次获得cpu之后就可以继续运行
4. 调用sleep之后会被阻塞挂起指定的时间，线程调度器不会去调度该线程，而yield则是让出剩余时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器很有可能会调度执行该线程





### Java序列化与反序列化

Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：

1. 序列化：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。
2. 反序列化：客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象



### 11.序列化与反序列化的好处

1. 对象序列化可以实现分布式对象
2. java对象序列化可以递归保存对象引用的每个对象的数据
3. 序列化可以将内存中的类写入文件或数据库中
4. 对象、文件、数据，有许多不同的格式，很难统一传输和保存，序列化以后就都是字节流了，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件



### 12.如何实现Java序列化与反序列化

```java
// 实现 Serializabel接口
public class Person implements Serializable {
    // ...
}


public static void main(String[] args) throws Exception {
    //序列化后生成指定文件路径
    File file = new File("path");
    ObjectOutputStream oos = null;
    
    //装饰流
    oos = new ObjectOutputStream(new FileOutputStream(file));

    //实例化类
    Person per = new Person();
    oos.writeObject(per); //把类对象序列化
    oos.close();
}
```







### IO的理解，NIO，BIO

IO通常指从设备（例如硬盘、网络、键盘等）读取数据到内存中，或将数据从内存写入到设备中的过程

1. BIO是阻塞式IO/Blocking IO，在进行IO操作时会一直阻塞当前线程，直到数据准备好或者超时才会返回结果

   BIO适用于连接数较少的场景，但对于连接数较多的高并发应用来说，由于每个连接都需要独立的线程来处理IO事件，因此会导致资源消耗严重和可扩展性差的问题。

2. NIO是非阻塞式IO/Non-blocking IO，在进行IO操作时不会阻塞当前线程，而是通过轮询方式查询IO操作是否完成，如果没有完成则可以去做其他事情

   NIO适用于连接数较多的高并发应用场景，它的优势在于单个线程可以处理多个连接的IO事件，因此可以大大降低系统开销和提升系统的可扩展性

3. AIO/Asynchronous IO，也叫做NIO.2，它采用异步回调的方式实现IO操作，在IO操作完成后通过回调函数通知应用程序处理结果。AIO适用于处理大文件、大数据量的场景，具有更高的性能和更低的资源消耗





### 14.IO同步、异步、阻塞、非阻塞的区别

1. 同步和异步的区别在于是否要等待IO完成
2. 阻塞和非阻塞的区别在于等待IO完成期间能否做其他事情







### 19.ClassNotFoundException 和 NoClassDefFoundError 有什么区别

| ClassNotFoundException                                       | NoClassDefFoundError                          |
| ------------------------------------------------------------ | --------------------------------------------- |
| 继承自 `java.lang.Exception`                                 | 继承自 `java.lang.Error`                      |
| 当动态加载Class时找不到类会抛出异常                          | 当编译成功后，执行过程中找不到Class抛出该错误 |
| 一般在执行`Class.forName()`，`ClassLoader.loadClass()`以及使用`ClassLoader.findSystemClass()` 时抛出异常 | 由JVM运行时，系统抛出                         |





### 20.Java中的4种引用类型

强引用、软引用、弱引用、虚引用





### 21.Java中常见的8种锁

#### 公平锁/非公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁，非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，非公平锁会造成优先级反转或者饥饿现象

1. 对于Java `ReentrantLock`而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大
2. 对于`Synchronized`而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁



#### 可重入锁

可重入锁又名递归锁，是指在同一个线程可以多次获得同一个锁

1. 对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁
2. 对于Synchronized而言，也是一个可重入锁，可重入锁的一个好处是可一定程度避免死锁



#### 独享锁/共享锁

独享锁是指该锁一次只能被一个线程所持有，Synchronized / ReentrantLock是独享锁，共享锁是指该锁可被多个线程所持有，Lock的另一个实现类`ReadWriteLock`，其读锁是共享锁，其写锁是独享锁

1. 读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的
2. 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享



#### 互斥锁/读写锁

独享锁/共享锁只是一种广义的说法，互斥锁/读写锁就是具体的实现：

1. 互斥锁在Java中的具体实现就是`ReentrantLock`
2. 读写锁在Java中的具体实现就是`ReadWriteLock`



#### 乐观锁/悲观锁

1. 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题

2. 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的

3. 悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升

   悲观锁在Java中的使用，就是利用各种锁

4. 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新



#### 分段锁

分段锁其实是一种锁的设计，并不是具体的一种锁，对于`ConcurrentHashMap`而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作，以ConcurrentHashMap来说一下分段锁的含义以及设计思想：

1. `ConcurrentHashMap`中的分段锁称为Segment，它即类似于HashMap的结构，内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock，因为Segment继承了`ReentrantLock`
2. 当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入
3. 但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作



#### 偏向锁/轻量级锁/重量级锁



#### 自旋锁

在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU







### 25.Java 内存模型JMM 

JMM 规定了线程的工作内存和主内存的交互关系，以及线程之间的可见性和程序的执行顺序：

1. 一方面，要为程序员提供足够强的内存可见性保证
2. 另一方面，对编译器和处理器的限制要尽可能地放松。JMM 对程序员屏蔽了 CPU 以及 OS 内存的使用问题，能够使程序在不同的 CPU 和 OS 内存上都能够达到预期的效果

Java 采用内存共享的模式来实现线程之间的通信。编译器和处理器可以对程序进行重排序优化处理，但是需要遵守一些规则，不能随意重排序

jmm用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量

JMM 是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的







### 32.深拷贝和浅拷贝

浅拷贝是指将一个对象复制到另一个对象，但复制过程中只复制对象的引用，而不复制对象内部的数据。也就是说，新的对象中的变量指向的是原始对象中的数据，两个对象中如果其中一个对象的数据被修改了，另一个对象也会改变

在java中实现 `Cloneable`，重写 clone()就可以实现浅拷贝：

```java
@Override
protected Line clone() throws CloneNotSupportedException {
    return (Line)super.clone();
}
```



深拷贝是指将一个对象复制到另一个对象，但复制过程中不仅复制对象的引用，而且复制对象内部的数据。也就是说，新的对象与原始对象完全独立，两者之间互不干扰，因此即使一个对象的数据被修改了，另一个对象也不会改变，深拷贝的两种实现方式：

```java
@Override
protected Header clone() throws CloneNotSupportedException {
    Header header = (Header) super.clone();
    Line line = header.getLine().clone();
    header.setLine(line);
    return header;
}

// 序列化，实现 Serializable 接口，当前对象和引用对象都要实现该接口
public Header deepClone () {

    ByteArrayOutputStream bos  = null;
    ObjectOutputStream oos = null;

    ByteArrayInputStream bis = null;
    ObjectInputStream ois = null;

    try {

        bos = new ByteArrayOutputStream();
        oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        bis = new ByteArrayInputStream(bos.toByteArray());
        ois = new ObjectInputStream(bis);
        return (Header) ois.readObject();

    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            bos.close();
            oos.close();
            bis.close();
            ois.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return null;
}
```





### 33.Java 异常

- 所有异常类的基类是Throwable类，两大子类分别是Error和Exception

- 异常又分为RuntimeException和CheckedException，检查时异常如IOException, FileNotFoundException

- Error是程序无法处理的错误，由JVM产生和抛出的，比如OutOfMemoryError，ThreadDeath等，这些异常发生时，Java虚拟机一般会选择线程终止

- 异常处理：throws，throw，try，catch，finnaly

  

#### Throwable

`Throwable` 是 Java 语言中所有错误与异常的超类， 包含两个子类：Error 和 Exception，它们通常用于指示发生了异常情况，提供了 `printStackTrace()` 等接口用于获取堆栈跟踪数据等信息



#### Error

程序中无法处理的错误，表示运行应用程序中出现了严重的错误，此类错误一般表示代码运行时 JVM 出现问题，通常有 `Virtual MachineError` 虚拟机运行错误、`NoClassDefFoundError` 类定义错误， `OutOfMemoryError` 内存不足，`StackOverflowError` 栈溢出错误，此类错误发生时，JVM 将终止线程



#### Exception

程序本身可以捕获并且可以处理的异常，分为运行时异常和编译时异常

1. 运行时异常：RuntimeException 类及其子类，Java 编译器不会检查它没有通过throws声明抛出它，也没有用try-catch语句捕获它，还是会编译通过，如 `NullPointerException ArrayIndexOutBoundException ClassCastException` 
2. 编译时异常：除 RuntimeException 及其子类之外的异常，必须手动在代码里添加`try-catch`捕获语句来处理该异常，否则不能通过编译，如`SQLException  IOException  FileNotFoundException  ClassNotFoundException`





### 34.Error 和 Exception 区别

Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复

Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行





### 35.final、finally、finalize 有什么区别

1. final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值
2. finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码
3. `finalize()`是Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作



### 36.try-catch-finally 中哪个部分可以省略

catch



### 37.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗

会执行，在 return 前执行



### 38.SimpleDateFormat 的线程安全问题

定义为static 的SimpleDateFormat存在线程安全问题

SimpleDateFormat 继承 DateFormat ,DateFormat 有一个成员变量 `calendar`：

SimpleDateFormat中的format方法在执行过程中，会使用一个成员变量calendar来保存时间。这其实就是问题的关键：

```java
private StringBuffer format(Date date, StringBuffer toAppendTo,
                                FieldDelegate delegate) {
        // Convert input date to time field list
        calendar.setTime(date);
  			// ...
}
```



声明SimpleDateFormat的时候，使用的是static定义的，那么这个SimpleDateFormat就是一个共享变量，随之，SimpleDateFormat中的calendar也就可以被多个线程访问到，假设线程1刚刚执行完calendar.setTime把时间设置成2018-11-11，还没等执行完，线程2又执行了calendar.setTime把时间改成了2018-12-12。这时候线程1继续往下执行，拿到的calendar.getTime得到的时间就是线程2改过之后的





### 40.new 一个对象 JVM做了什么

1. 首先去常量池中看能否根据这个类的全路径找到这个类的信息，查看是否加载过，解析，初始化过。如果没有，则先进行类加载过程
2. 接下来JVM从堆内存里为新的对象分配内存，对象所需的内存大小在类加载的时候就可以完全确定





### 41.new String("123") 创建了几个对象

1. 如果方法区的常量池中，已经存在`123`，则只需在堆里创建一个对象就行，栈里的变量引用指向堆
2. 如果常量池中不存在`123`，先在常量池中创建，然后在堆里new一个对象，栈里的变量引用指向堆





### 说一下泛型原理，并举例说明

泛型原理是指在编写代码时，允许参数类型（或返回类型）可以被指定为某个特定类型的变量，而不是具体的数据类型。泛型通常使用类型参数来实现，允许在调用泛型时指定实际的类型。这允许我们编写更灵活、可重用的代码，提高了程序的可读性和可维护性

```java
List<String>  list  =  new  ArrayList<>();
```





### 泛型中extends和super的区别

- `<? extends Fruit>`代表上界通配符，List中存放的对象都是Fruit以及其子类对象，由于不能确定List中是Fruit还是其子类对象，所以add的时候会报错，`确切的说不能add除了null以外的所有对象，包括object`

  ```java
  public void call(List<? extends Fruit> fruits) {
    for (Fruit fruit: fruits) {
      // ...
    }
  }
  
  public static void main(String[] args) {
    List<Banana> bananaList = new ArrayList<>();
    // 编译通过，若call方法中的参数直接写List<Fruit>会编译不通过
    new Fruit().call(bananaList);
  }

- super与extends是完全相反的，其定义的是下界通配符，`List<? super Fruit>`存放的是Fruit和它的父类的对象，如Object等，只能添加Fruit类型及其子类对象，并且取出的数据类型都为Object

  ```java
  public void call(List<? super Fruit> fruits) {
    fruits.add(new Fruit());
    fruits.add(new Banana());
    // 遍历的类型都为Object
    for (Object fruit : fruits) {
      // ... 
    }
  }
  ```

  



### 静态属性和静态方法能不能被继承和重写，为什么

- 静态属性和静态方法是可以被子类继承的，但静态属性和方法不能被子类重写
- 静态成员属于类本身，而不是类的实例，因此在子类中并不创建静态成员的副本，而是直接继承父类的静态成员。而重写是针对实例方法的，因为实例方法是根据对象的实际类型来调用的，所以子类可以根据需要重新实现它们。但是静态成员是基于类本身而不是基于对象的，因此它们不受继承机制的影响，也不能被重写
- 子类可以使用父类的静态成员，包括静态属性和静态方法。这是因为静态成员是公共的，可以被类和它的实例访问。但是，建议在访问静态成员时使用类名来引用它们，而不是使用实例变量。因为静态成员是属于类本身的，而不是实例，使用实例变量访问静态成员可能会导致混淆和意外的行为





### 注解

- 注解是通过@interface关键字来进行定义的，形式和接口差不多，只是前面多了一个@
- 要使注解能正常工作，还需要使用元注解，它是可以注解到注解上的注解，元标签有@Retention @Documented @Target @Inherited @Repeatable五种
- @Retention说明注解的存活时间，取值有RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时被丢弃；RetentionPolicy.CLASS 注解只保留到编译进行的时候，并不会被加载到JVM中，RetentionPolicy.RUNTIME可以留到程序运行的时候，它会被加载进入到JVM中，所以在程序运行时可以获取到它们
- @Target 限定注解的应用场景，ElementType.FIELD给属性进行注解；ElementType.LOCAL_VARIABLE可以给局部变量进行注解；ElementType.METHOD可以给方法进行注解；ElementType.PACKAGE可以给一个包进行注解 ElementType.TYPE可以给一个类型进行注解，如类、接口、枚举



- 何时执行：`@Retention(RetentionPolicy.RUNTIME)`
- 作用对象：`@Target(ElementType.TYPE)` 



### 序列化的方式

序列化是将数据结构或对象转换为可存储或传输的格式的过程，常见的序列化方式包括：

1. JSON：一种轻量级的文本数据交换格式，易于阅读和编写，支持多种编程语言。
2. XML：一种标记语言，用于存储和传输数据，具有良好的跨平台性和扩展性。
3. YAML：一种人类友好的数据序列化格式，易于阅读和编写，支持多种编程语言





### 静态代理和动态代理的区别

- 静态代理中的代理类是由程序员编写的，执行之前就已经存在class文件，而且一般来说一个代理类只能代理一个目标对象，静态代理要求代理类和目标类都实现同一接口，代码冗余高
- 动态代理则是根据程序的运行时动态的生成代理类，可以通过反射或者就修改字节码的生成代理类，如jdk，cglib动态代理

`代理解决的问题是当两个类需要通信时，引入第三方代理类，将两个类的关系解耦，代理类和委托类要实现相同的接口，因为代理真正调用的还是委托类的方法` 

- 静态代理：由程序员创建或特定工具自动生成源代码，再对其编译，在程序运行之前，代理类的class类文件就已经被创建了，静态代理通常只代理一个类，需要实现接口，造成代码冗余，只能对固定接口的实现类实现代理，灵活性较差

- 动态代理：在程序运行时通过反射机制动态创建代理类，动态代理代理的是一个接口下的多个实现类，只需将被委托类作为参数传入即可，使用灵活；服务内容只需写在invoke方法中，但效率低

- 动态代理基于JDK实现：通过JDK提供的工具方法Proxy.newProxyInstance动态构建全新的代理类（继承Proxy类，并持有InvocationHandler接口引用）字节码文件并实例化对象返回。由Java内部的反射机制来实例化代理对象，并代理的调用委托类方法

  ```java
 Proxy.newProxyInstance(
                  被代理类.getClass().getClassLoader(),
                  被代理类.getClass().getInterfaces(), 
                  this);
  ```

  

- 动态代理基于CGlib实现：基于继承被代理类生成代理子类，不用实现接口，只需被代理类为非final类，底层借用ASM字节码技术实现

- 动态代理基于AspectJ实现：修改目标类的字节，织入代理的字节，在程序编译的时候，插入动态代理的字节码，不会生成全新的class





### 解析与分派

- ###### 解析：指方法在运行前，即编译期间就可知的，有一个确定的版本，运行期间也不会改变。解析是静态的，在类加载的解析阶段就可将符号引用转变成直接引用

- ###### 分派：可分为静态分派和动态分派，重载属于静态分派，覆盖属于动态分派。 静态分派是指在重载时通过参数的静态类型而非实际类型作为判断依据，在编译阶段，编译器可根据参数的静态类型决定使用哪一个重载版本。 动态分派则需要根据实际类型来调用相应的方法



### 如何将一个Java对象序列化到文件里

- `ObjectOutputStream.writeObject()`负责将指定的流写入，`ObjectInputStream.readObject()`从指定流读取序列化数据

  ```java
  //写入
  try {
      ObjectOutputStream os = new ObjectOutputStream(
        new FileOutputStream("D:/student.txt")
      );
      os.writeObject(studentList);
      os.close();
  } catch(FileNotFoundException e) {
      e.printStackTrace();
  } catch(IOException e) {
      e.printStackTrace();
  }
  ```
  
  

### 反射

- 在运行状态中，对任意一个类，都能知道这个类的所有属性和方法，对任意一个对象，都能调用它的任意一个方法和属性，这种能动态获取信息及动态调用对象方法的功能称为java语言的反射机制
- 开发过程中，经常会遇到某个类的某个成员变量、方法或属性是私有的，或只对系统应用开放，这里就可以利用java的反射机制通过反射来获取所需的私有成员或是方法
- 带有Declared修饰的方法可以反射到私有的方法，没有Declared修饰的只能用来反射公有的方法



### transient

Java中`transient`关键字的作用，就是让某些被修饰的成员属性变量不被序列化





## 集合

### 集合类以及集合框架

Java集合类是Java编程语言中提供的一组数据结构，用于存储和操作一组对象。Java集合框架是由一组接口、类和算法组成的，用于表示和操作集合类。

Java集合框架包括以下接口：Collection、List、Set、Map、Queue、Deque等。其中，Collection是所有集合类的根接口，List表示有序的集合（即可以按照添加顺序访问元素），Set表示无序且不重复的集合，Map表示键值对映射，Queue表示先进先出队列，Deque表示双向队列。

Java集合类主要有ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap等。其中，ArrayList和LinkedList都实现了List接口，HashSet和TreeSet实现了Set接口，HashMap和TreeMap实现了Map接口。这些集合类提供了各种方法，如添加、删除、查找、排序等，以便开发人员在程序中高效地处理数据集合



### 容器类介绍以及之间的区别

容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 [Java容器类](http://alexyyek.github.io/2015/04/06/Collection/) 





### 列举java的集合以及集合之间的继承关系

```java
# Java集合类继承关系
- Collection
  - List
    - ArrayList
    - LinkedList
  - Set
    - HashSet
      - LinkedHashSet
    - SortedSet
      - TreeSet
  - Queue
    - Deque
      - ArrayDeque
      - LinkedList
    - PriorityQueue
- Map
  - SortedMap
    - TreeMap
  - HashMap
    - LinkedHashMap

```





### ArrayList

默认容量为10，当容量变为10时，扩容为原来的1.5倍，扩容的公式为 ：

```java
int newCapacity = oldCapacity + (oldCapacity >> 1);
```





### ArrayList 和 LinkedList 的区别，以及应用场景

1. ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构
2. 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针
3. 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据



### ArrayList 和 Vector 的区别

1. 同步性：Vector是线程安全的，而ArrayList是线程序不安全的，ArrayList效率会高些
2. 数据增长性：Vector默认增长为原来两倍，而ArrayList增长为原来的1.5倍，ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法



### Array 和 ArrayList 的区别

1. Array 可以包含基本数据类型和引用类型，ArrayList只能包含引用类型
2. ArrayList是基于数组实现的，Array大小不可以调整，但ArrayList可以通过内部方法自动调整容量
3. ArrayList是List接口的实现类，相比Array支持更多的方法和特性



### HashSet 的实现原理

1. HashSet是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 `PRESENT`，它是一个静态的 Object 对象
2. 要将某个对象放入HashSet中时，要重写该类的equals(Object obj)方法和 hashCode() 方法
3. HashSet的其他操作都是基于HashMap的



### List如何一边遍历，一边删除

```java
public static void main(String[] args) {
    List<String> platformList = new ArrayList<>();
    platformList.add("博客园");
    platformList.add("CSDN");
    platformList.add("掘金");

    // 使用迭代器删除
    Iterator<String> iterator = platformList.iterator();
    while (iterator.hasNext()) {
        String platform = iterator.next();
        if (platform.equals("博客园")) {
            iterator.remove();
        }
    }
    
    // 正序删除
    for (int i = 0; i < platformList.size(); i++) {
        String item = platformList.get(i);

        if (item.equals("博客园")) {
            platformList.remove(i);
            i = i - 1;
        }
    }
        
    // 倒叙删除
    for (int i = platformList.size() - 1; i >= 0; i--) {
        String item = platformList.get(i);

        if (item.equals("掘金")) {
            platformList.remove(i);
        }
    }

    System.out.println(platformList);
}


```





### Iterater和ListIterator的区别

1. 来遍历Set和List集合，而ListIterator只能遍历List
2. Iterator只能往后遍历，而LIstIterator可以双向遍历
3. ListIterator从Iterator接口继承，添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置





### fail-fast

每次尝试获取下一个元素的时候，Iterator `fail-fast` 属性检查当前集合结构里的任何改动，如果发现任何改动，它抛出`ConcurrentModificationException`，Collection中所有Iterator的实现都是按fail-fast来设计的，ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外

`fail—fast`迭代器抛出ConcurrentModificationException

`fail—safe`迭代器从不抛出ConcurrentModificationException，java.util.concurrent中的集合类都为fail-safe的，所以可以使用juc下的并发集合类避免这种异常





### List,Set,Map的区别

List的元素以线性方式存储，有序而且可以存放重复对象，List主要有以下两个实现类：

1. ArrayList：长度可变的数组，可以对元素进行随机的访问，向ArrayList中插入与删除元素的速度慢。JDK8中ArrayList扩容的实现是通过`grow()`方法里使用语句`newCapacity = oldCapacity + (oldCapacity >> 1)`（即1.5倍扩容）计算容量，然后调用`Arrays.copyof()`方法进行对原数组进行复制
2. LinkedList: 采用链表数据结构，插入和删除速度快，但访问速度慢



Set中的对象无序，并且没有重复对象，Set主要有以下两个实现类：

1. HashSet：HashSet按照哈希算法来存取集合中的对象，存取速度比较快
2. TreeSet：TreeSet实现了SortedSet接口，能够对集合中的对象进行排序



Map是一种以键值对映射的集合，主要有以下实现类：

1. HashMap：HashMap基于散列表实现，其插入和查询`<K,V>`的开销是固定的，可以通过构造器设置容量和负载因子来调整容器的性能
2. LinkedHashMap：类似于HashMap，但是迭代遍历它时，取得`<K,V>`的顺序是其插入次序，或者是最近最少使用(LRU)的次序
3. TreeMap：基于红黑树实现。查看`<K,V>`时会被排序，TreeMap是唯一的带有`subMap()`方法的Map，`subMap()`可以返回一个子树



### HashMap 的底层结构

1. 1.7中采用数组+链表，1.8采用的是数组+链表/红黑树，链表长度超过一定长度后就改成红黑树存储。 
2. 1.7扩容时需要重新计算哈希值和索引位置，1.8并不重新计算哈希值，而是利用 key的hash值与旧数组长度做&操作，分成高低位两条链表，低位则在原来的位置，高位则移动到原来的位置+旧数组长度的位置
3. 1.7是采用表头插入法插入链表，1.8采用的是尾部插入法
4. 在1.7中采用表头插入法，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题；在1.8中采用尾部插入法，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了





### HashMap如何put数据

1. 往map插入元素的时候首先通过对key hash然后与数组长度-1进行与运算((n-1)&hash)，都是2的次幂所以等同于取模，但是位运算的效率更高
2. 找到数组中的位置之后，如果数组中没有元素直接存入，反之则判断key是否相同，key相同就覆盖，否则就会插入到链表的尾部
3. 如果链表的长度超过8，则会转换成红黑树
4. 最后判断数组长度是否超过默认的长度*负载因子也就是12，超过则进行扩容
5. 在第一次 put 的时候，调用 `resize()` 方法进行 table 的初始化，默认情况下`table.length = 16, threshold = 12`，能存放 12 个元素，当存放第 13 个元素后进行扩容

![](https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XDk1m8MBdwesZicKgricM5TicHSSmGXOtd3mVUX7VO2WSgXsFUBbpz85LIhah4AgYh9zqe29OicibMWcLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





### HashMap 扩容流程

[HashMap扩容流程[通俗易懂]](https://cloud.tencent.com/developer/article/2129161) 

1. 当 size > threshold 的时候进行扩容

2. 扩容之后的 table.length = 旧 table.length * 2

3. 扩容之后的 threshold = 旧 threshold * 2

   

JDK1.8 HashMap 扩容阶段重新映射元素时不需要像 1.7 版本那样重新去一个个计算元素的 hash 值，而是通过 `hash & oldCap` 的值来判断，若为 0 则索引位置不变，不为 0 则`新索引=原索引+旧数组长度`，因为指长度扩为原来 2 倍，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置

链表长度大于等于 8且table 数组长度大于等于 64才会转换成红黑树，因为当 table 数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长



### 为何HashMap的数组长度一定是2的次幂

HashMap 通过 `tableSizeFor()` 来返回大于等于输入参数且最近的 2 的整数次幂的数：

```java
/*找到大于或等于 cap 的最小2的幂，用来做容量阈值*/  
static final int tableSizeFor(int cap) {  
    int n = cap - 1;  
    n |= n >>> 1;  
    n |= n >>> 2;  
    n |= n >>> 4;  
    n |= n >>> 8;  
    n |= n >>> 16;  
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;  
}
```

设置成2次幂的好处：

1. 可以使用位运算来计算元素在数组中的下标

   HashMap 是通过 `index=hash&(table.length-1)` 来计算元素在 table 数组中存放的下标，这条公式其实等价于 `hash%table.length-1`，只不过只有当数组长度为 2 的幂次方时，hash&(length-1) 才等价于 hash%length，使用位运算可以提高效率

2. 增加 hash 值的随机性，减少 hash 冲突

   如果 length 为 2 的幂次方，则 length-1 转化为二进制必定是 11111……的形式，这样的话可以使所有位置都能和元素 hash 值做与运算



### 为什么HashMap加载因子的默认值是 0.75

1. 如果loadFactor太小，那么map中的table需要不断的扩容，扩容是个耗时的过程
2. 如果loadFactor太大，那么map中table放满了也不不会扩容，导致冲突越来越多，解决冲突而起的链表越来越长，效率越来越低



### HashMap 边遍历边删除 fail-fast异常

在遍历 HashMap 的时候，若使用 remove 方法删除元素时会抛出 `ConcurrentModificationException` 异常

 HashMap 中有一个名为 modCount 的变量，它用来表示集合被修改的次数，修改指的是插入元素或删除元素，在遍历 HashMap 时，每次遍历下一个元素前都会对 modCount 进行判断，若和原来的不一致说明集合结果被修改过了，然后就会抛出异常



### Map map = new HashMap(1000)什么时候扩容

此时的 table.length = 2^10 = 1024; threshold = 1024 * 0.75 = 768; 所以存入第 769 个元素时进行扩容



### Map map = new HashMap(10000) 存入第 10001个元素时会触发 扩容吗

此时的 table.length = 2^14 = 16384; threshold = 16384 * 0.75 = 12288; 所以存入第 10001 个元素时不会进行扩容



### 手写hashmap需要注意什么

- key在数组中的位置，减少hash冲突
- 扩容阈值
- 何时将链表转红黑树
- 初始容量，加载因子



### HashTable实现原理

HashTable相对于HashMap的最大特点就是线程安全，所有的操作都是被`synchronized`锁保护的





### HashMap 为什么不是线程安全的

1. 在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失
2. 在jdk1.8中，在多线程环境下，会发生数据覆盖的情况





### HashMap / TreeMap

1. `TreeMap<K,V>`的Key值要求实现`java.lang.Comparable` （或者在新建时传入comparator），所以迭代的时候TreeMap默认是按照Key值升序排序的

   ```java
   public TreeMap() {
     comparator = null;
   }
   
   
   public TreeMap(Comparator<? super K> comparator) {
     this.comparator = comparator;
   }
   ```

   

2. TreeMap的实现是基于红黑树结构，TreeMap没有调优选项/加载因子，因为该树总处于平衡状态

3. `HashMap<K,V>`的Key值实现散列`hashCode()`，分布是散列的、均匀的，不支持排序；数据结构主要是数组，链表或红黑树。适用于在Map中插入、删除和定位元素

4. HashMap 和 TreeMap 都是非线程安全，HashMap继承AbstractMap抽象类，TreeMap继承自SortedMap接口

5. TreeMap中默认是按照升序进行排序的，要想倒叙可通过自定义的比较器来实现，在返回时多添加了个负号，就将比较的结果以相反的形式返回：

   ```java
   static class MyComparator implements Comparator{
       @Override
       public int compare(Object o1, Object o2) {
           // TODO Auto-generated method stub
           String param1 = (String)o1;
           String param2 = (String)o2;
           return -param1.compareTo(param2);
       }   
   }
   ```

   



### HashMap和HashTable的区别

主要区别：

1. 线程安全：HashTable是线程安全的，而HashMap是非线程安全的。
2. 效率：Hashtable在并发环境下效率较低，而HashMap在并发环境下效率较高。
3. null键值：Hashtable不允许键或值为null，而HashMap则可以。
4. 迭代器：HashMap的迭代器是fail-fast迭代器，而Hashtable的迭代器不是。
5. 继承关系：Hashtable是Dictionary类的子类，而HashMap是AbstractMap类的子类。
6. 扩容机制：Hashtable采用的是增加两倍的方式扩容，而HashMap采用的是增加一倍的方式扩容。
9. 数据结构：Hashtable使用的是链表数组结构，而HashMap使用的是链表和红黑树结构，当链表长度超过阈值时，会转化为红黑树，以提高搜索效率。



### HashMap与HashSet的区别

HashSet是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 `PRESENT`，它是一个静态的 Object 对象



### HashSet与HashMap怎么判断集合元素重复

hashcode



### 集合Set实现Hash怎么防止碰撞

链表/红黑树





### Hashmap为什么用红黑树，红黑树的优缺点，为什么不用avl树

- 红黑树不追求"完全平衡"，不像AVL那样要求左右子树高度它相差1，只要求部分达到平衡，但是提出了为节点增加颜色，`任何不平衡都会在三次旋转之内解决`，而AVL是严格平衡树，因此在增加或者删除节点时，旋转的次数可能比红黑树要多



### 经常用到哪些 Map，这几种 Map 的区别

HashMap，LinkedHashMap，ConcurrentHashMap



### Map、List、Set 分别说下你知道的线程安全类和线程不安全的类

```
HashTable，Collections.synchronizedMap()，ConcurrentHashMap

Vector，Collections.synchronizedList(List< T> list)，CopyOnWriteArrayList

Collections.synchronizedSet()，Collections.newSetFromMap()，CopyOnWriteArraySet，ConcurrentHashMap.newKeySet()

```



### 常用并发集合了解哪些

ConcurrentHashMap，CopyOnWriteArrayList，CopyOnWriteArraySet，ConcurrentSkipListMap，ConcurrentLinkedQueue





### ConcurrentHashMap 底层结构

JDK1.7 中的 ConcurrentHashMap 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成，即 ConcurrentHashMap 把哈希桶数组切分成小数组Segment，每个小数组有 n 个 HashEntry 组成

![](https://img2020.cnblogs.com/other/2283341/202101/2283341-20210126111703956-642010540.png)



```java
// Segment 继承了 ReentrantLock，所以 Segment 是一个可重入锁，Segment 默认为 16，也就是并发度为 16
static class Segment<K,V> extends ReentrantLock implements Serializable {
  private static final long serialVersionUID = 2249069246763182397L;

  transient volatile HashEntry<K,V>[] table;
  
  // 元素的个数，这里没有加volatile修饰，所以只能在加锁或者确保可见性
  // 如Unsafe.getObjectVolatile的情况下进行访问，不然无法保证数据的正确性
  transient int count;

  // segment元素修改次数记录，由于未进行volatile修饰，所以访问规则和count类似
  transient int modCount;

  // 扩容指标
  transient int threshold;

  // 负载因子
  final float loadFactor;

}

static final class HashEntry<K,V> {
  final int hash;
  final K key;
  // 用 volatile 修饰了 HashEntry 的数据 value 和 下一个节点 next
  // 保证了多线程环境下数据获取时的可见性
  volatile V value;
  volatile HashEntry<K,V> next;
}
```





 JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的Node数组+链表+红黑树结构，在锁的实现上，抛弃了原有的 Segment 分段锁，采用`CAS + synchronized`实现更加细粒度的锁，只锁住这个链表头节点或红黑树的根节点，就不会影响其他的哈希桶数组元素的读写，大大提高了并发度

![](https://img2020.cnblogs.com/other/2283341/202101/2283341-20210126111704792-1503647637.png)



### ConcurrentHashMap的实现原理

Jdk1.7 中采用分段锁和 HashEntry 使锁更加细化，ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量）的线程并发



Jdk1.8 利用 CAS+Synchronized 来保证并发更新的安全，当然底层采用数组+链表+红黑树的存储结构

1. table 中存放 Node 节点数据，默认 Node 数据大小为 16，扩容大小总是 2^N
2. 为了保证可见性，Node 节点中的 val 和 next 节点都用 volatile 修饰
3. 当链表长度大于 8 时，会转换成红黑树，节点会被包装成 TreeNode放在TreeBin 中
4. put()：1. 计算键所对应的 hash 值；2. 如果哈希表还未初始化，调用 initTable() 初始化，否则在 table 中找到 index 位置，并通过 CAS 添加节点。如果链表节点数目超过 8，则将链表转换为红黑树。如果节点总数超过阈值，则进行扩容操作
5. get()：无需加锁，直接根据 key 的 hash 值遍历 node



### ConcurrentHashMap是何保证线程安全

1. 在1.8中ConcurrentHashMap的get操作全程不需要加锁，这也是它比其他并发集合比如hashtable、用Collections.synchronizedMap()包装的hashmap;安全效率高的原因之一
2. get操作全程不需要加锁是因为Node的成员val是用volatile修饰的和数组用volatile修饰没有关系
3. 数组用volatile修饰主要是保证在数组扩容的时候保证可见性



### CocurrentHashMap 在 JDK 1.8 前后的锁有什么区别

在JDK 1.8之前，ConcurrentHashMap使用分段锁来保证线程安全，ConcurrentHashMap将底层数据结构分成许多小的Segment，每个段都有自己的锁，在多线程环境中，只有在访问相同段时才需要竞争锁

在JDK 1.8及以后版本中，ConcurrentHashMap不再使用分段锁 Segment，使用 CAS+Synchronized，其中CAS操作用于更新桶数组中的元素，而Synchronized用于控制整个桶数组的并发访问，减少了锁的粒度，从而提高了性能



### CocurrentHashMap 在 JDK 1.8 有什么改变

1. 数据结构：1.7及之前使用 数组segment + 数组 hashEntry + 链表，1.8 数组 + 链表/红黑树
2. 锁：1.7及之前使用ReentrantLock，1.8及之后 cas + synchronized，锁的粒度更小，cas失败之后才会尝试加锁



### JDK 1.7 ConcurrentHashMap 的 put 方法

1. 先定位到相应的 Segment ，然后再进行 put 操作
2. 首先会尝试获取锁，如果获取失败，则利用 `scanAndLockForPut()` 自旋获取锁
3. 如果重试的次数达到了 `MAX_SCAN_RETRIES` 则改为阻塞锁获取，保证能获取成功





### JDK 1.8 ConcurrentHashMap 的 put 方法 [来源](https://www.cnblogs.com/cosen/p/14329331.html) 

1. 根据 key 计算出 hash 值
2. 判断是否需要进行初始化
3. 定位到 Node，拿到首节点 f，判断首节点 f：
   - 如果为 null ，则通过 CAS 的方式尝试添加
   - 如果为 `f.hash = MOVED = -1` ，说明其他线程在扩容，参与一起扩容
   - 如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入
4. 当在链表长度达到 8 的时候，数组扩容或者将链表转换为红黑树

![未命名.png](https://s2.loli.net/2023/04/10/L9PKS7tuhaMryZA.png)



### JDK 1.8 ConcurrentHashMap 的 initTable 方法

```java
// -1:正在初始化，-N：N-1个线程正在扩容，正数代表扩容阈值 table.length * 0.75
private transient volatile int sizeCtl;

private final Node<K,V>[] initTable() {
  Node<K,V>[] tab; int sc;
  while ((tab = table) == null || tab.length == 0) {
    // 保证只有一个线程正在进行初始化操作
    if ((sc = sizeCtl) < 0)
      Thread.yield(); 
    
    // cas将sizeCtl改成-1
    else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
      try {
        if ((tab = table) == null || tab.length == 0) {
          // 计算数组大小
          int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
          @SuppressWarnings("unchecked")
					// 初始化数组
          Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
          table = tab = nt;
          // 计算扩容阈值：实际大小n*0.75
          sc = n - (n >>> 2);
        }
      } finally {
        sizeCtl = sc;
      }
      break;
    }
  }
  return tab;
}
```





### JDK1.8 中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock

1. 在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁一步步转换
2. 减少内存开销 ，使用ReentrantLock，那么每个节点都需要通过继承 AQS 来获得同步支持，但并不是每个节点都需要获得同步支持的，只有链表的头节点或红黑树的根节点需要同步，这无疑带来了巨大内存浪费



### ConcurrentHashMap 的 get 方法是否要加锁

get 方法不需要加锁。因为 Node 的元素 value 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改节点的 value 或者新增节点的时候是对线程B可见的

这也是它比其他并发集合比如 Hashtable、Collections.synchronizedMap()包装的 HashMap 效率高的原因之一 



### get 方法不需要加锁与 volatile 修饰的哈希桶数组有关吗

没有关系，哈希桶数组`table`用 volatile 修饰主要是保证在数组扩容的时候保证可见性



### JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别

1. 数据结构：取消了 Segment 分段锁的数据结构，取而代之的是数组+链表/红黑树的结构
2. 保证线程安全机制：JDK1.7 采用 Segment 的分段锁机制实现线程安全，其中 Segment 继承自 ReentrantLock ，JDK1.8 采用`CAS+synchronized`保证线程安全
3. 锁的粒度：JDK1.7 是对需要进行数据操作的 Segment 加锁，JDK1.8 调整为对每个数组元素加锁（Node）
4. 链表转化为红黑树：定位节点的 hash 算法简化会带来弊端，hash 冲突加剧，因此在链表节点数量大于 8（且数据总量大于等于 64）时，会将链表转化为红黑树进行存储
5. 查询时间复杂度：从 JDK1.7的遍历链表O(n)， JDK1.8 变成遍历红黑树O(logN)



### ConcurrentHashMap 和 Hashtable 的效率哪个更高

ConcurrentHashMap 的效率要高于 Hashtable，因为 Hashtable 给整个哈希表加了一把大锁从而实现线程安全。而ConcurrentHashMap 的锁粒度更低，在 JDK1.7 中采用分段锁实现线程安全，在 JDK1.8 中采用`CAS+synchronized`实现线程安全



### JDK1.8 ConcurrentHashMap 扩容流程

1. 构建一个 nextTable,它的容量是原来的两倍，这个操作是单线程完成的

   ```java
   Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];
   ```

   

2. 将原来 table 中的元素复制到 nextTable 中，主要是遍历复制的过程，根据运算得到当前遍历的数组的位置 i，然后利用 `tabAt` 方法获得 i 位置的元素再进行判断：

   - 如果这个位置为空，就在`原 table` 中的 i 位置放入 `forwardNode` 节点，这个也是触发并发扩容的关键点
   - 如果这个位置是Node节点（fh>=0），则和HashMap一样将key的hash值和旧数据长度相与，0则在原来的位置，1则在 原来位置+旧数组长度 的位置
   - 如果这个位置是 TreeBin 节点（fh<0），判断是否需要 untreefi 后和Node节点一致，将数据分别放在 nextTable 的 i 和 i+n 的位置上
   - 遍历过所有的节点以后就完成了复制工作，这时让 nextTable 作为新的 table，并且更新 sizeCtl 为新容量的 0.75 倍 ，完成扩容







## 并发编程

### 进程和线程的区别

1. 拥有资源：进程是一个独立的执行环境，拥有自己的地址空间、文件句柄、信号处理等系统资源；而线程是在进程内部创建的，共享进程的资源。
2. 调度：进程是系统进行调度的基本单位，操作系统对进程进行调度和分配处理器时间片；而线程是由进程调度的基本单位，操作系统将进程中的多个线程分配给处理器执行。
3. 并发性：由于进程拥有独立的资源，不同进程之间的并发运行不会相互干扰，但进程之间的通信需要通过进程间通信（IPC）机制。而线程共享进程的资源，线程之间的并发运行可能会相互干扰，因此需要使用同步机制来保证线程安全。
4. 创建和销毁：创建和销毁进程的开销较大，需要系统调用；而线程的创建和销毁开销较小，可以由线程本身完成。



### 为什么要有线程，而不是仅仅用进程

使用线程的主要原因是为了提高程序的并发度和性能，具体包括以下几点：

1. 资源开销更小：线程是在进程内部创建的，共享进程的资源，因此创建和销毁线程的开销较小，同时线程间切换的代价也比进程间切换小。
2. 执行效率更高：由于线程共享进程的地址空间和系统资源，线程之间的通信和同步更加简单和高效。多个线程可以并行执行，从而提高程序的并发度和性能。
3. 并发编程更方便：使用线程可以更方便地实现并发编程，例如通过多线程处理用户请求、同时更新多个文件等。
4. 可以充分利用多核处理器：线程可以被分配到不同的CPU核心上运行，从而充分利用多核处理器的计算能力。

综上所述，使用线程可以更加高效、灵活地实现并发编程，提高程序的并发度和性能



### 谈谈对多线程的理解

多线程指的是在一个进程内同时运行多个线程，每个线程负责不同的任务：

1. 多线程可以提高程序的执行效率和响应速度，当一个线程被阻塞时，其他线程可以继续工作，从而避免了整个程序的暂停
2. 多线程程序的开发需要考虑多线程间的并发问题，如数据竞争、死锁等
3. 与单线程相比，多线程程序会涉及到更多的问题，例如线程之间的通信和共享资源等，也会带来额外的开销和复杂度。因此，在使用多线程时需要权衡其优缺点，并谨慎设计线程模型和应用场景





[JAVA并发编程知识总结（全是干货超详细）](https://zhuanlan.zhihu.com/p/362843892)

### Java的并发、多线程、线程模型

java支持并发编程，允许多个线程同时执行不同的任务：

1. 并发

   指在某个时间段内，多任务交替的执行任务，当有多个线程在操作时，把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行。 在一个时间段的线程代码运行时，其它线程处于挂起状

   

2. 多线程

   多线程是指在一个进程中存在多个线程同时执行的能力，使用java.lang.thread类或者实现java.lang.runnable接口来创建线程，每个线程都有自己的栈空间，共享进程内存中的堆

   

3. 线程模型

   java中的线程模型又称为调度模型，是指java虚拟机的一种机制来管理和调度线程。java中的线程模型可以分为两种：协作式线程模型、抢占式线程模型



### 并发/并行

并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。实际上，如果系统内只有一个CPU，使用多线程时，在真实系统环境下不能并行，只能通过切换时间片的方式交替进行，从而并发执行任务。真正的并行只能出现在拥有多个CPU的系统中





### 多线程有什么要注意的问题

共享资源数据一致性，死锁，上下文切换





### 创建线程的方式

继承`Thread`类、实现`Runnable`接口、使用`Callable和Future`创建线程、使用线程池例如用Executor框架

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    FutureTask<String> task = new FutureTask<>(() -> "Hello");
    new Thread(task, "ThreadName").start();
    System.out.println(task.get());
}
```



### 线程的状态

1. NEW 新建

2. Runnable 可运行

3. Blocked 锁阻塞：竞争锁失败

4. Waiting 无限等待：调用了以下等待方法会进入无线等待，直到调用唤醒方法并获得CPU可变为Runnable

   | 等待方法              | 唤醒方法                                       |
   | --------------------- | ---------------------------------------------- |
   | `obj.wait()`          | `obj.notify(), obj.notifyAll(), t.interrupt()` |
   | `t.join()`            | `t.interrupt()`                                |
   | `LockSupport.park() ` | `LockSupport.unpark(目标线程), t.interrupt() ` |

   

5. TimedWaiting 计时等待：调用了以下等待方法会进入计时等待，直到线程等待时间超过了 n 毫秒或调用唤醒方法并获得CPU可变为Runnable

   | 等待方法                                                     | 唤醒方法                                                     |
   | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | `Thread.sleep(long n)`                                       | 等待时间超过了 n 毫秒                                        |
   | 线程用 `synchronized(obj)` 获取了对象锁后，调用 `obj.wait(long n)` | 等待时间超过了 n 毫秒或调用 `obj.notify(), obj.notifyAll(),  t.interrupt()` |
   | `t.join(long n)`                                             | 等待时间超过了 n 毫秒或调用`t.interrupt()`                   |
   | `LockSupport.parkNanos(long nanos),  LockSupport.parkUntil(long millis)` | 等待时间超过了 n 毫秒或调用`LockSupport.unpark(目标线程), t.interrupt() ` |

   

6. Teminated 被终止：当前线程所有代码运行完毕



![](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufQgw4O7chibY66JoPJQHU7gCnUic0BY9MkTvhc5no97PcPnkb1H6eIgGtcrbUtNStYO833icrpp496g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### run/start方法区别

1.  start方法创建并启动一个新的线程，并将其放入就绪队列中等待执行
2. run方法只是在线程内部定义一个可执行的任务，并且只有在start方法被调用后才会真正执行





### 如何停止一个正在运行的线程

停止一个线程可以用`Thread.stop()`方法，但最好不要用，虽然它可以停止一个正在运行的线程，但这个方法是不安全的，而且已被废弃，在java中有以下3种方法可以终止正在运行的线程：

1. 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止
2. 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法
3. 使用interrupt方法中断线程



1. interrupt()方法的使用效果并不像for+break语句那样，马上停止循环，调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程

2. Thread类中提供了两个方法来判断线程是否停止状态：`this.interrupted()`：测试当前线程是否已经中断；`this.isInterrupted()`：测试线程是否已经中断，两个方法的区别：

   

   `this.interrupted()`：测试当前线程是否已经中断，当前线程是指运行this.interrupted()这行代码的线程，以下例子是在Main方法种调用的，Main方法没有被中断过，所以两次输出都是false

   ```java
   public class MyThread extends Thread {
       public void run(){
           super.run();
           for(int i=0; i<500000; i++){
               i++;
           }
       }
   }
   
   public class Run {
       public static void main(String args[]){
           Thread thread = new MyThread();
           thread.start();
           try {
               Thread.sleep(2000);
               thread.interrupt();
   
               System.out.println("Is thread Stop?" + thread.interrupted());// 清除打断标记
               System.out.println("Is thread Stop?" + thread.interrupted());
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   }
   ```

   输出结果：

   ```
   Is thread Stop? false
   Is thread Stop? false
   ```

   

   `Thread.currentThread().interrupt()` 可使main线程产生中断效果，Thread.interrupted() 会清除打断标记，所以第一次调用为true，再次调用时输出false：

   ```java
   public class Run {
       public static void main(String args[]){
           Thread.currentThread().interrupt();
           System.out.println("Is thread Stop? " + Thread.interrupted());
           System.out.println("Is thread Stop?" + Thread.interrupted());
       }
   }    
   
   // 输出
   Is thread Stop? true
   Is thread Stop? false
   ```

   

   `isInterrupted()` 不会清除打断标记：

   ```java
   public class Run {
       public static void main(String args[]){
           Thread thread = new MyThread();
           thread.start();
           thread.interrupt();
           System.out.println("Is thread Stop? " + thread.isInterrupted());
           System.out.println("Is thread Stop? " + thread.isInterrupted());
       }
   }
   
   // 输出
   Is thread Stop? true
   Is thread Stop? true
   ```

   

3. 所以可以利用 `interrupted()`来停止线程：

   ```java
   public class MyThread extends Thread {
       public void run(){
           super.run();
           for(int i=0; i<500000; i++){
               // 判断是否被打断
               if(this.interrupted()) {
                   System.out.println("线程已经终止， for循环不再执行");
                   break;
               }
               // System.out.println("i="+(i+1));
           }
           
           System.out.println("这是for循环外面的语句，也会被执行");
       }
   }
   
   public class Run {
       public static void main(String args[]){
           Thread thread = new MyThread();
           thread.start();
           try {
               Thread.sleep(2000);
               // 打断线程
               thread.interrupt();
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   }
   
   // 输出
   // 线程已经终止， for循环不再执行
   // 这是for循环外面的语句，也会被执行
   ```

   

   虽然停止了线程，但如果for语句下面还有语句，还是会继续运行，若不想让线程继续往下执行，可将 `break` 替换成 ` throw new InterruptedException();` 直接抛异常代码就不会往下执行





### 线程间如何通信

synchronized、wait/notify、join



### Wait / Sleep / Yield方法的区别

三个方法都可以用来暂停线程，区别：

1. wait 是 Object 中的方法，而sleep/yield是Thread中的方法
2. 调用 wait 时会释放锁并让出cpu，而调用sleep/yield不会释放锁，只让出cpu
3. 调用 wait 之后，别的线程调用该 Object 的 notify/notifyAll 之后，才有机会获得cpu和锁，而sleep/yield再次获得cpu之后就可以继续运行
4. 调用sleep之后会被阻塞挂起指定的时间，线程调度器不会去调度该线程，而yield则是让出剩余时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器很有可能会调度执行该线程



### 谈谈wait/notify关键字的理解

wait/notify是Java中用于实现线程同步的关键字。

wait方法可以让一个线程暂时阻塞并释放占用的锁，进入等待状态，直到其他线程调用notify方法来唤醒它。在调用wait方法时需要先获得对象的锁，否则会抛出`IllegalMonitorStateException`异常。

notify方法则用于唤醒一个处于等待状态的线程，让其重新竞争锁。被唤醒的线程仍然要继续等待其他线程释放锁后才能再次执行。notify方法同样需要在持有对象锁的情况下调用。

wait/notify机制可以协调不同线程之间的操作，避免了多个线程同时对共享资源进行修改的问题，从而保证了线程安全



### 同步方法和同步代码块的区别

1. 同步方法默认用this或者当前类class对象作为锁；
2. 同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法



### 在监视器(Monitor)内部，是如何做线程同步的

监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码

java 提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案



### 死锁

相互竞争不可抢占的资源就会导致死锁



### 如何确保N个线程可以访问N个资源同时又不导致死锁

多线程产生死锁的四个必要条件，只要破坏其中任意一个条件，就可以避免死锁：

1. 互斥条件：一个资源每次只能被一个进程使用
2. 保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
3. 不可剥夺性：进程已获得资源，在未使用完成前，不能被剥夺
4. 循环等待条件（闭环）：若干进程之间形成一种头尾相接的循环等待资源关系



### 如何避免死锁

1. 指定获取锁的顺序，并强制线程按照指定的顺序获取锁，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了
2. 超时锁，先指定时间获取锁，若获取不到则释放所有已经获取到的锁





### 如何控制某个方法允许并发访问线程的个数

1. `Semaphore`类可以用来限制同时执行某个代码块的线程数，通过调用acquire()方法来获取一个许可，如果没有许可可用，则该方法将阻塞直到有许可可用。在代码块执行完毕后，必须调用release()方法来释放许可
2. 线程池



### 多线程使用场景

多线程是一种并发编程技术，它允许程序同时执行多个线程，以便在并发任务时提高程序的效率：

1. 网络应用/数据库程序：网络应用程序通常需要与多个客户端同时通信，而多线程可以允许服务器同时处理多个连接，从而提高服务器的吞吐量和响应速度
2. 并行计算：并行计算通常需要同时执行多个计算任务，使用多线程可以将计算任务分配到不同的线程中，以提高计算速度



### 什么导致线程阻塞

- Thread.sleep(int n)

- 锁

- IO/远程通信

  



### 讲一下java中的同步的方法

1. Java中的同步方法是使用synchronized关键字定义的方法。当一个方法被定义为同步方法时，只有一个线程可以进入该方法，直到它执行完毕并释放锁时，其他线程才能执行该方法
2. Java中的同步方法可以保证线程安全，避免多线程同时操作一个共享资源而导致的数据不一致或异常情况
3. 果同步方法的代码块过大，则会导致线程的等待时间过长，从而影响系统的整体性能，降低系统并发能力



### 数据一致性如何保证

// todo



### 如何保证线程安全/如何实现线程同步

并发编程的三大特性：原子性，可见性，有序性

实现线程安全的方式：

1. 互斥同步：一个线程进入监视器后，其他线程必须等待该线程退出监视器
2. 非阻塞同步：CAS
3. 线程本地存储：ThreadLocal
4. 阻塞队列（LinkedBlockingQueue）
5. 使用原子变量（java.util.concurrent.atomic）
6. 变量的不可变性



### 如何使得共享变量变得线程安全

1. 方法内定义局部变量
2. 加锁：乐观/悲观锁
3. ThreadLocal



### 两个进程同时要求写或者读，能不能实现，如何防止进程的同步

// todo



### 线程间操作List

1. ArrayList 不是线程安全的，在高并发情况下对list进行数据添加会出现数据丢失的情况
2. 一个线程在遍历List，另一个线程修改List，会报ConcurrentModificationException异常



### 类锁和对象锁的区别

1. 如果多线程同时访问同一类的 类锁（synchronized 修饰的静态方法）以及对象锁（synchronized 修饰的非静态方法）这两个方法执行是异步的，原因：类锁和对象锁是两种不同的锁
2. 类锁对该类的所有对象都能起作用，而对象锁不能



### 对象锁和类锁是否会互相影响

对象锁和类锁是两个不同的锁，它们不会相互影响。对象锁的锁对象是某个具体的实例对象，不同的实例对象之间不会存在锁竞争问题；而类锁的锁对象是该类的Class对象，因此类锁是对类的所有对象实例起作用的，不同的实例对象之间也会存在锁竞争问题。因此，在使用对象锁和类锁时应根据具体情况选择合适的锁类型，以避免可能的竞争问题。



### 对象头

对象在内存中的存储布局可以分为三块区域：对象头，实例数据（对象真正存储的有效信息，程序代码中所定义的各个类型的字段内容），对齐填充

![](https://ask.qcloudimg.com/http-save/yehe-5522483/fu98yi2bmj.webp?imageView2/2/w/2560/h/7000/format/jpg)





对象头主要结构是由`Mark Word` 和 `Class Metadata Address`组成，**其中**`**Mark Word**`**存储对象的hashCode、锁信息或分代年龄或GC标志等信息**，`**Class Metadata Address**`**是类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例**

对象头里面也存储了两部分信息：第一部分呢，存储对象自身的运行时数据，包括哈希码，GC分代年龄，锁状态标识位，线程持有的锁，偏向锁Id，偏向时间戳等数据



### synchronized 原理

`synchronized` 是 java 中用于实现线程同步的关键字。它可以用来修饰方法和代码块，实现对共享资源的互斥访问，避免多个线程同时修改数据造成的冲突

synchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为监视器锁，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现，作用主要就是实现原子性操作和解决共享变量的内存可见性问题：

1. 执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1，此时其他竞争锁的线程则会进入等待队列中
2. 执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁



如果再深入到源码来说，synchronized实际上有两个队列`waitSet`和`entryList`：

1. 当多个线程进入同步代码块时，首先进入entryList
2. 有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1
3. 如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁
4. 如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null



#### 锁膨胀

偏向锁：在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁，如果一个线程获得了锁，那么锁就进入偏向模式，此时`Mark Word`的结构也就变为偏向锁结构，**当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查**`Mark Word`**的锁标记位为偏向锁以及当前线程ID等于**`Mark Word`**的ThreadID即可**，这样就省去了大量有关锁申请的操作

轻量级锁：由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁，这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块

自旋锁：大多数情况下共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU，得到锁，就顺利进入临界区，否则一直循环获取锁，若锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销

重量级锁：当**同一时间**有多个线程竞争锁时，锁就会被升级成重量级锁



#### 锁消除

```java
public void test() {
    Object obj = new Object();
    synchronized (obj) {
        System.out.println("allen");
    }
}

// jit 编译后优化为以下代码
public void test() {
    Object obj = new Object();
    System.out.println("allen");
}
```



#### 锁粗化

通过扩大锁的范围，避免反复加锁解锁

```java
public void test() {
    for (int i = 0; i < 1000; i++) {
        synchronized (this) {
            System.out.println("allen");
        }
    }
}

// 锁粗化
public void test() {
    synchronized (this) {
        for (int i = 0; i < 1000; i++) {
            System.out.println("allen");
        }
    }
}
```





### 谈谈对Synchronized 类锁，方法锁，重入锁的理解

1. 类锁

   ```java
   public static synchronized void test() {}
   
   public void test () {
     synchronized(Test.class) {}
   }
   ```

   

2. 方法锁：用synchronized修饰的方法

3. 重入锁：在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁，如果一个线程获得了锁，那么锁就进入偏向模式，此时`Mark Word`的结构也就变为偏向锁结构，**当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查**`Mark Word`**的锁标记位为偏向锁以及当前线程ID等于**`Mark Word`**的ThreadID即可**，这样就省去了大量有关锁申请的操作





### volatile原理

volatile 是轻量级的锁，它不会引起线程上下文的切换和调度:

1. volatile可见性：对一个volatile 的读，总可以看到对这个变量最终的写
2. volatile 原子性：volatile对单个读 / 写具有原子性（32 位 Long、Double），但是复合操作除外，例如i++ 
3. volatile 有序性：JVM 底层采用“内存屏障”来实现 volatile 语义，防止指令重排序
4. volatile 经常用于两个场景：状态标记变量、Double Check



#### 实现可见性原理

volatile可以保证内存可见性的关键是volatile的读/写实现了缓存一致性，缓存一致性的主要内容为：

- 每个处理器会通过嗅探总线上的数据来查看自己的数据是否过期，一旦处理器发现自己缓存对应的内存地址被修改，就会将当前处理器的缓存设为无效状态。此时，如果处理器需要获取这个数据需重新从主内存将其读取到本地内存。
- 当处理器写数据时，如果发现操作的是共享变量，会通知其他处理器将该变量的缓存设为无效状态

通过volatile修饰的变量，生成汇编指令时会比普通的变量多出一个Lock指令，这个Lock指令就是volatile关键字可以保证内存可见性的关键，它主要有两个作用：

- 将当前处理器缓存的数据刷新到主内存。
- 刷新到主内存时会使得其他处理器缓存的该内存地址的数据无效



#### 实现有序性原理

为了实现volatile的内存语义，编译器在生成字节码时会通过插入`内存屏障`来禁止指令重排序



### 内存屏障

内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行

Java内存模型把内存屏障分为4类：

| 屏障类型            | 指令示例                 | 说明                                                         |
| ------------------- | ------------------------ | ------------------------------------------------------------ |
| LoadLoad Barriers   | Load1;LoadLoad;Load2     | 保证Load1数据的读取先于Load2及后续所有读取指令的执行         |
| StoreStore Barriers | Store1;StoreStore;Store2 | 保证Store1数据刷新到主内存先于Store2及后续所有存储指令       |
| LoadStore Barriers  | Load1;LoadStore;Store2   | 保证Load1数据的读取先于Store2及后续的所有存储指令刷新到主内存 |
| StoreLoad Barriers  | Store1;StoreLoad;Load2   | 保证Store1数据刷新到主内存先于Load2及后续所有读取指令的执行  |



StoreLoad Barriers同时具备其他三个屏障的作用，它会使得该屏障之前的所有内存访问指令完成之后，才会执行该屏障之后的内存访问命令





### volatile能使一个非原子操作变成一个原子操作吗

`volatile`只能保证可见性和有序性，但可以保证64位的`long`型和`double`型变量的原子性





### synchronized 和volatile 的区别

1. volatile仅能实现变量的修改可见性及有序性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性及有序性
2. volatile不会造成线程上下文切换及调度；synchronized可能会造成线程的阻塞
3. volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的





### 45.ThreadLocal

在多线程并发访问同一个共享变量时，如果不做同步控制就可能会导致数据不一致的问题，所以需要加锁来解决这个问题，而Thread Local则是以空间换时间的方式来处理多线程的情况

Thread Local本身不存储数据，他使用的是线程中的threadLocals属性，这个数据的类型是一个在Thread Local 中定义的Thread LocalMap，当调用ThreadLocal的set方法时Thread Local会将自身引用作为key，值作为value存到线程的threadLocals中，也就是说每个线程的操作都是基于线程本身的一个私有副本，线程之间的数据相互隔离也就解决了线程安全的问题



ThreadLocalMap 中维护了一个Entry数组，名称为table，用来存储数据：

```java
static class ThreadLocalMap {
  // ...
  static class Entry extends WeakReference<ThreadLocal<?>> {
    Object value;
    
    Entry(ThreadLocal<?> k, Object v) {
      super(k);
      value = v;
    }
  }
  // ...
  private Entry[] table;
  // ...
}
```



因为Entry中的key为弱引用，因此在GC时，key就会被回收，而value为强引用，但key为null，永远无法通过key访问到value却又不能被回收，因此发生了内存泄漏

所以ThreadLocalMap中的Entry对象不在使用了之后，如果没有被及时清理，而程序本身也无法通过GC将其回收的话就会发生内存泄露



ThreadLocalMap属于线程，若线程生命周期短，当线程销毁时value也会随之回收，但一般用的线程池，线程生命周期较长



### 45.如何避免Thread Local内存泄漏

ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用

1. 每次使用完之后都掉用remove清除数据
2. 将threadlocal定义为 static fianl ，避免频繁创建thread local实例，保证程序中存在threadlocal的强引用







### 45.CAS 原理及缺点

原理：通过处理器的指令 保证操作的原子性，V为内存值，A旧的预期值，B新值，只有当V=A时才会用B去更新V

缺点：

1. ABA问题：Javay用`AtomicStampedReference`来解决这个问题，加入了版本号(加入了预期标志和更新后标志两个字段)，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新
2. 循环时间长开销大：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销
3. 只能保证一个共享变量的原子操作：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现





### ReentrantLock

`ReentrantLock`继承自接口`Lock`，有`3`个内部类，其中`Sync`内部类继承自`AQS`，另外的两个内部类继承自`Sync`，这两个类分别是用来**公平锁和非公平锁**的

 通过`Sync`重写的方法`tryAcquire`、`tryRelease`可以知道，**`ReentrantLock`实现的是`AQS`的独占模式，也就是独占锁，这个锁是悲观锁**

AQS内部维护一个state状态位，尝试加锁的时候通过CAS修改值，如果成功设置为1，并且将当前线程设置为锁的持有者，代表加锁成功，一旦获取到锁，其他的线程将会被阻塞进入阻塞队列自旋，获得锁的线程释放锁的时候将会唤醒阻塞队列中的线程，释放锁的时候则会把state重新置为0，同时当前线程ID置为空

#### 非公平锁

lock：

```java
final void lock() {
  if (compareAndSetState(0, 1))
    setExclusiveOwnerThread(Thread.currentThread());
  else
    acquire(1);
}
```



#### 公平锁

lock：

```java

```



#### Condition

Condition 和 Lock 一起使用以实现等待/通知模式，通过 `await()`和`singnal()` 来阻塞和唤醒线程

Condition 是一种广义上的条件队列。他为线程提供了一种更为灵活的等待 / 通知模式，线程在调用 await 方法后执行挂起操作，直到线程等待的某个条件为真时才会被唤醒。Condition 必须要配合 Lock 一起使用，因为对共享状态变量的访问发生在多线程环境下。一个 Condition 的实例必须与一个 Lock 绑定，因此 Condition 一般都是作为 Lock 的内部实现



[ReentrantLock 原理](https://juejin.cn/post/6844903805683761165) 

[ReentrantLock 原理](https://juejin.cn/post/7219953605763268669#heading-5)





### ReentrantLock::unlock()释放锁，如何唤醒等待队列中的线程

```java
		public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
```





### 28.ReentrantReadWriteLock

读写锁维护着一对锁，一个读锁和一个写锁。通过分离读锁和写锁，使得并发性比一般的排他锁有了较大的提升：

1. 在同一时间，可以允许多个读线程同时访问
2. 但是，在写线程访问时，所有读线程和写线程都会被阻塞





### 29.Synchronized 和 Lock 的区别

1. Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；
2. synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock() 去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；
3. Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，- 等待的线程会一直等待下去，不能够响应中断；
4. 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。
5. Lock 可以提高多个线程进行读操作的效率

更深的：

1. 与 synchronized 相比，ReentrantLock 提供了更多，更加全面的功能，具备更强的扩展性。例如：时间锁等候，可中断锁等候，锁投票。
2. ReentrantLock 还提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活，所以在多个条件变量和高度竞争锁的地方，ReentrantLock 更加适合（以后会阐述 Condition）。
3. ReentrantLock 提供了可轮询的锁请求。它会尝试着去获取锁，如果成功则继续，否则可以等到下次运行时处理，而 synchronized则一旦进入锁请求要么成功要么阻塞，所以相比synchronized 而言，ReentrantLock 会不容易产生死锁些。
4. ReentrantLock 支持更加灵活的同步代码块，但是使用 synchronized时，只能在同一个synchronized块结构中获取和释放。注意，ReentrantLock 的锁释放一定要在finally 中处理，否则可能会产生严重的后果。
5. ReentrantLock 支持中断处理，且性能较 synchronized 会好些





### AQS

AQS 是用来构建锁和同步器的基础框架，如 `ReentrantLock、ReentrantReadWriteLock、Semaphore` 等, 包含了实现同步器的细节，即获取同步状态、FIFO 同步队列。AQS 的主要使用方式是继承，子类通过继承同步器，并实现它的抽象方法来管理同步状态

维护一个同步状态 state。当 state > 0时，表示已经获取了锁；当state = 0 时，表示释放了锁

AQS 通过内置的 FIFO 同步队列来完成资源获取线程的排队工作：

1. 如果当前线程获取同步状态失败（锁）时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程
2. 当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态
3. AQS 内部维护的是CLH 双向同步队列

相关文章参考： [AbstractQueuedSynchronizer源码分析之条件队列](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485273&idx=2&sn=f0741b315ba14562317bc3c6fa91b2ae&chksm=ebd63875dca1b163d0338e97a11f8bccee07226890640826d7b0ec822c1e7eaf365f92db15fb&scene=21#wechat_redirect) 

调用signal方法可能唤醒线程也可能不会唤醒线程，但是调用signal方法一定会将线程从条件队列中移到同步队列尾部



![image-20230316113919383.png](https://s2.loli.net/2023/03/16/EQoVNbBF6y2as5H.png)

### AQS 的底层原理

AQS是AbstractQueuedSynchronizer的缩写，用来构建锁和同步器。AQS主要是通过内部维护一个双向链表来实现同步的。下面是AQS的底层原理的简要介绍：

1. 状态变量：AQS内部维护一个int类型的状态变量，用来表示当前同步状态。对于不同的同步操作，状态变量的值有不同的意义。
2. 内部队列：AQS内部维护一个双向链表，用来存储等待获取锁的线程。当线程尝试获取锁时，如果锁已经被其他线程占用，则该线程会被加入到内部队列中，并进入等待状态。
3. CAS操作：AQS使用CAS（Compare and Swap）操作来更新状态变量的值。CAS操作是一种原子操作，可以保证多个线程同时修改同一个变量时的线程安全性。
4. 独占锁：AQS的独占锁是一种排他锁，同一时刻只能有一个线程持有锁。在AQS中，独占锁是通过状态变量来实现的。当一个线程尝试获取独占锁时，如果锁已经被其他线程占用，则该线程会被加入到内部队列中，并进入等待状态。
5. 共享锁：AQS的共享锁是一种共享的读锁，可以允许多个线程同时访问共享资源。在AQS中，共享锁也是通过状态变量来实现的。当一个线程尝试获取共享锁时，如果锁已经被其他线程占用，则该线程会被加入到内部队列中，并进入等待状态。当其他线程释放共享锁时，AQS会通知所有等待获取共享锁的线程，让它们重新尝试获取锁。
6. Condition对象：AQS还提供了Condition对象，用来实现线程间的等待/通知机制。Condition对象本质上是一个等待队列，当一个线程调用Condition对象的await()方法时，该线程会被加入到等待队列中，并释放当前持有的锁。当其他线程调用Condition对象的signal()或者signalAll()方法时，等待队列中的线程会被唤醒，并尝试重新获取锁





### CountdownLatch

```java
public CountDownLatch(int count) {
  if (count < 0) throw new IllegalArgumentException("count < 0");
  this.sync = new Sync(count);
}
```



CountDownLatch 有一个内部类` Sync extends AbstractQueuedSynchronizer`，当新建CountDownLatch对象时，count就会赋值给AQS的state变量：

1. 当执行`countDown()`时，其实就是使用CAS将state - 1
2. 执行`await()`时，则判断state是否为0，不为0则将任务加入阻塞队列中并阻塞线程，头节点会一直自旋等待state为0，当state为0时，会把阻塞队列中的线程唤醒





### CyclicBarrier

```java
	public int await() throws InterruptedException, BrokenBarrierException {
        try {
            return dowait(false, 0L);
        } catch (TimeoutException toe) {
            throw new Error(toe); // cannot happen
        }
    }
```



CyclicBarrier 并不像CountDownLatch和ReentrantLock一样使用AQS的state变量，而是借助了`ReentrantLock的Condition`等待唤醒的功能实现`await`的：

1. 每次调用await时，使用Reentrant Lock加锁将count -1，如果count不为0，则加入Condition等待队列中，如果count为0，则将Condition队列的节点添加到AQS中并全部唤醒，并且将parties的值重新赋值给count实现复用



### CountDownLatch/CyclicBarrier 区别

CountDownLatch 和 CyclicBarrier 都是 Java 多线程并发编程中用于线程协调的工具类。

CountDownLatch：是可以让一个或多个线程等待另外一个或多个线程完成操作后再执行的工具类。CountDownLatch 的内部有一个计数器，可以设定一个初始值，在等待该计数器的线程数量减至 0 之前，调用 CountDownLatch 的 await() 方法的线程都必须等待。

CyclicBarrier：也是让多个线程等待彼此达到一定状态后再继续执行的工具类，但是它具有“可循环使用”的特点。在 CyclicBarrier 中，可以设定一个状态，当达到该状态时，所有等待的线程都会被释放，并可进行可选的操作。

它们的主要区别如下：

1. CountDownLatch 只能够使用一次，调用 countDown() 方法计数器减 1，当计数器归零后，所有等待线程会被唤醒执行，不能够复用。而 CyclicBarrier 可以反复使用。

2. CountDownLatch 只能等待异步操作执行完毕，而 CyclicBarrier 可以等待多个线程都到达同一个状态之后再执行下一步。

3. CountDownLatch 是通过计数器实现的，而 CyclicBarrier 是通过屏障机制实现的。

在使用 CountDownLatch 和 CyclicBarrier 时，需要注意线程安全问题和执行顺序等问题。



二者都能实现线程之间的等待，都是基于AQS实现，主要区别：

1. `CountDownLanch`是为计数器是设置一个值，当多次执行`countDown`后，计数器减为`0`的时候所有线程被唤醒，然后CountDownLanch失效，`只能够使用一次`
2. `CyclicBarrier`是当`count`为`0`时同样唤醒全部线程，`同时会重新设置count为parties`，重新new一个generation来实现重复利用



[CountDownLatch/CyclicBarrier 区别](https://zhuanlan.zhihu.com/p/393492693)



### Semaphore

Semaphore也称信号量，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源，Semaphore通常用于那些资源有明确访问数量限制的场景，常用于限流，如数据库连接数

与Reentrant Lock一样，Semaphore内部也有公平锁/非公平锁的静态内部类，其中`Sync`内部类继承自`AQS`，NonfairSync/FairSync继承自`Sync`，当初始的资源个数为 1 的时候，Semaphore 退化为排他锁



`Semaphore` 是共享锁的一种实现，它默认构造 AQS 的 `state` 值为 `permits`，可以将 `permits` 的值理解为许可证的数量，只有拿到许可证的线程才能执行：

1. `semaphore.acquire()` ，线程尝试获取许可证，如果 `state >= 0` 的话，则表示可以获取并使用 CAS 将 `state - 1` 
2. 若 `state<0` 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程
3. `semaphore.release()` ，线程尝试释放许可证，并使用 CAS 将 `state+1 ` 的值 ，释放许可证成功之后，同时会唤醒同步队列中的一个线程
4. 被唤醒的线程会重新用CAS尝试去将将 `state - 1` ，如果 `state>=0` 则获取令牌成功，否则重新进入阻塞队列，挂起线程









### 什么是线程池，为什么要使用线程池

线程池是一种基于池化思想`管理线程`的工具，经常出现在多线程服务器中，如MySQL。

线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用，使用线程池的好处：

- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。
- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行



### 线程池在业务中的实践

1. 快速响应用户请求：如查看商品详情，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务
2. 快速处理批量任务：如统计报表，计算全国门店哪些商品有某些属性，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量



### ThreadPoolExecutor 的5中运行状态/生命周期

| 状态       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| RUNNING    | 能接受新任务，也能处理队列中任务                             |
| SHUTDOWN   | 不在接受新提交的任务，但能处理队列中的任务                   |
| STOP       | 不在接受新提交的任务，也不处理队列中的任务，并且中断正在处理任务的线程 |
| TIDYING    | 所有任务已经终止，线程数量为0                                |
| TERMINATED | 终止状态                                                     |

![](https://p0.meituan.net/travelcube/582d1606d57ff99aa0e5f8fc59c7819329028.png)







### 线程池原理

当execute方法提交一个任务时时：

1. 线程数量未达到 corePoolSize，则新建一个线程（核心线程）执行任务
2. 线程数量达到了 corePoolSize，则将任务移入队列等待
3. 队列已满，新建线程（非核心线程）执行任务
4. 队列已满，总线程数又达到了 maximumPoolSize，就会由 handler 的拒绝策略来处理

如果线程池存在空闲的线程，并且设置了`allowCoreThreadTimeOut`为`true`，那么空闲时间超过keepAliveTime的线程都会被销毁



#### 阻塞队列

阻塞队列实现了 BlockingQueue 接口，并且有多组处理方法

1. 抛出异常：add(e) 、remove()、element()
2. 返回特殊值：offer(e) 、pool()、peek()
3. 阻塞：put(e) 、take()

JDK 8 中提供了七个阻塞队列可供使用：

1. ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列，采用 FIFO 的原则对元素进行排序添加的。内部使用可重入锁 ReentrantLock + Condition 来完成多线程环境的并发操作
2. LinkedBlockingQueue ：一个由链表结构组成的无界阻塞队列
3. PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列
4. DelayQueue：一个使用优先级队列实现的无界阻塞队列
5. SynchronousQueue：一个不存储元素的阻塞队列
6. LinkedTransferQueue：一个由链表结构组成的无界阻塞队列
7. LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列

相关文章参考 ：[阻塞队列 BlockingQueue](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487078&idx=2&sn=315f39b6d53862dcb732390729951628&chksm=ebd6314adca1b85c33db1134fbe98bf7526943b02dfc23021781abff265bb231ad9bcd3e1ad1&scene=21#wechat_redirect) [Java并发编程：阻塞队列](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485221&idx=1&sn=056f233e5d1579da75fb3c1ffe6b9a53&chksm=ebd63809dca1b11f801ce66a30dcddc23645e4352ada849066687d4107903d92bdd8ac70bef9&scene=21#wechat_redirect) 



#### 四种拒绝策略

1. AbortPolicy：直接抛出异常，默认策略
2. CallerRunsPolicy：用调用者所在的线程来执行任务
3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务
4. DiscardPolicy：直接丢弃任务
5. 实现 RejectedExecutionHandler 接口，自定义拒绝策略





在向线程池提交任务时有两个比较中要的参数会决定任务的去向，分别是线程池的状态和线程池中的线程数。在ThreadPoolExecutor内部使用了一个AtomicInteger类型的整数`ctl`来表示这两个参数，`ctl将32位的int拆分成了高3位和低29位`，分别表示线程池的运行状态和线程池中的线程个数：

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    // Integer.SIZE = 32.所以 COUNT_BITS= 29
    private static final int COUNT_BITS = Integer.SIZE - 3;
  
    // 00011111 11111111 11111111 11111111 这个值可以表示线程池的最大线程容量
    private static final int COUNT_MASK = (1 << COUNT_BITS) - 1;
  
    // 将-1左移29位得到RUNNING状态的值
    private static final int RUNNING    = -1 << COUNT_BITS;    
  
    // 线程池运行状态和线程数
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    
    private static int ctlOf(int rs, int wc) { return rs | wc; }
    
    // ...
}  
```



#### execute

```java
public void execute(Runnable command) {
      // 如果传入的Runnable的空，就抛出异常
      if (command == null)
          throw new NullPointerException();
      int c = ctl.get();
      // 线程池中的线程比核心线程数少
      if (workerCountOf(c) < corePoolSize) {
          // 新建一个核心线程执行任务
          if (addWorker(command, true))
              return;
          c = ctl.get();
      }
      // 核心线程已满，但是任务队列未满，添加到队列中
      if (isRunning(c) && workQueue.offer(command)) {
          int recheck = ctl.get();
          // 任务成功添加到队列以后，再次检查是否需要添加新的线程，因为已存在的线程可能被销毁了
          if (! isRunning(recheck) && remove(command))
              // 如果线程池处于非运行状态，并且把当前的任务从任务队列中移除成功，则拒绝该任务
              reject(command);
          else if (workerCountOf(recheck) == 0)
              // 如果之前的线程已经被销毁完，新建一个非核心线程
              addWorker(null, false);
      }
      // 核心线程池已满，队列已满，尝试创建一个非核心新的线程
      else if (!addWorker(command, false))
          // 如果创建新线程失败，说明线程池关闭或者线程池满了，拒绝任务
          reject(command);
  }
```





#### addWorker

Worker 是ThreadPoolExecutor的一个内部类，继承了AQS并实现Runnable接口，但Worker并没有像ReentrantLock等锁工具使用了CLH的功能，因为线程池中并不存在多个线程访问同一个Worker的场景，`只是使用了AQS中状态维护的功能`：

```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
  // 工作线程
  final Thread thread;
  // 提交的待执行任务
  Runnable firstTask;
  
  Worker(Runnable firstTask) {
    setState(-1); // inhibit interrupts until runWorker
    this.firstTask = firstTask;
    this.thread = getThreadFactory().newThread(this);
  }
  
  public void run() {
    runWorker(this);
  }
  
}  
```



addWorker工作流程：

1. `addWorker() `先尝试在线程池运行状态为`RUNNING`并且线程数量未达上限的情况下，通过CAS操作将线程池数量+1
2. 接着在`ReentrantLock`同步锁的同步保证下判断线程池为运行状态，然后把Worker添加到HashSet `workers`中
3. 若添加成功则调用`t.start()`执行Worker的内部线程，否则添加失败

```java
private boolean addWorker(Runnable firstTask, boolean core) {
  // 省略校验线程池状态及线程数的代码

  boolean workerStarted = false;
  boolean workerAdded = false;
  Worker w = null;
  
  try {
        w = new Worker(firstTask);
        //Worker内部有一个Thread，并且执行Worker的run方法，因为Worker实现了Runnable
        final Thread t = w.thread;
        if (t != null) {
            //这里必须同步在状态为运行的情况下将Worker添加到workers中
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());
 
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);  //把新建的woker线程放入集合保存，这里使用的是HashSet
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            //如果添加成功则运行线程
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        //如果woker启动失败，则进行一些善后工作，如移除work，线程数-1，尝试停止线程
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```



每个Worker对象会持有一个工作线程 thread，因此调用t.start()，会转而去执行worker的run方法，而Worker 中的 run() 方法则委托给 ThreadPoolExecutor 中的 runWorker() 执行：

1. runWorker其实就是一直调用`getTask()`，只要不返回空就可以一直复用线程去执行任务
2. 如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态
3. 调用 `task.run()`执行任务
4. 若getTask返回空，则执行processWorkerExit销毁线程

```java
final void runWorker(Worker w) {
  Thread wt = Thread.currentThread();
  // 拷贝提交的任务，并将 Worker 中的 firstTask 置为 null，便于下一次重新赋值。
  Runnable task = w.firstTask;
  w.firstTask = null;
  
  // status 设置为0，允许中断，也可以避免再次加锁失败
  w.unlock();
  boolean completedAbruptly = true;
  try {
    // 执行完持有任务后，通过 getTask() 不断从任务队列中获取任务
    while (task != null || (task = getTask()) != null) {
      w.lock();
      
      if ((runStateAtLeast(ctl.get(), STOP) ||
                    (Thread.interrupted() &&
                     runStateAtLeast(ctl.get(), STOP))) &&
                   !wt.isInterrupted())
                   wt.interrupt();
      
      try {
        // ThreadPoolExecutor 的钩子函数，用户可以实现 ThreadPoolExecutor，并重写 beforeExecute() 方法，从而在任务执行前 完成用户定制的操作逻辑。
        beforeExecute(wt, task);
        Throwable thrown = null;
        try {
          // 执行提交任务的 run() 方法
          task.run();
        } catch (RuntimeException x) {
          // ...
        } finally {
          // ThreadPoolExecutor 的钩子函数，同 beforeExecute，只不过在任务执行完后执行。
          afterExecute(task, thrown);
        }
      } finally {
        // 便于任务回收
        task = null;
        w.completedTasks++;
        w.unlock();
      }
    }
    completedAbruptly = false;
  } finally {
    // 执行到这里表示任务队列中没了任务，或者线程池关闭了，此时需要将worker从缓存冲清除
    processWorkerExit(w, completedAbruptly);
  }
}
```





#### getTask

ThreadPoolExcute中大部分都是先判断状态，在判断线程数量，若状态已停止那么很多操作也就没必要了，获取线程数量则是要和核心线程/最大线程数比较来确定下一步要做什么：

1. 第一个 if 判断线程池状态，当运行状态处于非 RUNNING 状态，此外 rs >= STOP（线程池是否正在 stop）或阻塞队列是否为空。则将 workerCount 减 1 并返回 null。为什么要减 1 呢，因为此处其实是去获取一个 task，但是发现处于停止状态了，也就是没必要再去获取运行任务了，那这个线程就没有存在的意义了。后续也会在 processWorkerExit 将该线程移除。

2. 第二个 if 条件目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行 execute 方法时，如果当前线程池的线程数量超过了 corePoolSize 且小于 maximumPoolSize，并且 workQueue 已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是 timedOut 为 true 的情况，说明 workQueue 已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于 corePoolSize 数量的线程销毁掉，保持线程数量在 corePoolSize 即可

```java
private Runnable getTask() {
    // timeOut变量的值表示上次从阻塞队列中取任务时是否超时
    boolean timedOut = false;
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
      
        // 线程池的状态是SHUTDOWN且队列为空，或者状态是STOP
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }
        int wc = workerCountOf(c);
        
        // allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
        
        /*
         * wc > maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；
         * timed && timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时
         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；
         * 如果减1失败，则返回重试。
         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。
         */
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }
        try {
            /*
             * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；
             * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。
             * 
             */
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            // 如果 r == null，说明已经超时，timedOut设置为true
            timedOut = true;
        } catch (InterruptedException retry) {
            // 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试
            timedOut = false;
        }
    }
}
```



#### processWorkerExit

当getTask返回null之后就会执行processWorkerExit：

1. 使用ReentrantLock加锁，将worker从workers移除
2. 调用`tryTerminate`判断是否有必要要结束线程池
3. 判断当前线程池的状态及线程数量，如果此时线程处于 STOP 状态以下，那么就会判断核心线程数是否达到了规定的数量，没有的话，就会继续创建一个线程



#### tryTerminate

```java
final void tryTerminate() {
    for (;;) {
        int c = ctl.get();
        
        if (isRunning(c) ||
            runStateAtLeast(c, TIDYING) ||
            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
            return;
      
        // 如果线程数量不为0，则中断一个空闲的工作线程，并返回
        if (workerCountOf(c) != 0) { // Eligible to terminate
            interruptIdleWorkers(ONLY_ONE);
            return;
        }
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                try {
                    // terminated方法默认什么都不做，留给子类实现
                    terminated();
                } finally {
                    // 设置状态为TERMINATED
                    ctl.set(ctlOf(TERMINATED, 0));
                    termination.signalAll();
                }
                return;
            }
        } finally {
            mainLock.unlock();
        }
        // else retry on failed CAS
    }
}
```



#### shutdown

shutdown 方法要将线程池切换到 SHUTDOWN 状态，并调用 interruptIdleWorkers 方法请求中断所有空闲的 worker，最后调用 tryTerminate 尝试结束线程池

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 安全策略判断
        checkShutdownAccess();
        // 切换状态为SHUTDOWN
        advanceRunState(SHUTDOWN);
        // 中断空闲线程
        interruptIdleWorkers();
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    // 尝试结束线程池
    tryTerminate();
}
```





#### shutdownNow

shutdownNow 方法与 shutdown 方法类似，不同的地方在于：

1. 设置状态为 STOP；
2. 中断所有工作线程，无论是否是空闲的；
3. 取出阻塞队列中没有被执行的任务并返回

```java
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(STOP);
        // 中断所有工作线程，无论是否空闲
        interruptWorkers();
        // 取出队列中没有被执行的任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
```





[线程池原理](https://www.cnblogs.com/huansky/p/12467720.html#:~:text=ThreadPoolExcutor%20%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%20%E6%A6%82%E8%AE%BA%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E8%8B%B1%E8%AF%AD%EF%BC%9Athread%20pool%EF%BC%89%EF%BC%9A%E4%B8%80%E7%A7%8D%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F%E3%80%82%20%E7%BA%BF%E7%A8%8B%E8%BF%87%E5%A4%9A%E4%BC%9A%E5%B8%A6%E6%9D%A5%E8%B0%83%E5%BA%A6%E5%BC%80%E9%94%80%EF%BC%8C%E8%BF%9B%E8%80%8C%E5%BD%B1%E5%93%8D%E7%BC%93%E5%AD%98%E5%B1%80%E9%83%A8%E6%80%A7%E5%92%8C%E6%95%B4%E4%BD%93%E6%80%A7%E8%83%BD%E3%80%82%20%E8%80%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%B4%E6%8A%A4%E7%9D%80%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E7%AD%89%E5%BE%85%E7%9D%80%E7%9B%91%E7%9D%A3%E7%AE%A1%E7%90%86%E8%80%85%E5%88%86%E9%85%8D%E5%8F%AF%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%E3%80%82%20%E8%BF%99%E9%81%BF%E5%85%8D%E4%BA%86%E5%9C%A8%E5%A4%84%E7%90%86%E7%9F%AD%E6%97%B6%E9%97%B4%E4%BB%BB%E5%8A%A1%E6%97%B6%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A3%E4%BB%B7%E3%80%82,%2B2%20%E6%AF%94%E8%BE%83%E5%90%88%E9%80%82%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%BF%87%E5%A4%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%A2%9D%E5%A4%96%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80%E3%80%82%20Java%20%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E7%94%A8%20ThreadPoolExecutor%20%E7%B1%BB%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84.%20%E6%9C%AC%E6%96%87%E5%B0%B1%E5%AF%B9%E8%AF%A5%E7%B1%BB%E7%9A%84%E6%BA%90%E7%A0%81%E6%9D%A5%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B%E8%BF%99%E4%B8%AA%E7%B1%BB%E5%86%85%E9%83%A8%E5%AF%B9%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%2C%20%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%89%E6%96%B9%E9%9D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E3%80%82)

[线程池原理](https://juejin.cn/post/6983213662383112206/#heading-9) 



### 线程池中多余的线程如何回收

工作线程启动后，就进入`runWorker(Worker w)`方法，里面是一个while循环，循环判断任务是否为空，若不为空，执行任务；若取不到任务，或发生异常，退出循环，执行`processWorkerExit(w, completedAbruptly); `在这个方法里把工作线程移除掉



一条线程`getTask()`返回`null`，就会被回收，有一下两种情况会返回空：

1. 线程池的状态是SHUTDOWN且队列为空，或者状态是STOP

   ```java
   if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
       decrementWorkerCount();
       return null;
   }
   ```

   

2. 工作线程数已经大于最大线程数或当前工作线程已超时，且，还有其他工作线程或任务队列为空

   ```java
   boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
   
   if ((wc > maximumPoolSize || (timed && timedOut))
           && (wc > 1 || workQueue.isEmpty())) {
       if (compareAndDecrementWorkerCount(c))
            return null;
       continue;
   }
   ```

   ![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2308365b1e7846c29d3410a105723a7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)







### Worker为什么继承AQS

在空闲时可以响应中断，在执行任务时不可被中断，在runWorker中执行任务会调用`w.lock()`，执行结束后释放锁：

1. 调用shutdown，优雅的关闭线程池
2. 调整核心线程数和最大线程数，需要将多余的线程停掉，但停掉时还是要优雅

在这些场景中，实现的核心是interruptIdleWorkers方法：

```java
private void interruptIdleWorkers(boolean onlyOne) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (Worker w : workers) {
                Thread t = w.thread;
                if (!t.isInterrupted() && w.tryLock()) {
                    try {
                        t.interrupt();
                    } catch (SecurityException ignore) {
                    } finally {
                        w.unlock();
                    }
                }
                if (onlyOne)
                    break;
            }
        } finally {
            mainLock.unlock();
        }
    }
```





### Worker为什么不使用ReentrantLock，而设计为不可重入锁

防止在做`setCorePoolSize` 等操作时，线程获取到锁，导致正在运行的线程被中断





### JAVA 常见的几种线程池



#### FixedThreadPool

有固定数量线程的线程池，其`corePoolSize=maximumPoolSize`，且keepAliveTime为0，适合线程稳定的场所：

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
   return new ThreadPoolExecutor(nThreads, nThreads,
                                 0L, TimeUnit.MILLISECONDS,
                                 new LinkedBlockingQueue<Runnable>());
}
```



1. FixedThreadPool 使用了无界的 LinkedBlockingQueue, 当任务数量超过 corePoolSize 后，全都会添加到队列中
2. 当线程池满时且阻塞队列也已经满时，如果继续提交任务线程池不会再新建线程，会直接走拒绝策略，FixedThreadPool 使用的是默认的拒绝策略，即 `AbortPolicy`，直接抛出异常





#### SingleThreadExecutor

从数学的角度来看SingleThreadPool应该属于FixedThreadPool的子集。其`corePoolSize=maximumPoolSize=1`,且keepAliveTime为0，适合线程同步操作的场所

```java
public static ExecutorService newSingleThreadExecutor() {
   return new FinalizableDelegatedExecutorService
       (new ThreadPoolExecutor(1, 1,
                               0L, TimeUnit.MILLISECONDS,
                               new LinkedBlockingQueue<Runnable>()));
}
```





#### CachedThreadPool

既然要储存，其容量肯定是很大，所以他的corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE

```java
public static ExecutorService newCachedThreadPool() {
   return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                 60L, TimeUnit.SECONDS,
                                 new SynchronousQueue<Runnable>());
}
```



这个线程池，当任务提交是就会创建线程去执行,执行完成后线程会空闲60s,之后就会销毁。但是如果主线程提交任务的速度远远大于 CachedThreadPool 的处理速度，则 CachedThreadPool 会不断地创建新线程来执行任务，这样有可能会导致系统耗尽 CPU 和内存资源



#### ScheduleThreadPool

ScheduledThreadPool是一个具有定时定期执行任务功能的线程池



关文章参考：[JAVA线程池原理详解（1）](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247484686&idx=1&sn=b4f63e08a018ff7fadc4ecfb9352e439&chksm=ebd63a22dca1b334cc9ae79df71095cfbc6880e671aaa8addd273aa842801ebfaf4d9f95e714&scene=21#wechat_redirect) [JAVA线程池原理详解（2）](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247484699&idx=2&sn=b0e359218437e3eb6223b9acb8cdca68&chksm=ebd63a37dca1b321740fee80579779b6d34cf1997878a896f3a47127a2670afbd2af4f15127d&scene=21#wechat_redirect) [Java多线程和线程池](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247484840&idx=2&sn=6fa3a468ba36e86ab2c73b6c289dd708&chksm=ebd63a84dca1b392ed1674be76df99bcdd1ffb5dcc8245613d24b7cf277db663f3b40fd3fae2&scene=21#wechat_redirect) [Java线程池总结](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486337&idx=2&sn=5abbb5bf79607d437c637c8a968475c8&chksm=ebd634addca1bdbb62788e44feb9ff5692d9809eaeab4af07fa427cd349978d58e5be5ee9133&scene=21#wechat_redirect) 



### 线程池参数怎么配置

做压测，核心线程数根据CPU情况，工作队列根据内存及任务延迟时间，拒绝策略则根据任务的重要情况是否能够丢弃

[美团动态线程池](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html) 





### 谈谈你对并发编程的理解并举例说明

并发编程是指在同一时刻有多个任务在执行，它的目标是提高程序的执行效率

在处理用户请求时可以创建新线程/线程池以便在后台处理请求，并返回响应给用户，让用户感觉服务响应更快捷



### 谈谈你对多线程同步机制的理解

多线程同步机制是指在多个线程并发运行时，为了避免程序出现意外情况（如数据竞争），需要规定多个线程之间的执行顺序和相互操作的关系。常见的同步机制包括互斥锁、信号量、条件变量等。

以下是我对多线程同步机制的一些理解：

1.互斥锁

- 互斥锁是用来保证同一时刻只有一个线程能够访问共享资源。
- 在使用共享资源前，需要先获取互斥锁进行加锁，并在使用完后释放锁。
- 在加锁期间，如果其他线程也尝试获取锁，那么它们将会被阻塞挂起，直到当前线程释放锁。

2.信号量

- 信号量是一种计数器，用于控制同时访问的线程数。
- 在使用共享资源前，需要先获取信号量，并在使用完后释放信号量。
- 当信号量计数为0时，表示资源已经被占用，新的线程需要等待其它线程释放资源后才能获得信号量。

3.条件变量

- 条件变量是用来控制线程执行的序列和相互之间协作的一种手段，可用于实现生产者消费者模型。
- 条件变量需要与互斥锁一起使用，一般是当共享资源不满足特定条件时，线程将会处于休眠状态，直到条件满足后被唤醒。

以上是我对多线程同步机制的简单理解。在实际应用中，我们需要根据具体情况选择适合的同步机制，以保证程序的





### 多线程断点续传原理

多线程断点续传是一种优化下载的方式，可以提高下载速度并保证下载文件不受网络波动影响而中断。其原理如下：

1. 第一次请求：客户端发出 http 请求，并在请求头中添加 range 字段，指定需要下载的文件范围。
2. 服务端响应：服务器接收到请求后，返回文件的部分数据给客户端，并在响应头中设置 content-range 字段，指明此次返回的数据在整个文件中的位置。同时，响应头中也会包含当前文件的大小等信息。
3. 接着下载：客户端接收到数据后，将数据写入本地文件相应的位置。然后发出新的请求，请求下一部分所需的数据。
4. 多线程下载：为了利用带宽更充分，多线程断点续传会启动多个线程并发下载同一个文件的不同部分，每个线程负责下载该部分的数据。由于每个线程只需要下载一部分数据，因此下载速度会更快。
5. 断点续传：如果下载过程中出现网络中断、客户端崩溃等情况，那么当再次发起请求时，服务端通过请求头中的 range 字段和之前已经下载的部分进行比对，然后从上一次中断的位置开始继续向客户端发送剩余的数据。这样可以避免重新下载已经完整的部分，节省了带宽和时间。

综上所述，多线程断点续传通过将文件分成若干小块进行并行下载，同时记录下载进度，方便后续恢复下载现场，可以提高下载速度，并且保证下载过程不受网络波动的影响而失败



### 断点续传的实现

断点续传是一种网络传输技术，允许在文件下载或上传过程中暂停并继续恢复，而不会影响已经传输的部分。以下是一个简单的实现示例：

1. 建立 HTTP 连接

首先，在客户端和服务器之间建立 HTTP 连接。此连接可以使用常规的 `GET` 或 `POST` 请求进行设置。

1. 发送请求头

需要在请求头中包含 Range 头字段。该字段指定了客户端希望在继续传输时从哪个位置开始续传。例如：

```
复制代码Range: bytes=5000-9999
```

上面的代码表示客户端请求服务器从 5000 字节处开始上传或下载文件，直到第 9999 字节为止。

1. 服务器响应

服务器以 HTTP 状态 206（Partial Content）回应客户端。这表示它正在为客户端提供部分文件内容。其中，响应头包含如下信息：

```
复制代码Content-Range: bytes 5000-9999/20000
```

上述代码表示服务器正在返回从第 5000 到第 9999 字节的数据，并且该文件总共有 20000 字节。

1. 客户端保存文件

客户端接收服务器传输的文件内容，并将其保存到本地。在下次传输时，客户端从保存的文件最后一个字节的下一个字节处开始继续传输。

通过这样的方式，实现了文件传输的暂停和继续操作，以及避免重复下载整个文件，从而提高了传输效率。





## JVM



### 运行时数据区



### Java 内存模型JMM 

JMM 是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的

JMM用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量



### 如何判断一个对象是否存活/GC对象的判定方法

判断对象是否存活的算法包括：

1. 引用计数算法

   给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是不能再被引用的

2. 可达性分析算法

   通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链Reference Chain，当一个对象到GC Root没有任何引用链相连时，则证明此对象是不可用的

3. 三色标记法



判断一个无用的类需要同时满足下面3个条件：

1. 该类的所有实例都已经被回收
2. 加载该类的ClassLoader已经被回收
3. 该类对应的java.lang.Class对象已经没有任何地方被引用，无法在任何地方通过反射访问该类的方法





### CMS 垃圾收集的原理

1. 初始标记：STW，仅仅只是标记出GC Roots能直接关联的对象，一旦标记完成后就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这里速度非常快
2. 并发标记：从GCRoots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行，在并发标记中若用户线程产生了垃圾，这部分不会被清理
3. 重新标记：为了修正并发标记期间，因用户程序继续运作导致标记产生变动的那—部分对象的标记记录
4. 并发清除：清理删除标记阶段判断的已经死亡的对象，释放内存空间，由于不需要移动存活对象，所以这个阶段也可以与用户线程同时并发

cms的**收集是优点是尽量保证对用户线程的影响降到最低，但是其主要缺点是由于需要与用户线程并发执行，因此在处理某些极端情况的时候可能会出现时间不可预测和**到达瓶颈时空间明显变小等性能问题



### G1 垃圾收集的特点，为什么低延迟

1. 分代收集：G1将堆分割成多个不同大小的区域
2. 并发执行
3. 空间整理：G1采用了增量收集的方式进行回收，只是对堆中碎片化的空间进行整合而不是对整个堆进行完全腾空
4. 可预测性：G1能控制GC时间，避免了 STW 带来的系统不可用问题，而且还设置了预期的最大延迟时间，确保每次收集操作都能在预期时间范围内完成
5. 自适应调节



### 有哪些垃圾回收算法，优缺点

|          | Mark-Sweep<br />标记清除 | Mark-Compact<br />标记-压缩 | Copying<br />复制算法                     |
| -------- | ------------------------ | --------------------------- | ----------------------------------------- |
| 速度     | 中等                     | 最慢                        | 最快                                      |
| 空间开销 | 少，但会堆积碎片         | 少，但不会堆积碎片          | 通常需要存活对象的2倍大小<br />不堆积碎片 |
| 移动对象 | 否                       | 是                          | 是                                        |





### 哪些对象可以作为 GC Roots

1. 栈中引用的对象
2. 堆中的静态变量及字符串常量池
3. 锁持有的对象
4. 线程





### 有哪些类加载器

1. 启动类加载器
2. 扩展类加载器
3. 应用/系统类加载器



### 双亲委派模式，哪些场景会打破双亲委派模式

可以通过重写抽象类ClassLoader中的loadClass方法来打破双亲委派模式：

1. 如果不想打破双亲委派模型，就重写ClassLoader类中的`findClass()`方法即可，无法被父类加载器加载的类最终会通过这个方法被加载
2. 而如果想打破双亲委派模型则需要重写ClassLoader类`loadClass()`方法，典型的打破双亲委派模型的框架和中间件有tomcat与osgi





### 线上服务器出现频繁 Full GC，怎么排查

出现频繁 full gc 的情况可能是由于以下几个因素导致的：

1. 内存泄露：程序中存在大量无用对象没有被回收，导致堆内存占满，触发 full gc。
2. 内存分配不当：程序中使用了过多的大对象，导致堆内存较快被占满，触发 full gc。
3. jvm 配置不当：jvm 的内存配置参数设置不合理，造成内存泄漏或者 full gc 频繁触发。

为了排查服务器频繁 full gc 的问题，可以尝试以下几个步骤：

1. 查看应用日志：检查应用日志文件，查看是否有异常抛出、程序运行状态等信息。

2. 分析 gc 日志：对进行全局观察和统计服务各个 jvm 进程内存变化情况，找到频繁触发 full gc 的节点，定位具体原因。可以使用 jstat、jmap、jstack 等命令获取相关信息。

3. 检查代码：检查代码是否存在常见的内存泄漏问题，例如未关闭资源、集合类对象未清空等。

4. 调整 jvm 配置：根据实际测试结果，逐步调整 jvm 参数以达到最优状态。一般来说，需要关注的参数包括 xms、xmx、xmn、xx:survivorratio 等。可以通过 visualvm 工具进行内存分析，通过视图界面，可以直观的看到 jvm 的内存使用情况。

5. 优化代码：针对程序中存在的大对象进行合理设计和合理的内存分配策略。

   

### 定位问题常用哪些命令

1. jps -lv

2. jstat -gcutil -h5 1234 1000 20：查看进程id为1234的gc垃圾收集信息，每秒打印一次，总共打印20行，每5行打印一次表头

3. jinfo: 实时地查看和调整虚拟机各项参数，使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数：

   ```shell
   # jinfo -flag [+|-]name vmid 开启或者关闭对应名称的参数
   
   # 关闭进程为1234的 printGc
   jinfo -flag PrintGC 1234
   
   # 开启进程为1234的 printGc
   jinfo -flag +PrintGC 1234
   ```

   

4. jmap：生成堆转存快照

   ```shell
   jmap -dump:format=b,file=C:\Users\SnailClimb\Desktop\heap.hprof 17340
   ```

   

   如果不使用 `jmap` 命令，要想获取 Java 堆转储，可以使用 `“-XX:+HeapDumpOnOutOfMemoryError”` 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 `kill -3` 发送进程退出信号也能拿到 dump 文件

   

5. jstack :生成虚拟机当前时刻的线程快照，`jstack` 命令可以找到发生死锁的线程的具体信息

   ```shell
   jstack 1234
   ```





### JConsole:JDK 可视化分析工具

使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:

```properties
-Djava.rmi.server.hostname=外网访问 ip 地址 
-Dcom.sun.management.jmxremote.port=60001   //监控的端口号
-Dcom.sun.management.jmxremote.authenticate=false   //关闭认证
-Dcom.sun.management.jmxremote.ssl=false
```



[JDK 可视化分析工具](https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jdk-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7) 



### 介绍下 JVM 调优的过程

1. 监控报警
2. 查看日志，定位问题
3. 使用GC工具/命令查看进一步确定问题
4. 查看代码是否有优化空间
5. 调整JVM参数
6. 压测



### 对象什么时候会从servivor区放放old区，jvm中哪些地方会发生oom

- 当对象首次创建时，会放在新生代的eden区, 若没有发生GC，会一直在eden区, GC后，可能进入survivor区或者年老代
- 当对象年龄达到一定的大小 ,就会离开年轻代， 进入老年代，`-XX:MaxTenuringThreshold=n`：在年轻代servivor经过n次GC后进入old区，-XX:TargetSurvivorRatio
- 若对象体积太大, 新生代无法容纳这个对象，也会进入old区，`-XX:PretenureSizeThreshold`：达到这个值的对象直接放入old区



### 何时发生full gc

- 调用System.gc()，可能会fullgc，可通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc

- 老年代空间不足

- 方法区/元空间 空间不足

  

### 方法区会gc吗，什么时候gc

会，full gc或者方法区满时发生gc



### 各个版本的jdk内存结构的变化

- jdk1.6之前，堆，方法区，静态变量及字符串常量池都在方法区中

- jdk1.7，堆，方法区，静态变量及字符串常量池都在堆中

- Jdk1.8之后，堆，将方法区该为元空间，而且元空间不在jvm当中，被提到了本地内存中，静态变量及字符串常量池都在堆中

  

### 如果年轻代经常发生gc，会是什么原因，怎么解决

1. 内存分配过于频繁：如果程序经常在堆上创建和销毁对象，就会导致频繁的gc。这种情况下，可以考虑重用对象而不是创建和销毁，或者使用对象池等技术来减少内存分配。

2. 内存不足：如果内存不足，会导致gc更加频繁。这种情况下，可以考虑增加堆的大小，或者优化程序的内存使用。

3. 大对象：如果程序创建了大对象（比如超过了年轻代的容量），就可能导致频繁的gc。这种情况下，可以考虑调整年轻代和老年代的比例，或者优化程序的内存使用。

4. 缓存失效：如果程序使用了缓存，但是缓存失效太频繁，也会导致gc更加频繁。这种情况下，可以考虑优化缓存的使用，减少缓存失效的可能性。

针对以上问题，可以从以下几个方面来解决：

1. 减少内存分配：重用对象或使用对象池等技术来减少内存分配。

2. 增加堆的大小：通过增加堆的大小来减少gc的频率。

3. 调整年轻代和老年代的比例：根据程序的特点来调整年轻代和老年代的比例，减少大对象的出现。

4. 优化缓存的使用：通过合理地使用缓存来减少gc的频率。

5. 优化程序的内存使用：对程序进行优化，减少内存消耗。



### 项目上如果发生了oom如何定位问题

如果项目发生了 OutOfMemoryError（OOM），需要进行下面的步骤来定位问题：

1.查看日志。首先需要查看项目的日志，找到 OOM 异常相关的堆栈信息。

2.使用 JVM 工具。在出现 OOM 问题后，使用一些 JVM 工具进行诊断，例如 jmap、jstack、jstat、jvisualvm 等。

3.内存泄露检查。查看项目中是否存在内存泄露问题，例如未关闭的数据库连接等。

4.分析代码。如果在项目的代码中存在大量的对象创建和持有，需要对代码进行分析和优化。

5.调整 JVM 参数。根据项目的实际情况，调整 JVM 参数，例如堆内存大小、GC 策略等。

6.压力测试。进行压力测试，验证在高并发场景下，项目是否会出现 OOM 问题。

通过以上步骤的分析，可以找到 OOM 问题的根本原因，并进行相应的优化和调整，提高系统的稳定性和性能。





### 如何调整新老年代的空间，项目上是怎么设计的，你们生产的比例一般设为多少

调整新老年代的空间大小可以通过JVM的参数来实现，具体参数如下：

- -XX:NewSize：设置新生代初始大小
- -XX:MaxNewSize：设置新生代最大大小
- -XX:SurvivorRatio：设置Eden区与Survivor区的比例，默认为8:1，即Eden区占整个新生代的8/10，Survivor区占2/10

项目上如何设计可以参考以下几个方面：

- 系统中对象的生命周期长短：如果系统中的对象生命周期较短，那么应该增大新生代的比例，以便更快地回收对象，反之应该增大老年代的比例。
- 系统中的内存压力：如果系统中的内存压力较大，可以适当增大新生代的比例。
- 系统对垃圾回收时间的要求：如果对垃圾回收时间要求较高，可以适当增大新生代的比例，以减少垃圾回收的时间。

一般而言，生产环境中新生代和老年代的比例可以设置为1：2或1：3，具体根据应用的情况而定。





### 年轻代经常gc，可以调高年轻代的空间吗，这样做的优缺点是什么

可以调高年轻代的空间，优点是可以减少GC的频率和时间，提高应用程序性能和响应速度；缺点是可能会导致老年代的空间不足，从而导致更加频繁的Full GC和严重的性能问题。同时，调整年轻代的空间还需要考虑到应用程序的实际情况和内存需求，以避免浪费内存或导致内存不足等问题。



### 有没有用过什么gc工具



### g1垃圾回收器的回收流程

G1垃圾回收器的回收流程可以分为以下几个步骤：

1. 初始标记（Initial Mark）

在这个阶段，G1 GC会从根对象开始对活动对象进行标记，并记录下这些对象的引用关系。这个过程是通过扫描堆中的根对象和之前标记的卡片（Card）来完成的。这个过程需要停止所有应用程序线程。

2. 并发标记（Concurrent Mark）

在这个阶段，G1 GC会对堆中的未标记对象进行标记，并记录下这些对象的引用关系。这个过程是与应用程序并发执行的，并且不会停止应用程序线程。

3. 初始标记重标记（Remark）

在这个阶段，G1 GC会重新标记从并发标记开始时到现在发生变化的对象。这个过程需要停止所有应用程序线程。

4. 清理（Cleanup）

在这个阶段，G1 GC会清理掉所有未标记的对象，并进行内存整理。这个过程是与应用程序并发执行的，并且不会停止应用程序线程。

G1垃圾回收器通过分区（Partition）把整个堆划分成多个区域，每个区域都会被分配一个优先级。G1 GC会根据这些优先级来决定哪些区域需要被回收。在进行垃圾回收时，G1 GC会先回收优先级最高的区域，然后再逐步回收其他区域，以此来减少应用程序中断时间。







