### 1.为什么使用消息队列

消息队列的常见使用场景有很多但是核心的有三个：解耦、异步、削峰

1. 解耦：系统A往系统BCD发数据，通过接口调用，若BCD其中一个系统挂了或者新加一个系统E也需要这些数据，使用MQ就可以解耦这些系统，A系统往MQ中发数据，需要数据的系统直接在MQ里拿
2. 异步：系统A接收一个请求，需要在本地库写，同时也要在其他系统中写，则自己本地写库需要3ms，BCD分别需要300ms、450ms、200ms，最终总好时长：953ms
3. 系统在某一段时间请求量暴增，可以先将用户请求放在MQ中，不要直接打到系统，让系统从MQ中拉取请求





### 2.消息队列的优缺点





### .消息队列中，如何保证消息的顺序性

在 mysql 里增删改一条数据，对应出来了增删改 3 条 `binlog` 日志，接着这三条 `binlog` 发送到 MQ 里面，再消费出来依次执行，本来是：增加、修改、删除；若换了顺序给执行成删除、修改、增加，就错了，出错场景：

RabbitMQ：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1/data3，导致错误

Kafka：如建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的，消费者从 partition 中取出来数据的时候，也一定是有顺序的，但是消费者是多个线程并发跑的话，顺序可能就乱掉了

解决方法：

RabbitMQ：拆分多个 queue，每个 queue 一个 consumer，或者一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理

Kafka：写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性